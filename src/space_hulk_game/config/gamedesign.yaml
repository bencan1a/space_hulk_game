# Input examples for a game description

example1_pacman: >
  """
  Game Overview:

  Pac-Man is a classic arcade game where the player controls a character, Pac-Man,
  through a maze. The objective is to eat all the pellets in the maze while avoiding
  four ghosts that pursue Pac-Man. If Pac-Man eats a large power pellet, the ghosts
  turn blue, and Pac-Man can eat them for extra points.
  The game is over when Pac-Man is caught by a ghost or when the player runs out of
  lives.
  Core Game Elements:

      Maze Layout:
          The game is set within a grid-like maze. The walls are solid, and Pac-Man
          cannot pass through them.
          The maze contains corridors where Pac-Man can move in four directions: up,
          down, left, and right. Some sections of the maze loop back on themselves.
          The maze contains two types of special tiles:
              Pellets: Small dots scattered throughout the maze, worth 10 points each.
              Power Pellets: Larger dots placed in the four corners of the maze,
              worth 50 points each. Eating a Power Pellet allows Pac-Man to eat the
              ghosts for a limited time.

      Player Controls:
          The player controls Pac-Man's movement using arrow keys (or other
          directional inputs, such as WASD).
          Pac-Man moves continuously in the chosen direction until blocked by a wall
          or until the player changes direction.
          Pac-Man cannot stop moving, so the player must carefully time movements and
          changes in direction.

      Pac-Man Mechanics:
          Movement: Pac-Man moves one tile at a time in a grid-based movement system.
          Collision Detection: Pac-Man collides with walls, pellets, power pellets,
          and ghosts. Pac-Man cannot pass through walls.
          Pellet Collection: When Pac-Man moves onto a tile containing a pellet, it
          is "eaten," and the pellet disappears.
          Power Pellet Effects: Eating a Power Pellet allows Pac-Man to turn the
          ghosts blue for a short period (usually 7-10 seconds). During this time,
          Pac-Man can eat the ghosts for extra points. Ghosts revert to their regular
          form after the time limit.

      Ghosts:
          There are four ghosts: Blinky, Pinky, Inky, and Clyde. Each has a distinct
          behavior pattern:
              Blinky (Red Ghost): Aggressively pursues Pac-Man, always targeting his
              current location.
              Pinky (Pink Ghost): Attempts to ambush Pac-Man by aiming four tiles
              ahead of Pac-Man's current direction.
              Inky (Cyan Ghost): Has a more complex behavior, targeting an area
              between Pac-Man and Blinky's current location.
              Clyde (Orange Ghost): Alternates between chasing Pac-Man and wandering
              randomly when he gets too close to Pac-Man.
          Ghost Movement: Ghosts move one tile at a time, just like Pac-Man, and they
          can change directions at intersections. Their goal is to catch Pac-Man.
          Ghost States:
              Chase Mode: Ghosts actively pursue Pac-Man based on their unique
              behavior patterns.
              Scatter Mode: Ghosts move to specific corners of the maze, where they
              "scatter" and remain for a brief period before returning to Chase mode.
              Frightened Mode: After Pac-Man eats a Power Pellet, ghosts turn blue
              and flee from Pac-Man. In this mode, Pac-Man can eat them for extra
              points. When a ghost is eaten, it respawns at the center of the maze
              and resumes chasing Pac-Man.

      Scoring System:
          Eating a pellet: 10 points.
          Eating a Power Pellet: 50 points.
          Eating a ghost (in Frightened mode):
              First ghost: 200 points.
              Second ghost: 400 points.
              Third ghost: 800 points.
              Fourth ghost: 1600 points.
          Clearing a level (eating all the pellets): Bonus points for completing the
          level.

      Lives and Game Over:
          Pac-Man starts the game with 3 lives.
          If a ghost touches Pac-Man while in its normal or chase mode, Pac-Man loses
          a life.
          When all lives are lost, the game ends.

      Level Progression:
          After all pellets and Power Pellets are consumed in the maze, Pac-Man
          progresses to the next level.
          Each new level increases the game difficulty, making the ghosts move faster.
          At higher levels, the time that ghosts remain blue after eating a Power
          Pellet decreases, eventually reaching a point where they no longer turn
          blue.

      Warp Tunnels:
          The maze has two special tunnels on the left and right edges that act as
          "warp tunnels."
          When Pac-Man or the ghosts enter one side, they instantly reappear on the
          opposite side of the maze.

  Mechanics Used in the Game:

      Tile-Based Movement:
          The entire game operates on a grid, where each movement happens from one
          tile to another. Both Pac-Man and the ghosts must follow the grid's
          structure.

      Pathfinding (Ghost AI):
          The ghosts use basic pathfinding algorithms to chase Pac-Man. One common
          method for this is the A algorithm* or a simplified greedy algorithm to
          determine the shortest path toward Pac-Man.
          Each ghost has its unique targeting behavior, ranging from direct pursuit
          to attempting ambush strategies.

      State Management:
          Pac-Man's State: Handles whether Pac-Man is in a normal state, Power Pellet
          state (can eat ghosts), or has collided with a ghost.
          Ghosts' State: Manages transitions between three ghost states:
              Chase State: Actively chasing Pac-Man.
              Scatter State: Retreats to their designated corners.
              Frightened State: Turns blue and flees from Pac-Man, allowing Pac-Man
              to eat them.

      Collision Detection:
          Pellets and Pac-Man: When Pac-Man's position matches a pellet's position,
          the pellet is eaten.
          Ghosts and Pac-Man: When Pac-Man's position matches a ghost's position:
              If the ghost is in Frightened mode, Pac-Man eats the ghost.
              If the ghost is in Chase or Scatter mode, Pac-Man loses a life.

      Timer and Speed Control:
          The game runs on a time-based loop where Pac-Man and the ghosts move at set
          intervals.
          Ghosts' speeds increase over time, making higher levels more difficult.

      Level Design and Randomness:
          While the layout of the maze stays the same, the randomness in ghost
          behavior and increasing speed add variability to each playthrough.

      Game Over Conditions:
          When Pac-Man has no remaining lives, the game ends, displaying a "Game
          Over" screen.
          The players final score is shown"""

example2_pacman: >
  Build a Pacman game, where the pacman moves up, down, left, right with the use of
  keyboard arrows. each food dot he eats, he gets a point. ghosts appear at random
  times and move randomly and if they hit pacman, it loses a life, he has three lives,
  then game over. if he finishes all food points in one level, he moves on to the next
  level, in which pacman moves faster, and more ghosts appear.

example3_snake: >
  """Snake Game Description
  Objective:

  The objective of the Snake game is for the player to control a snake that moves
  across the game area, consuming food while avoiding obstacles, including its own
  tail. The snake grows longer each time it consumes food, and the game continues
  until the snake collides with the boundaries of the game area or its own body.
  Game Mechanics:

  Game Area:
      The game takes place in a rectangular grid, typically represented as a 2D matrix
      or array.
      The grid contains cells, where the snake can move and food can spawn.

  Snake Movement:
      The snake is controlled by the player, typically through arrow keys (Up, Down,
      Left, Right) or WASD keys.
      The snake moves continuously in one direction until the player changes its
      direction.
      Movement is discrete, with the snake advancing one cell per frame or tick.
      The snake's body consists of connected segments that follow the movement of the
      head, forming a continuous line.

  Growth Mechanism:
      The snake starts with a default length (e.g., 3 segments) and grows longer by
      one segment every time it eats food.
      The new segment is added to the end of the snake's body after consuming food.

  Food:
      Randomly spawns at an unoccupied position in the game area (i.e., not on the
      snake's body).
      Each piece of food can only be consumed once.
      After being consumed, a new piece of food spawns at another random position.

  Collisions:
      The game ends when the snake collides with any of the following:
          Walls: The boundaries of the game area.
          Self: The snake's own body.

  Game Rules:

  Movement:
      The snake moves continuously, and the player can change its direction using
      input keys.
      The snake cannot move in the opposite direction of its current movement (e.g.,
      if moving right, it cannot immediately move left).

  Boundaries:
      The edges of the grid act as walls. If the snake crosses these boundaries, the
      game is over.

  Self-Collision:
      The snake's body grows as it consumes food, but if the snake's head touches any
      part of its body, the game ends.

  Scoring System:

  Food Consumption:
      Every time the snake eats a piece of food, the player earns points.
      The typical scoring system could be:
          10 points per food item consumed.
      The score increases with each successful food consumption.

  Time or Speed-Based Scoring (Optional):
      Additional points can be awarded based on how long the player survives, or the
      game can speed up as the snake grows, increasing difficulty over time.

  High Score:
      The player's current score is displayed during gameplay.
      A high-score system can be implemented to keep track of the highest score
      achieved. """

example4_space_hulk: >
  """
  Objective:
    In Warhammer 40,000: Waking the Hulk, you awaken aboard a derelict Space Hulk
    adrift in the void—a labyrinth of ancient starship wrecks fused together over
    millennia. Dark whispers echo through rusted corridors, and faint, ragged chanting
    suggests a heretical cult may lurk in the shadows. As the protagonist, your goal is
    to uncover the Space Hulk's hidden horror, survive its warped denizens, and escape
    with your mind (and soul) intact.

  Story & Setting:
    Gothic Horror in the 40k Universe: The environment is oppressive and claustrophobic,
    filled with rusted corridors and lingering warp corruption.
    Overarching Mystery: Inconsistent sensor readings, half-burned logs, and cryptic
    runes suggest that a sinister force—possibly a Chaos entity—has been guiding events.
    To complete the game, you must gather clues and piece together this puzzle.

  Player Goals:
    Survive the dangers (Genestealers, Chaos cultists, malfunctioning servitors)
    prowling in the dark.
    Investigate hidden archives, shrines, and long-forgotten vaults to reveal the Space
    Hulk's secret.
    Decide your character's moral and spiritual path—champion the Emperor, embrace the
    Ruinous Powers, or walk a perilous middle course.

  Text Adventure Mechanics:
    Exploration:
        Use commands like "GO EAST," "OPEN HATCH," and "SEARCH BODY" to
        navigate rooms, discover items, and encounter story elements.
        Item Interaction:
            Acquire relics, dataslates, or damaged weapons. Combine or use
            them to bypass obstacles (e.g., repairing a laspistol to fight or a vox-unit to
            call for aid).
    Puzzles:
        Reroute power through decaying corridors, decode warded locks, or solve
        heretical riddles. Each solution uncovers lore or essential tools.
    Branching Choices:
        Dialogue prompts and moral decisions shape the narrative's
        outcome, affecting alliances and future encounters.

    Combat & Healing
        Turn-Based Combat:
            When enemies appear, you'll choose actions like "ATTACK WITH
            LASPISTOL," "DEFEND," or "USE STIM-PAK." Outcomes depend on your equipment, stats
            (such as Faith or Corruption), and the enemy's type.
            Weapon Reliability: Scavenged weapons may jam at critical moments, forcing creative
            solutions or flight.
        Health & Trauma:
            Each hit reduces health; horrifying encounters may also affect your
            Sanity. You recover health through med-kits, bionic repair stations, or rare healing
            relics. Some advanced items might restore both health and sanity—but risk drawing
            the attention of warp entities.

  Mystery & Multiple Endings:
    Central Mystery:
        A creeping evil at the Hulk's core manipulates events. Locating its
        source and unveiling its plan is key to escaping.
    Moral Pathways:
            Each path alters the final confrontation and dictates whether you depart the Hulk
            purified, damned, or something in-between.

        The Emperor's Light:
            Destroy the corruption and remain steadfast in faith.
        Ruinous Powers:
            Embrace Chaos gifts for power at the cost of your humanity.
        Middle Path:
            A precarious balance between survival and compromise,
            possibly angering both Imperium and Chaos forces.
  """

example5_game_engine_format: >
  """
  Game Engine Data Structure Examples

  This example shows the expected JSON structure for the game engine. The GameEngineerAgent
  must transform narrative content into this exact format.

  **Complete Game Structure:**
  {
    "game": {
      "title": "Space Hulk: Echoes of the Void",
      "description": "A text-based adventure in the Warhammer 40K universe",
      "starting_scene": "scene_001_hangar",
      "scenes": {
        "scene_001_hangar": {
          "id": "scene_001_hangar",
          "name": "Hangar Bay Delta",
          "description": "You stand in a vast hangar bay, the air thick with the stench of decay...",
          "exits": {
            "north": "scene_002_corridor",
            "east": "scene_003_armory",
            "examine wreckage": "scene_004_wreckage"
          },
          "items": [
            {
              "id": "item_flare",
              "name": "Emergency Flare",
              "description": "A standard Imperial Guard emergency flare",
              "takeable": true
            },
            {
              "id": "item_dataslate",
              "name": "Damaged Dataslate",
              "description": "A cracked dataslate with partial logs",
              "takeable": true
            }
          ],
          "npcs": [
            {
              "id": "npc_servitor",
              "name": "Damaged Servitor",
              "description": "A malfunctioning servitor sparks and twitches",
              "dialogue": {
                "greeting": "...unit...malfunction...warning...",
                "repeated": "...systems...failing..."
              }
            }
          ],
          "events": [],
          "dark": false,
          "locked_exits": {}
        },
        "scene_002_corridor": {
          "id": "scene_002_corridor",
          "name": "Main Corridor",
          "description": "A long corridor stretches before you, walls covered in ancient grime...",
          "exits": {
            "south": "scene_001_hangar",
            "north": "scene_005_chapel",
            "west": "scene_006_lab"
          },
          "items": [],
          "npcs": [],
          "events": [],
          "dark": true,
          "locked_exits": {
            "north": "item_chapel_key"
          }
        },
        "scene_final_escape": {
          "id": "scene_final_escape",
          "name": "Extraction Point",
          "description": "You reach the extraction point as the hulk begins to collapse...",
          "exits": {},
          "items": [],
          "npcs": [],
          "events": [],
          "dark": false,
          "locked_exits": {}
        }
      },
      "global_items": {},
      "global_npcs": {},
      "endings": [
        {
          "id": "ending_victory",
          "scene_id": "scene_final_escape",
          "name": "Victorious Escape",
          "description": "Against all odds, you escaped the Space Hulk alive",
          "ending_type": "victory"
        },
        {
          "id": "ending_sacrifice",
          "scene_id": "scene_final_sacrifice",
          "name": "Noble Sacrifice",
          "description": "You gave your life to ensure your brothers escaped",
          "ending_type": "sacrifice"
        }
      ]
    }
  }

  **Key Mapping Rules:**

  1. Scene Connections -> Exits (MUST BE BIDIRECTIONAL):
     Narrative: "connections": [{"target": "scene_002", "condition": "..."}]
     Game Engine: "exits": {"north": "scene_002"}

     **CRITICAL: Exits must be bidirectional!**
     If scene_001 has "north" -> scene_002, then scene_002 MUST have "south" -> scene_001

     Example of correct bidirectional exits:
     scene_001_hangar: {"exits": {"north": "scene_002_corridor"}}
     scene_002_corridor: {"exits": {"south": "scene_001_hangar"}}

     Example with location names:
     scene_001_hangar: {"exits": {"corridor": "scene_002_corridor"}}
     scene_002_corridor: {"exits": {"hangar": "scene_001_hangar"}}

     Use directional pairs: north↔south, east↔west, up↔down, forward↔back
     Use location pairs: name the source location in reverse exit

  2. Decision Points -> Multiple Exits (NOT Events):
     Narrative: "decision_points": [{"options": ["choice A", "choice B"]}]
     Game Engine: "exits": {"choice_a_route": "scene_a", "choice_b_route": "scene_b"}

     **IMPORTANT**: Decision points are player choices, so they become multiple exits.
     Do NOT create events for decision points. Events are automatic story triggers.

  3. Character Moments -> NPCs:
     Narrative: "character_moments": [{"character": "Valerius", "moment": "..."}]
     Game Engine: "npcs": [{"id": "npc_valerius", "name": "Captain Valerius", ...}]

  4. Artifacts -> Items:
     Narrative: puzzle_design.artifacts: [{"name": "Xenos Device", ...}]
     Game Engine: "items": [{"id": "item_xenos_device", "name": "Xenos Device", ...}]

  5. Scene Descriptions:
     Always use the full description from scene_texts.json, not the summary from narrative_map.json

  6. Events (Automatic Story Triggers):
     Events are for automatic triggers when entering a scene (NOT for player choices).
     Event structure: {"id": "event_id", "description": "What happens", "trigger_on_entry": true}
     Example: Alarm sounds, NPC flees, door seals automatically
     **DO NOT** use events for decision points - those become multiple exits

  **Validation Checklist:**
  - ✅ All scenes have an "id" field matching the key
  - ✅ All scenes have "name", "description", and "exits"
  - ✅ Exits dictionary maps direction/action to scene IDs
  - ✅ **ALL EXITS ARE BIDIRECTIONAL** (if A→B exists, then B→A must exist)
  - ✅ Exit names use proper directional pairs (north↔south, east↔west)
  - ✅ Exit names are grammatically correct (work with "There is an exit to the [NAME]")
  - ✅ Decision points are mapped to multiple exits (NOT events)
  - ✅ All events have required "id" and "description" fields
  - ✅ Events do NOT have "type", "prompt", or "options" (those are for exits)
  - ✅ Most scenes have "events": [] unless specific story triggers exist
  - ✅ Starting scene exists in scenes dictionary
  - ✅ All exit targets exist as scene IDs
  - ✅ Ending scenes are marked in endings array
  - ✅ At least one path from start to an ending exists
  - ✅ Items have id, name, description, takeable
  - ✅ NPCs have id, name, description, dialogue
  - ✅ No orphaned scenes (unreachable from start)
  """
