"""
Tests for the Space Hulk Game implementation.
These tests verify input validation, error handling, and output processing.
"""
import sys
import os
import unittest
from unittest.mock import patch, MagicMock
import json
import datetime

# Add the src directory to the path so we can import the module
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../')))

# Create mock classes to avoid loading real configuration
class MockSpaceHulkGame:
    """Mock class for SpaceHulkGame to test specific methods without initialization issues."""
    
    def prepare_inputs(self, inputs):
        """
        Hook method that validates inputs before the crew starts.
        Ensures required fields are present and adds additional data.
        """
        try:
            # Validate required inputs
            if "prompt" not in inputs:
                raise ValueError("Input must contain a 'prompt' key")
                
            # Process inputs
            inputs["additional_data"] = "Some extra information for the first task."
            return inputs
        except Exception as e:
            # Log error and provide recovery mechanism
            print(f"Error in prepare_inputs: {str(e)}")
            # Set default values if possible
            inputs["prompt"] = inputs.get("prompt", "Default space hulk exploration scenario")
            return inputs
    
    def handle_task_failure(self, task, exception):
        """
        Handle task execution failures with appropriate recovery mechanisms.
        Provides task-specific fallback content to allow the process to continue.
        """
        error_message = f"Error executing task '{task.name}': {str(exception)}"
        print(error_message)
        
        # Task-specific recovery mechanisms
        if task.name == "Generate Overarching Plot":
            # Return a basic default plot outline
            return {
                "plot_outline": {
                    "title": "Default Space Hulk Adventure",
                    "setting": "Derelict space vessel",
                    "main_branches": [
                        {"path": "Exploration", "description": "Explore the vessel cautiously"},
                        {"path": "Combat", "description": "Fight through hostile entities"}
                    ],
                    "endings": [
                        {"name": "Escape", "description": "Successfully escape the vessel"},
                        {"name": "Trapped", "description": "Become trapped in the vessel"}
                    ]
                }
            }
        elif task.name == "Create Narrative Map":
            # Return a basic narrative map
            return {
                "narrative_tree": {
                    "start_scene": "entrance",
                    "scenes": {
                        "entrance": {"description": "The entrance", "connections": ["corridor"]}
                    }
                }
            }
        elif task.name == "Design Artifacts, Puzzles, Monsters, and NPCs":
            # Return basic puzzle design
            return {
                "puzzle_design": {
                    "puzzles": [{"name": "Engine Repair", "description": "Repair the engine"}]
                }
            }
        elif task.name == "Write Scene Descriptions and Dialogue":
            # Return basic scene descriptions
            return {
                "scene_texts": {
                    "entrance": {"description": "The massive entrance hatch creaks open"}
                }
            }
        elif task.name == "Create Game Mechanics PRD":
            # Return basic PRD document
            return {
                "prd_document": {
                    "game_title": "Space Hulk: Derelict Vessel"
                }
            }
        
        # Default fallback
        return {"error": error_message, "recovered": False}
    
    def process_output(self, output):
        """
        Hook method that modifies the final output after the crew finishes all tasks.
        Adds metadata and formats the output for better usability.
        """
        try:
            # Add metadata about the processing
            output.metadata = {
                "processed_at": str(datetime.datetime.now()),
                "validation_applied": True,
                "error_handling_applied": True
            }
            
            # If your tasks produce text-based outputs, you might do formatting here
            output.raw += "\n\n[Final post-processing complete with validation and error handling.]"
            
            # Check if there were any errors during processing
            if hasattr(output, 'errors') and output.errors:
                output.raw += "\n\n[WARNING: Some errors occurred during processing. " \
                             "Recovery mechanisms were applied, but you should review the content.]"
            
            return output
        except Exception as e:
            # Handle any errors in post-processing
            print(f"Error in post-processing: {str(e)}")
            # Return original output if post-processing fails
            return output

class TestSpaceHulkGame(unittest.TestCase):
    """Test cases for the Space Hulk Game crew implementation."""
    
    def setUp(self):
        """Set up test fixtures."""
        self.game = MockSpaceHulkGame()
    
    def test_prepare_inputs_with_valid_prompt(self):
        """Test prepare_inputs with a valid prompt."""
        inputs = {"prompt": "Create a space hulk adventure"}
        result = self.game.prepare_inputs(inputs)
        self.assertIn("prompt", result)
        self.assertIn("additional_data", result)
    
    def test_prepare_inputs_with_missing_prompt(self):
        """Test prepare_inputs with missing prompt."""
        inputs = {}
        result = self.game.prepare_inputs(inputs)
        self.assertIn("prompt", result)  # Should have added a default prompt
        self.assertEqual(result["prompt"], "Default space hulk exploration scenario")
    
    def test_handle_task_failure(self):
        """Test handle_task_failure with different task types."""
        # Test for Generate Overarching Plot
        class MockTask:
            name = "Generate Overarching Plot"
        
        task = MockTask()
        exception = Exception("Test error")
        result = self.game.handle_task_failure(task, exception)
        self.assertIn("plot_outline", result)
        
        # Test for Create Narrative Map
        task.name = "Create Narrative Map"
        result = self.game.handle_task_failure(task, exception)
        self.assertIn("narrative_tree", result)
        
        # Test for Design Artifacts
        task.name = "Design Artifacts, Puzzles, Monsters, and NPCs"
        result = self.game.handle_task_failure(task, exception)
        self.assertIn("puzzle_design", result)
        
        # Test for Write Scene Descriptions
        task.name = "Write Scene Descriptions and Dialogue"
        result = self.game.handle_task_failure(task, exception)
        self.assertIn("scene_texts", result)
        
        # Test for Create Game Mechanics PRD
        task.name = "Create Game Mechanics PRD"
        result = self.game.handle_task_failure(task, exception)
        self.assertIn("prd_document", result)
        
        # Test for default fallback
        task.name = "Unknown Task"
        result = self.game.handle_task_failure(task, exception)
        self.assertIn("error", result)
        self.assertIn("recovered", result)
        self.assertEqual(result["recovered"], False)
    
    def test_process_output(self):
        """Test process_output method."""
        # Create a mock output object
        class MockOutput:
            def __init__(self):
                self.raw = "Test output"
        
        output = MockOutput()
        result = self.game.process_output(output)
        
        # Verify the output was modified
        self.assertNotEqual(result.raw, "Test output")
        self.assertTrue(hasattr(result, 'metadata'))
        self.assertIn("processed_at", result.metadata)

if __name__ == '__main__':
    unittest.main()