# Game Engine Architecture

## Overview

The Space Hulk game engine is a **text-based adventure game engine** designed to run games generated by AI agents using the CrewAI framework. It follows clean architecture principles and proven design patterns to ensure maintainability, testability, and extensibility.

## Table of Contents

- [Architecture Overview](#architecture-overview)
- [Core Components](#core-components)
- [Design Patterns](#design-patterns)
- [Data Flow](#data-flow)
- [Extending the Engine](#extending-the-engine)
- [Testing Strategy](#testing-strategy)

## Architecture Overview

The engine follows a **layered architecture** with clear separation of concerns:

```
┌─────────────────────────────────────────────────────────┐
│                   CLI Layer (demo_game.py)              │
│  - User interface                                        │
│  - Input/output handling                                │
│  - Save/load menus                                       │
└────────────────┬────────────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────────────┐
│              Engine Layer (engine.py)                    │
│  - Game loop                                             │
│  - Action execution                                      │
│  - State transitions                                     │
└────────────────┬────────────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────────────┐
│         Domain Model Layer                               │
│  - GameState (game_state.py)                            │
│  - Scene (scene.py)                                      │
│  - Entities (entities.py)                                │
└────────────────┬────────────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────────────┐
│          Infrastructure Layer                            │
│  - ContentLoader (loader.py)                            │
│  - GameValidator (validator.py)                          │
│  - Persistence (persistence.py)                          │
│  - CommandParser (parser.py)                             │
└─────────────────────────────────────────────────────────┘
```

### Architectural Principles

1. **Separation of Concerns**: Each component has a single, well-defined responsibility
2. **Dependency Inversion**: High-level modules don't depend on low-level modules
3. **Single Responsibility**: Each class has one reason to change
4. **Open/Closed**: Open for extension, closed for modification
5. **Testability**: All components are independently testable

## Core Components

### 1. TextAdventureEngine (engine.py)

**Purpose**: Main game loop and action orchestration

**Responsibilities**:
- Running the game loop
- Processing player input
- Executing actions
- Managing state transitions
- Checking victory/defeat conditions

**Key Methods**:
```python
def run(self) -> None:
    """Start the main game loop."""

def _execute_action(self, action: Action) -> None:
    """Execute a parsed action and update game state."""

def handle_move(self, direction: str) -> None:
    """Handle movement to another scene."""
```

**Design Pattern**: **Facade Pattern** - Provides a simple interface to complex subsystems

### 2. GameState (game_state.py)

**Purpose**: Represents the current state of the game

**Responsibilities**:
- Tracking player location
- Managing inventory
- Storing flags and variables
- Recording visited scenes

**Key Attributes**:
```python
current_scene: str        # Current scene ID
inventory: List[Item]     # Player's items
flags: Set[str]          # Game flags (e.g., "door_unlocked")
game_variables: Dict     # Dynamic variables
visited_scenes: Set[str] # Exploration tracking
```

**Design Pattern**: **Memento Pattern** - Enables save/load functionality

### 3. Scene (scene.py)

**Purpose**: Represents a location in the game world

**Responsibilities**:
- Storing scene description
- Managing exits (connections to other scenes)
- Containing items and NPCs
- Handling events and locked exits

**Key Attributes**:
```python
id: str                          # Unique identifier
name: str                        # Display name
description: str                 # Scene description
exits: Dict[str, str]           # direction -> scene_id
items: List[Item]               # Items in scene
npcs: List[NPC]                 # NPCs in scene
locked_exits: Dict[str, str]    # exit -> required_key_id
```

**Design Pattern**: **Composite Pattern** - Scenes contain items and NPCs

### 4. ContentLoader (loader.py)

**Purpose**: Loads AI-generated YAML files into game objects

**Responsibilities**:
- Loading 5 YAML files (plot, narrative, puzzles, scenes, mechanics)
- Parsing YAML with error handling
- Converting YAML to engine objects
- Validating loaded content

**Key Methods**:
```python
def load_game(self, output_dir: str) -> GameData:
    """Load all generated YAML files into a playable game."""

def load_yaml(self, filepath: str) -> Dict[str, Any]:
    """Load a single YAML file with error handling."""
```

**Design Pattern**: **Builder Pattern** - Constructs complex GameData from YAML

### 5. CommandParser (parser.py)

**Purpose**: Parses natural language commands into Action objects

**Responsibilities**:
- Tokenizing input
- Recognizing command patterns
- Creating Action objects
- Handling ambiguous input

**Supported Commands**:
- Movement: `go north`, `north`, `n`
- Items: `take key`, `drop sword`, `use key on door`
- Interaction: `talk to npc`, `look`, `inventory`
- Meta: `help`, `quit`, `save`

**Design Pattern**: **Command Pattern** - Commands as objects

### 6. Actions (actions.py)

**Purpose**: Represents player actions as executable objects

**Action Types**:
```python
MoveAction       # Move to another scene
TakeAction       # Pick up an item
DropAction       # Drop an item
UseAction        # Use an item
LookAction       # Examine something
InventoryAction  # View inventory
TalkAction       # Talk to NPC
HelpAction       # Display help
```

**Design Pattern**: **Command Pattern** - Encapsulates actions as objects

### 7. Persistence (persistence.py)

**Purpose**: Saves and loads game state

**Responsibilities**:
- Serializing GameState to JSON
- Deserializing JSON to GameState
- Managing save files
- Listing available saves

**Key Methods**:
```python
def save(self, game_state: GameState, save_name: str) -> None:
    """Save game state to file."""

def load(self, save_name: str) -> GameState:
    """Load game state from file."""
```

**Design Pattern**: **Memento Pattern** - Captures and restores state

### 8. GameValidator (validator.py)

**Purpose**: Validates game content for correctness

**Responsibilities**:
- Checking scene connectivity
- Verifying all exits lead to valid scenes
- Validating item and NPC references
- Detecting unreachable content

**Key Methods**:
```python
def validate_game(self, game_data: GameData) -> ValidationResult:
    """Validate a complete game for correctness."""
```

**Design Pattern**: **Strategy Pattern** - Different validation strategies

### 9. DemoGameCLI (demo_game.py)

**Purpose**: Command-line interface for playing games

**Responsibilities**:
- Title screen and menus
- Colorized output
- Save/load UI
- Help system
- Integration with TextAdventureEngine

**Design Pattern**: **Facade Pattern** - Simplified interface for complex system

## Design Patterns

### Gang of Four Patterns Used

1. **Facade Pattern**
   - `TextAdventureEngine`: Simplifies interaction with complex subsystems
   - `DemoGameCLI`: Provides simple interface to engine and persistence

2. **Command Pattern**
   - `Action` classes: Encapsulate actions as objects
   - Enables undo/redo (future enhancement)

3. **Builder Pattern**
   - `ContentLoader`: Constructs complex `GameData` from YAML files

4. **Memento Pattern**
   - `GameState` + `SaveSystem`: Capture and restore game state

5. **Composite Pattern**
   - `Scene` contains `Item` and `NPC` objects

6. **Strategy Pattern**
   - `GameValidator`: Different validation strategies

### SOLID Principles

**Single Responsibility Principle (SRP)**
- Each class has one reason to change
- `CommandParser` only parses commands
- `SaveSystem` only handles persistence
- `ContentLoader` only loads content

**Open/Closed Principle (OCP)**
- New action types can be added without modifying engine
- New validation rules can be added to validator
- Extensible through inheritance and composition

**Liskov Substitution Principle (LSP)**
- All `Action` subclasses can be used interchangeably
- Custom loaders can replace `ContentLoader`

**Interface Segregation Principle (ISP)**
- Small, focused interfaces
- Components only depend on methods they use

**Dependency Inversion Principle (DIP)**
- Engine depends on abstract `Action`, not concrete implementations
- Custom I/O functions can be injected for testing

## Data Flow

### Game Initialization Flow

```
1. DemoGameCLI created
   ↓
2. ContentLoader.load_game("fixtures/")
   ↓
3. Load 5 YAML files:
   - plot_outline.yaml
   - narrative_map.yaml
   - puzzle_design.yaml
   - scene_texts.yaml
   - prd_document.yaml
   ↓
4. Convert YAML → GameData (scenes, items, NPCs, etc.)
   ↓
5. GameValidator.validate_game(game_data)
   ↓
6. Create GameState (starting scene)
   ↓
7. Create TextAdventureEngine(game_state, scenes)
   ↓
8. engine.run()
```

### Command Processing Flow

```
1. Player enters command: "go north"
   ↓
2. CommandParser.parse("go north", game_state, current_scene)
   ↓
3. Returns MoveAction(direction="north")
   ↓
4. engine._execute_action(move_action)
   ↓
5. engine.handle_move("north")
   ↓
6. Check if exit exists and is unlocked
   ↓
7. Update game_state.current_scene
   ↓
8. Display new scene description
   ↓
9. Process entry events
   ↓
10. Check victory/defeat conditions
```

### Save/Load Flow

```
Save:
1. User selects "save" from menu
   ↓
2. Enter save name
   ↓
3. SaveSystem.save(game_state, "save_name")
   ↓
4. Serialize GameState to JSON
   ↓
5. Write to saves/save_name.json

Load:
1. User selects "load" from menu
   ↓
2. SaveSystem.list_saves() → display options
   ↓
3. User selects save
   ↓
4. SaveSystem.load("save_name")
   ↓
5. Read saves/save_name.json
   ↓
6. Deserialize JSON → GameState
   ↓
7. Create new engine with loaded state
```

## Extending the Engine

### Adding New Action Types

1. Create new action class in `actions.py`:

```python
class ExamineAction(Action):
    """Action for examining items/NPCs closely."""

    def __init__(self, target_id: str):
        self.target_id = target_id

    def __str__(self) -> str:
        return f"ExamineAction(target={self.target_id})"
```

2. Add handler to `TextAdventureEngine`:

```python
def handle_examine(self, target_id: str) -> None:
    """Handle examining a target."""
    # Implementation
    pass
```

3. Update `_execute_action` to route to handler:

```python
elif isinstance(action, ExamineAction):
    self.handle_examine(action.target_id)
```

4. Update `CommandParser` to recognize the command:

```python
def _parse_examine(self, tokens: List[str], ...) -> Action:
    """Parse examine command."""
    # Implementation
    return ExamineAction(target_id)
```

### Adding New Game Mechanics

**Example: Combat System**

1. Add combat-related fields to `GameState`:

```python
@dataclass
class GameState:
    # ... existing fields ...
    health: int = 100
    armor: int = 0
```

2. Create combat entities in `entities.py`:

```python
@dataclass
class Enemy:
    id: str
    name: str
    health: int
    damage: int
    armor: int
```

3. Add combat actions:

```python
class AttackAction(Action):
    def __init__(self, target_id: str):
        self.target_id = target_id
```

4. Implement combat handler in engine:

```python
def handle_attack(self, target_id: str) -> None:
    """Handle combat."""
    # Combat logic
    pass
```

### Adding Custom Content Loaders

Extend `ContentLoader` for custom formats:

```python
class CustomContentLoader(ContentLoader):
    """Loads game from custom format."""

    def load_game(self, source: str) -> GameData:
        """Load from custom source."""
        # Custom loading logic
        return game_data
```

## Testing Strategy

### Test Pyramid

```
         /\
        /  \  E2E Tests (5%)
       /────\  - Full game playthroughs
      /      \ - Integration tests
     /────────\
    /  Unit    \ Unit Tests (70%)
   /   Tests    \ - Individual components
  /──────────────\ - Mock dependencies
 /  Integration  \
/     Tests       \ Integration Tests (25%)
──────────────────── - Component interaction
```

### Test Categories

**1. Unit Tests**
- Test individual components in isolation
- Mock all dependencies
- Fast execution (<1ms per test)
- High coverage (>90%)

Example:
```python
def test_command_parser_move(self):
    """Test parsing move command."""
    parser = CommandParser()
    action = parser.parse("go north", mock_state, mock_scene)
    self.assertIsInstance(action, MoveAction)
    self.assertEqual(action.direction, "north")
```

**2. Integration Tests**
- Test component interaction
- Minimal mocking
- Medium speed (~10-100ms per test)

Example:
```python
def test_engine_with_loader(self):
    """Test engine with loaded content."""
    loader = ContentLoader()
    game_data = loader.load_game("fixtures/")
    engine = TextAdventureEngine(...)
    # Test engine with real data
```

**3. End-to-End Tests**
- Test complete workflows
- No mocking
- Slower execution (~100ms-1s per test)

Example:
```python
def test_full_game_workflow(self):
    """Test load → play → save → load → continue."""
    # Complete workflow test
```

### Testing Best Practices

1. **Arrange-Act-Assert Pattern**
   - Arrange: Set up test data
   - Act: Execute the operation
   - Assert: Verify the results

2. **Given-When-Then** (for integration tests)
   - Given: Initial state
   - When: Action occurs
   - Then: Expected outcome

3. **Fixtures and Factories**
   - Use test fixtures for consistent data
   - Factory functions for test objects

4. **Mock External Dependencies**
   - Mock I/O operations
   - Mock file system access
   - Mock LLM calls

## Performance Considerations

### Optimization Strategies

1. **Lazy Loading**
   - Load scenes on-demand rather than all at once
   - Cache scene descriptions

2. **Efficient Lookups**
   - Use dictionaries for O(1) lookups
   - Index scenes, items, NPCs by ID

3. **Memory Management**
   - Clean up unused objects
   - Limit event history size

4. **String Operations**
   - Use string formatting over concatenation
   - Cache frequently used strings

### Scalability

The engine is designed to handle:
- **100+ scenes**: Tested with large game worlds
- **1000+ items**: Efficient item lookup
- **100+ NPCs**: Optimized NPC management
- **10000+ events**: Event history pruning

## Error Handling

### Error Handling Strategy

1. **Validation at Boundaries**
   - Validate input at system boundaries
   - Fail fast on invalid data

2. **Specific Exceptions**
   - Use specific exception types
   - Avoid bare `except` clauses

3. **Graceful Degradation**
   - Handle missing data gracefully
   - Provide sensible defaults

4. **Logging**
   - Log all errors with context
   - Use appropriate log levels

### Exception Hierarchy

```python
LoaderError                 # Base for loading errors
├── YAMLParseError         # YAML parsing failed
├── ValidationError        # Content validation failed
└── FileNotFoundError      # File not found

EngineError                # Base for engine errors
├── InvalidActionError     # Invalid action
├── InvalidSceneError      # Scene not found
└── InvalidStateError      # Invalid game state
```

## Logging

### Log Levels

- **DEBUG**: Detailed information for diagnosing problems
- **INFO**: Confirmation that things are working as expected
- **WARNING**: Something unexpected happened
- **ERROR**: A serious problem occurred
- **CRITICAL**: The program may not be able to continue

### Logging Strategy

```python
# At module level
logger = logging.getLogger(__name__)

# In code
logger.debug(f"Parsing command: {command}")
logger.info(f"Game started with {len(scenes)} scenes")
logger.warning(f"Missing optional field: {field_name}")
logger.error(f"Failed to load scene: {scene_id}")
logger.exception("Unexpected error in game loop")
```

## Future Enhancements

### Planned Features

1. **Combat System**
   - Turn-based combat
   - Weapons and armor
   - Enemy AI

2. **Quest System**
   - Quest tracking
   - Objectives
   - Rewards

3. **Dialogue Trees**
   - Branching conversations
   - Choice-based outcomes
   - NPC relationships

4. **Multiplayer**
   - Multi-player cooperation
   - Shared world state
   - Turn-based play

5. **Scripting Support**
   - Lua scripting for custom logic
   - Event scripting
   - Custom commands

## References

- [CrewAI Documentation](https://docs.crewai.com/)
- [Design Patterns: Gang of Four](https://en.wikipedia.org/wiki/Design_Patterns)
- [SOLID Principles](https://en.wikipedia.org/wiki/SOLID)
- [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)

## Contributing

See [CONTRIBUTING.md](CONTRIBUTING.md) for development guidelines and best practices.

---

**Last Updated**: 2024-11-10
**Version**: 1.0
**Authors**: Space Hulk Development Team
