<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>space_hulk_game.validation API documentation</title>
<meta name="description" content="Validation module for Space Hulk Game YAML outputs …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>space_hulk_game.validation</code></h1>
</header>
<section id="section-intro">
<p>Validation module for Space Hulk Game YAML outputs.</p>
<p>This module provides validators and auto-correctors for parsing, validating,
and fixing YAML outputs from AI agents against Pydantic schemas.</p>
<p>DEPRECATED: This module is deprecated as the system has migrated to JSON outputs.
JSON mode in LLMs guarantees valid syntax, eliminating the need for this validation layer.
For game playability validation, use space_hulk_game.engine.validator instead.</p>
<h2 id="exports">Exports</h2>
<p>ProcessingResult: Unified result type for all processing operations (NEW)
OutputValidator: Main validator class for all YAML outputs (DEPRECATED)
ValidationResult: Result dataclass containing validation status and errors (DEPRECATED)
OutputCorrector: Auto-corrector for fixing common YAML validation errors (DEPRECATED)
CorrectionResult: Result dataclass containing correction status and changes (DEPRECATED)</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="space_hulk_game.validation.corrector" href="corrector.html">space_hulk_game.validation.corrector</a></code></dt>
<dd>
<div class="desc"><p>Auto-correction for YAML validation outputs …</p></div>
</dd>
<dt><code class="name"><a title="space_hulk_game.validation.types" href="types.html">space_hulk_game.validation.types</a></code></dt>
<dd>
<div class="desc"><p>Unified result types for validation and processing operations …</p></div>
</dd>
<dt><code class="name"><a title="space_hulk_game.validation.types" href="types.html">space_hulk_game.validation.types</a></code></dt>
<dd>
<div class="desc"><p>Unified result types for validation and processing operations …</p></div>
</dd>
<dt><code class="name"><a title="space_hulk_game.validation.validator" href="validator.html">space_hulk_game.validation.validator</a></code></dt>
<dd>
<div class="desc"><p>Output validation for Space Hulk Game YAML outputs …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="space_hulk_game.validation.CorrectionResult"><code class="flex name class">
<span>class <span class="ident">CorrectionResult</span></span>
<span>(</span><span>corrected_yaml: str,<br>corrections: list[str],<br>validation_result: <a title="space_hulk_game.validation.ValidationResult" href="#space_hulk_game.validation.ValidationResult">ValidationResult</a>,<br>success: bool)</span>
<span>(</span><span>corrected_yaml: str,<br>corrections: list[str],<br>validation_result: <a title="space_hulk_game.validation.ValidationResult" href="#space_hulk_game.validation.ValidationResult">ValidationResult</a>,<br>success: bool)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class CorrectionResult:
    &#34;&#34;&#34;Result of attempting to auto-correct YAML output.

    NOTE: CorrectionResult is kept for backward compatibility.
    New code should use ProcessingResult from validation.types

    NOTE: CorrectionResult is kept for backward compatibility.
    New code should use ProcessingResult from validation.types

    Attributes:
        corrected_yaml: The corrected YAML string.
        corrections: List of corrections applied.
        validation_result: Result from validating the corrected output.
        success: Whether correction succeeded and output is now valid.

    Example:
        &gt;&gt;&gt; result = CorrectionResult(
        ...     corrected_yaml=&#34;title: Fixed\\n...&#34;,
        ...     corrections=[&#34;Added missing &#39;plot_points&#39; field&#34;],
        ...     validation_result=ValidationResult(...),
        ...     success=True
        ... )
    &#34;&#34;&#34;

    corrected_yaml: str
    corrections: list[str]
    validation_result: ValidationResult
    success: bool

    def to_processing_result(self) -&gt; ProcessingResult:
        &#34;&#34;&#34;Convert to unified ProcessingResult type.

        Returns:
            ProcessingResult instance with equivalent data.

        Example:
            &gt;&gt;&gt; result = CorrectionResult(
            ...     corrected_yaml=&#34;title: Fixed&#34;,
            ...     corrections=[&#34;Fixed ID&#34;],
            ...     validation_result=ValidationResult(valid=True, data=None, errors=[]),
            ...     success=True
            ... )
            &gt;&gt;&gt; processing_result = result.to_processing_result()
            &gt;&gt;&gt; processing_result.is_valid
            True
        &#34;&#34;&#34;
        from space_hulk_game.validation.types import ProcessingResult  # noqa: PLC0415

        return ProcessingResult(
            success=self.success,
            data=None,  # corrected_yaml is in metadata
            errors=self.validation_result.errors if self.validation_result else [],
            warnings=self.validation_result.warnings if self.validation_result else [],
            corrections=self.corrections,
            metadata={&#34;corrected_yaml&#34;: self.corrected_yaml},
        )</code></pre>
    success: bool

    def to_processing_result(self) -&gt; ProcessingResult:
        &#34;&#34;&#34;Convert to unified ProcessingResult type.

        Returns:
            ProcessingResult instance with equivalent data.

        Example:
            &gt;&gt;&gt; result = CorrectionResult(
            ...     corrected_yaml=&#34;title: Fixed&#34;,
            ...     corrections=[&#34;Fixed ID&#34;],
            ...     validation_result=ValidationResult(valid=True, data=None, errors=[]),
            ...     success=True
            ... )
            &gt;&gt;&gt; processing_result = result.to_processing_result()
            &gt;&gt;&gt; processing_result.is_valid
            True
        &#34;&#34;&#34;
        from space_hulk_game.validation.types import ProcessingResult  # noqa: PLC0415

        return ProcessingResult(
            success=self.success,
            data=None,  # corrected_yaml is in metadata
            errors=self.validation_result.errors if self.validation_result else [],
            warnings=self.validation_result.warnings if self.validation_result else [],
            corrections=self.corrections,
            metadata={&#34;corrected_yaml&#34;: self.corrected_yaml},
        )</code></pre>
</details>
<div class="desc"><p>Result of attempting to auto-correct YAML output.</p>
<p>NOTE: CorrectionResult is kept for backward compatibility.
New code should use ProcessingResult from validation.types</p>
<p>NOTE: CorrectionResult is kept for backward compatibility.
New code should use ProcessingResult from validation.types</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>corrected_yaml</code></strong></dt>
<dd>The corrected YAML string.</dd>
<dt><strong><code>corrections</code></strong></dt>
<dd>List of corrections applied.</dd>
<dt><strong><code>validation_result</code></strong></dt>
<dd>Result from validating the corrected output.</dd>
<dt><strong><code>success</code></strong></dt>
<dd>Whether correction succeeded and output is now valid.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; result = CorrectionResult(
...     corrected_yaml=&quot;title: Fixed\n...&quot;,
...     corrections=[&quot;Added missing 'plot_points' field&quot;],
...     validation_result=ValidationResult(...),
...     success=True
... )
</code></pre></div>
<h3>Instance variables</h3>
<dl>
<dt id="space_hulk_game.validation.CorrectionResult.corrected_yaml"><code class="name">var <span class="ident">corrected_yaml</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.validation.CorrectionResult.corrections"><code class="name">var <span class="ident">corrections</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.validation.CorrectionResult.success"><code class="name">var <span class="ident">success</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.validation.CorrectionResult.validation_result"><code class="name">var <span class="ident">validation_result</span> : <a title="space_hulk_game.validation.validator.ValidationResult" href="validator.html#space_hulk_game.validation.validator.ValidationResult">ValidationResult</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="space_hulk_game.validation.CorrectionResult.to_processing_result"><code class="name flex">
<span>def <span class="ident">to_processing_result</span></span>(<span>self) ‑> <a title="space_hulk_game.validation.ProcessingResult" href="#space_hulk_game.validation.ProcessingResult">ProcessingResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_processing_result(self) -&gt; ProcessingResult:
    &#34;&#34;&#34;Convert to unified ProcessingResult type.

    Returns:
        ProcessingResult instance with equivalent data.

    Example:
        &gt;&gt;&gt; result = CorrectionResult(
        ...     corrected_yaml=&#34;title: Fixed&#34;,
        ...     corrections=[&#34;Fixed ID&#34;],
        ...     validation_result=ValidationResult(valid=True, data=None, errors=[]),
        ...     success=True
        ... )
        &gt;&gt;&gt; processing_result = result.to_processing_result()
        &gt;&gt;&gt; processing_result.is_valid
        True
    &#34;&#34;&#34;
    from space_hulk_game.validation.types import ProcessingResult  # noqa: PLC0415

    return ProcessingResult(
        success=self.success,
        data=None,  # corrected_yaml is in metadata
        errors=self.validation_result.errors if self.validation_result else [],
        warnings=self.validation_result.warnings if self.validation_result else [],
        corrections=self.corrections,
        metadata={&#34;corrected_yaml&#34;: self.corrected_yaml},
    )</code></pre>
</details>
<div class="desc"><p>Convert to unified ProcessingResult type.</p>
<h2 id="returns">Returns</h2>
<p>ProcessingResult instance with equivalent data.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; result = CorrectionResult(
...     corrected_yaml=&quot;title: Fixed&quot;,
...     corrections=[&quot;Fixed ID&quot;],
...     validation_result=ValidationResult(valid=True, data=None, errors=[]),
...     success=True
... )
&gt;&gt;&gt; processing_result = result.to_processing_result()
&gt;&gt;&gt; processing_result.is_valid
True
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="space_hulk_game.validation.CorrectionResult.to_processing_result"><code class="name flex">
<span>def <span class="ident">to_processing_result</span></span>(<span>self) ‑> <a title="space_hulk_game.validation.ProcessingResult" href="#space_hulk_game.validation.ProcessingResult">ProcessingResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_processing_result(self) -&gt; ProcessingResult:
    &#34;&#34;&#34;Convert to unified ProcessingResult type.

    Returns:
        ProcessingResult instance with equivalent data.

    Example:
        &gt;&gt;&gt; result = CorrectionResult(
        ...     corrected_yaml=&#34;title: Fixed&#34;,
        ...     corrections=[&#34;Fixed ID&#34;],
        ...     validation_result=ValidationResult(valid=True, data=None, errors=[]),
        ...     success=True
        ... )
        &gt;&gt;&gt; processing_result = result.to_processing_result()
        &gt;&gt;&gt; processing_result.is_valid
        True
    &#34;&#34;&#34;
    from space_hulk_game.validation.types import ProcessingResult  # noqa: PLC0415

    return ProcessingResult(
        success=self.success,
        data=None,  # corrected_yaml is in metadata
        errors=self.validation_result.errors if self.validation_result else [],
        warnings=self.validation_result.warnings if self.validation_result else [],
        corrections=self.corrections,
        metadata={&#34;corrected_yaml&#34;: self.corrected_yaml},
    )</code></pre>
</details>
<div class="desc"><p>Convert to unified ProcessingResult type.</p>
<h2 id="returns">Returns</h2>
<p>ProcessingResult instance with equivalent data.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; result = CorrectionResult(
...     corrected_yaml=&quot;title: Fixed&quot;,
...     corrections=[&quot;Fixed ID&quot;],
...     validation_result=ValidationResult(valid=True, data=None, errors=[]),
...     success=True
... )
&gt;&gt;&gt; processing_result = result.to_processing_result()
&gt;&gt;&gt; processing_result.is_valid
True
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.validation.OutputCorrector"><code class="flex name class">
<span>class <span class="ident">OutputCorrector</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OutputCorrector:
    &#34;&#34;&#34;Auto-corrector for YAML validation outputs.

    This class provides methods to automatically fix common validation errors
    in YAML outputs from AI agents. It attempts to add missing required fields,
    fix syntax errors, normalize field names, and correct ID format violations.

    Features:
        - Fixes missing required fields with sensible defaults
        - Repairs common YAML syntax errors
        - Normalizes field names (e.g., camelCase to snake_case)
        - Corrects ID format violations (lowercase, underscores, alphanumeric)
        - Logs all corrections transparently
        - Validates corrected output

    Example:
        &gt;&gt;&gt; corrector = OutputCorrector()
        &gt;&gt;&gt; result = corrector.correct_plot(invalid_yaml_string)
        &gt;&gt;&gt; if result.success:
        ...     print(f&#34;Corrections applied: {result.corrections}&#34;)
        ...     with open(&#39;output.yaml&#39;, &#39;w&#39;) as f:
        ...         f.write(result.corrected_yaml)
        ... else:
        ...     print(f&#34;Correction failed: {result.validation_result.errors}&#34;)
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialize the output corrector with a validator instance.&#34;&#34;&#34;
        self.validator = OutputValidator()
        logger.info(&#34;OutputCorrector initialized&#34;)

    def _fix_id_format(self, id_value: str) -&gt; str:
        &#34;&#34;&#34;Fix ID format to match schema requirements.

        Ensures IDs are lowercase, use underscores, and contain only
        alphanumeric characters, underscores, and hyphens.

        Args:
            id_value: Original ID value.

        Returns:
            Corrected ID value.

        Example:
            &gt;&gt;&gt; corrector = OutputCorrector()
            &gt;&gt;&gt; corrector._fix_id_format(&#34;My-Scene ID!&#34;)
            &#39;my_scene_id&#39;
        &#34;&#34;&#34;
        # Convert to lowercase
        fixed = id_value.lower()
        # Replace spaces with underscores
        fixed = fixed.replace(&#34; &#34;, &#34;_&#34;)
        # Remove invalid characters (keep only alphanumeric, underscores, hyphens)
        fixed = re.sub(r&#34;[^a-z0-9_-]&#34;, &#34;&#34;, fixed)
        # Replace multiple underscores/hyphens with single underscore
        fixed = re.sub(r&#34;[_-]+&#34;, &#34;_&#34;, fixed)
        # Remove leading/trailing underscores/hyphens
        fixed = fixed.strip(&#34;_-&#34;)
        return fixed

    def _extend_short_description(self, description: str, min_length: int) -&gt; str:
        &#34;&#34;&#34;Extend a description that is too short to meet minimum length.

        Args:
            description: Original description.
            min_length: Minimum required length.

        Returns:
            Extended description if needed, otherwise original.
        &#34;&#34;&#34;
        if len(description) &gt;= min_length:
            return description

        # Add generic filler text to meet minimum length
        filler = (
            &#34; Additional details and context will be developed further &#34;
            &#34;during the narrative design process.&#34;
        )
        extended = description + filler

        # If still not long enough, add more filler
        while len(extended) &lt; min_length:
            extended += &#34; Further elaboration and refinement will enhance this element.&#34;

        return extended

    def _fix_mixed_quotes(self, content: str) -&gt; str:
        &#34;&#34;&#34;Fix strings with mismatched quote delimiters.

        Handles strings like &#34;entrance&#39; or &#39;corridor_1&#34; where the opening
        and closing quotes don&#39;t match. Normalizes to the opening quote type.

        Args:
            content: Raw YAML string with potential mixed quotes.

        Returns:
            Fixed YAML string with consistent quote usage.

        Example:
            &gt;&gt;&gt; corrector = OutputCorrector()
            &gt;&gt;&gt; corrector._fix_mixed_quotes(&#39;starting_scene: &#34;entrance\\&#39;&#39;)
            &#39;starting_scene: &#34;entrance&#34;&#39;
            &gt;&gt;&gt; corrector._fix_mixed_quotes(&#34;south: &#39;corridor_1\\&#34;&#34;)
            &#34;south: &#39;corridor_1&#39;&#34;
        &#34;&#34;&#34;
        # Strategy: Look for strings that start with one quote type and end with another
        # We need to be careful about apostrophes inside strings
        # Pattern 1: &#34; ... &#39; at end of line (double quote start, single quote end)
        # Pattern 2: &#39; ... &#34; at end of line (single quote start, double quote end)

        # Use line-by-line processing to avoid matching across multiple values
        lines = content.split(&#34;\n&#34;)
        fixed_lines = []

        for line in lines:
            # Check for mismatched quotes on this line
            # Pattern: starts with &#34; and ends with &#39; (at end of line)
            if re.search(r&#39;:\s*&#34;[^&#34;]*\&#39;$&#39;, line):
                # Replace the final &#39; with &#34;
                line = re.sub(r&#34;\&#39;$&#34;, &#39;&#34;&#39;, line)  # noqa: PLW2901
            # Pattern: starts with &#39; and ends with &#34; (at end of line)
            elif re.search(r&#34;:\s*&#39;[^&#39;]*\&#34;$&#34;, line):
                # Replace the final &#34; with &#39;
                line = re.sub(r&#39;&#34;$&#39;, &#34;&#39;&#34;, line)  # noqa: PLW2901

            fixed_lines.append(line)

        content = &#34;\n&#34;.join(fixed_lines)
        logger.debug(&#34;Fixed mixed quote delimiters&#34;)
        return content

    def _fix_invalid_list_markers(self, content: str) -&gt; str:
        &#34;&#34;&#34;Fix invalid YAML list markers with multiple dashes.

        Handles list items marked with multiple dashes (e.g., &#39;---------------- item&#39;)
        and converts them to proper YAML list syntax (&#39;- item&#39;).

        Args:
            content: Raw YAML string with potential invalid list markers.

        Returns:
            Fixed YAML string with proper list markers.

        Example:
            &gt;&gt;&gt; corrector = OutputCorrector()
            &gt;&gt;&gt; corrector._fix_invalid_list_markers(&#39;items:\\n  ---------------- flashlight&#39;)
            &#39;items:\\n  - flashlight&#39;
        &#34;&#34;&#34;
        # Pattern: line starting with indentation, followed by 4+ dashes, then content
        # Captures: (indentation) (4+ dashes) (optional spaces) (rest of line)
        # Replace with: (indentation) - (rest of line)
        content = re.sub(
            r&#34;^(\s*)-{4,}\s*(.+)$&#34;,
            r&#34;\1- \2&#34;,
            content,
            flags=re.MULTILINE,
        )

        logger.debug(&#34;Fixed invalid list markers&#34;)
        return content

    def _fix_unescaped_apostrophes(self, content: str) -&gt; str:
        &#34;&#34;&#34;Fix unescaped apostrophes in single-quoted strings.

        Handles apostrophes inside single-quoted strings (e.g., &#39;Ship&#39;s Bridge&#39;)
        by converting them to double-quoted strings to avoid escaping.

        Args:
            content: Raw YAML string with potential unescaped apostrophes.

        Returns:
            Fixed YAML string with apostrophes properly handled.

        Example:
            &gt;&gt;&gt; corrector = OutputCorrector()
            &gt;&gt;&gt; corrector._fix_unescaped_apostrophes(&#34;name: &#39;Ship&#39;s Bridge&#39;&#34;)
            &#39;name: &#34;Ship\\&#39;s Bridge&#34;&#39;
            &gt;&gt;&gt; corrector._fix_unescaped_apostrophes(&#34;description: &#39;The captain&#39;s quarters&#39;&#34;)
            &#39;description: &#34;The captain\\&#39;s quarters&#34;&#39;
        &#34;&#34;&#34;
        # Pattern: find single-quoted strings that contain apostrophes
        # We need to match the entire string including any apostrophes inside
        # Strategy: Look for : &#39;some text with potential apostrophe&#39; pattern
        # Use a greedy match to get everything between the outer quotes

        def replace_single_quoted_with_apostrophe(match):
            &#34;&#34;&#34;Replace single-quoted string containing apostrophe with double-quoted version.&#34;&#34;&#34;
            prefix = match.group(1)  # Everything before the opening quote (: and spaces)
            inner_content = match.group(2)  # Content inside the outer quotes

            # Check if content contains an apostrophe (but not just the closing quote)
            # We need to look for apostrophes that are NOT the final closing quote
            if &#34;&#39;&#34; in inner_content:
                # Convert to double-quoted string
                # The content already has the apostrophes, just change the delimiters
                return f&#39;{prefix}&#34;{inner_content}&#34;&#39;
            else:
                # Keep as-is
                return match.group(0)

        # Pattern: (: + optional spaces) &#39; (everything until last &#39;) &#39;
        # This uses a possessive quantifier to match everything between outer quotes
        # The pattern matches: colon, spaces, opening single quote, content (greedy), closing single quote
        # We need to match the full quoted string, even if it contains apostrophes
        # The key insight: match from &#39; to the LAST &#39; on the line
        lines = content.split(&#34;\n&#34;)
        fixed_lines = []

        for line in lines:
            # Look for pattern: key: &#39;value with potential apostrophes&#39;
            # Use a more sophisticated approach: find : &#39; pairs and match to closing &#39;
            if &#34;: &#39;&#34; in line or &#34;:\t&#39;&#34; in line:
                # Find the position of &#34;: &#39;&#34;
                match = re.search(r&#34;(\s*:\s*)&#39;(.+)&#39;$&#34;, line)
                if match:
                    prefix = match.group(1)
                    inner = match.group(2)
                    # Check if inner content has apostrophes
                    if &#34;&#39;&#34; in inner:
                        # Replace the line with double-quoted version
                        fixed_line = line[: match.start()] + f&#39;{prefix}&#34;{inner}&#34;&#39;
                        fixed_lines.append(fixed_line)
                        continue
            # No match or no apostrophes, keep original
            fixed_lines.append(line)

        result = &#34;\n&#34;.join(fixed_lines)
        logger.debug(&#34;Fixed unescaped apostrophes in single-quoted strings&#34;)
        return result

    def _fix_mixed_quotes(self, content: str) -&gt; str:
        &#34;&#34;&#34;Fix strings with mismatched quote delimiters.

        Handles strings like &#34;entrance&#39; or &#39;corridor_1&#34; where the opening
        and closing quotes don&#39;t match. Normalizes to the opening quote type.

        Args:
            content: Raw YAML string with potential mixed quotes.

        Returns:
            Fixed YAML string with consistent quote usage.

        Example:
            &gt;&gt;&gt; corrector = OutputCorrector()
            &gt;&gt;&gt; corrector._fix_mixed_quotes(&#39;starting_scene: &#34;entrance\\&#39;&#39;)
            &#39;starting_scene: &#34;entrance&#34;&#39;
            &gt;&gt;&gt; corrector._fix_mixed_quotes(&#34;south: &#39;corridor_1\\&#34;&#34;)
            &#34;south: &#39;corridor_1&#39;&#34;
        &#34;&#34;&#34;
        # Strategy: Look for strings that start with one quote type and end with another
        # We need to be careful about apostrophes inside strings
        # Pattern 1: &#34; ... &#39; at end of line (double quote start, single quote end)
        # Pattern 2: &#39; ... &#34; at end of line (single quote start, double quote end)

        # Use line-by-line processing to avoid matching across multiple values
        lines = content.split(&#34;\n&#34;)
        fixed_lines = []

        for line in lines:
            # Check for mismatched quotes on this line
            # Pattern: starts with &#34; and ends with &#39; (at end of line)
            if re.search(r&#39;:\s*&#34;[^&#34;]*\&#39;$&#39;, line):
                # Replace the final &#39; with &#34;
                line = re.sub(r&#34;\&#39;$&#34;, &#39;&#34;&#39;, line)  # noqa: PLW2901
            # Pattern: starts with &#39; and ends with &#34; (at end of line)
            elif re.search(r&#34;:\s*&#39;[^&#39;]*\&#34;$&#34;, line):
                # Replace the final &#34; with &#39;
                line = re.sub(r&#39;&#34;$&#39;, &#34;&#39;&#34;, line)  # noqa: PLW2901

            fixed_lines.append(line)

        content = &#34;\n&#34;.join(fixed_lines)
        logger.debug(&#34;Fixed mixed quote delimiters&#34;)
        return content

    def _fix_invalid_list_markers(self, content: str) -&gt; str:
        &#34;&#34;&#34;Fix invalid YAML list markers with multiple dashes.

        Handles list items marked with multiple dashes (e.g., &#39;---------------- item&#39;)
        and converts them to proper YAML list syntax (&#39;- item&#39;).

        Args:
            content: Raw YAML string with potential invalid list markers.

        Returns:
            Fixed YAML string with proper list markers.

        Example:
            &gt;&gt;&gt; corrector = OutputCorrector()
            &gt;&gt;&gt; corrector._fix_invalid_list_markers(&#39;items:\\n  ---------------- flashlight&#39;)
            &#39;items:\\n  - flashlight&#39;
        &#34;&#34;&#34;
        # Pattern: line starting with indentation, followed by 4+ dashes, then content
        # Captures: (indentation) (4+ dashes) (optional spaces) (rest of line)
        # Replace with: (indentation) - (rest of line)
        content = re.sub(
            r&#34;^(\s*)-{4,}\s*(.+)$&#34;,
            r&#34;\1- \2&#34;,
            content,
            flags=re.MULTILINE,
        )

        logger.debug(&#34;Fixed invalid list markers&#34;)
        return content

    def _fix_unescaped_apostrophes(self, content: str) -&gt; str:
        &#34;&#34;&#34;Fix unescaped apostrophes in single-quoted strings.

        Handles apostrophes inside single-quoted strings (e.g., &#39;Ship&#39;s Bridge&#39;)
        by converting them to double-quoted strings to avoid escaping.

        Args:
            content: Raw YAML string with potential unescaped apostrophes.

        Returns:
            Fixed YAML string with apostrophes properly handled.

        Example:
            &gt;&gt;&gt; corrector = OutputCorrector()
            &gt;&gt;&gt; corrector._fix_unescaped_apostrophes(&#34;name: &#39;Ship&#39;s Bridge&#39;&#34;)
            &#39;name: &#34;Ship\\&#39;s Bridge&#34;&#39;
            &gt;&gt;&gt; corrector._fix_unescaped_apostrophes(&#34;description: &#39;The captain&#39;s quarters&#39;&#34;)
            &#39;description: &#34;The captain\\&#39;s quarters&#34;&#39;
        &#34;&#34;&#34;
        # Pattern: find single-quoted strings that contain apostrophes
        # We need to match the entire string including any apostrophes inside
        # Strategy: Look for : &#39;some text with potential apostrophe&#39; pattern
        # Use a greedy match to get everything between the outer quotes

        def replace_single_quoted_with_apostrophe(match):
            &#34;&#34;&#34;Replace single-quoted string containing apostrophe with double-quoted version.&#34;&#34;&#34;
            prefix = match.group(1)  # Everything before the opening quote (: and spaces)
            inner_content = match.group(2)  # Content inside the outer quotes

            # Check if content contains an apostrophe (but not just the closing quote)
            # We need to look for apostrophes that are NOT the final closing quote
            if &#34;&#39;&#34; in inner_content:
                # Convert to double-quoted string
                # The content already has the apostrophes, just change the delimiters
                return f&#39;{prefix}&#34;{inner_content}&#34;&#39;
            else:
                # Keep as-is
                return match.group(0)

        # Pattern: (: + optional spaces) &#39; (everything until last &#39;) &#39;
        # This uses a possessive quantifier to match everything between outer quotes
        # The pattern matches: colon, spaces, opening single quote, content (greedy), closing single quote
        # We need to match the full quoted string, even if it contains apostrophes
        # The key insight: match from &#39; to the LAST &#39; on the line
        lines = content.split(&#34;\n&#34;)
        fixed_lines = []

        for line in lines:
            # Look for pattern: key: &#39;value with potential apostrophes&#39;
            # Use a more sophisticated approach: find : &#39; pairs and match to closing &#39;
            if &#34;: &#39;&#34; in line or &#34;:\t&#39;&#34; in line:
                # Find the position of &#34;: &#39;&#34;
                match = re.search(r&#34;(\s*:\s*)&#39;(.+)&#39;$&#34;, line)
                if match:
                    prefix = match.group(1)
                    inner = match.group(2)
                    # Check if inner content has apostrophes
                    if &#34;&#39;&#34; in inner:
                        # Replace the line with double-quoted version
                        fixed_line = line[: match.start()] + f&#39;{prefix}&#34;{inner}&#34;&#39;
                        fixed_lines.append(fixed_line)
                        continue
            # No match or no apostrophes, keep original
            fixed_lines.append(line)

        result = &#34;\n&#34;.join(fixed_lines)
        logger.debug(&#34;Fixed unescaped apostrophes in single-quoted strings&#34;)
        return result

    def _parse_yaml_safe(self, raw_output: str) -&gt; tuple[dict | None, list[str]]:
        &#34;&#34;&#34;Safely parse YAML with error recovery.

        Attempts to parse YAML and apply basic syntax fixes if parsing fails.

        Args:
            raw_output: Raw YAML string.

        Returns:
            Tuple of (parsed_data, errors). If parsing succeeds, parsed_data
            is a dict and errors is empty. If parsing fails, parsed_data is None
            and errors contains the error messages.
        &#34;&#34;&#34;
        try:
            # Strip markdown fences first
            clean_yaml = strip_markdown_yaml_blocks(raw_output)

            # Apply syntax fixes BEFORE parsing
            clean_yaml = self._fix_mixed_quotes(clean_yaml)
            clean_yaml = self._fix_invalid_list_markers(clean_yaml)
            clean_yaml = self._fix_unescaped_apostrophes(clean_yaml)
            clean_yaml = strip_markdown_yaml_blocks(raw_output)

            # Apply syntax fixes BEFORE parsing
            clean_yaml = self._fix_mixed_quotes(clean_yaml)
            clean_yaml = self._fix_invalid_list_markers(clean_yaml)
            clean_yaml = self._fix_unescaped_apostrophes(clean_yaml)

            # Try to parse
            data = yaml.safe_load(clean_yaml)

            if data is None:
                return None, [&#34;YAML is empty or contains only whitespace&#34;]

            if not isinstance(data, dict):
                return None, [f&#34;YAML must be a dictionary, got {type(data).__name__}&#34;]

            return data, []

        except yaml.YAMLError as e:
            # Attempt basic syntax fixes
            logger.warning(f&#34;YAML parsing error, attempting fixes: {e}&#34;)

            try:
                # Common fix: remove duplicate colons, fix indentation issues
                clean_yaml = strip_markdown_yaml_blocks(raw_output)
                clean_yaml = strip_markdown_yaml_blocks(raw_output)

                # NOTE: This is the ONLY implementation of colon-in-values fixing.
                # Other modules (evaluator, crew) have been refactored to rely on this.
                # Do not duplicate this logic elsewhere.
                #
                # NOTE: This is the ONLY implementation of colon-in-values fixing.
                # Other modules (evaluator, crew) have been refactored to rely on this.
                # Do not duplicate this logic elsewhere.
                #
                # Try to fix &#34;mapping values are not allowed here&#34; by escaping colons in values
                # This is a simple heuristic and may not catch all cases
                lines = clean_yaml.split(&#34;\n&#34;)
                fixed_lines = []
                for line in lines:
                    if &#34;:&#34; in line and not line.strip().startswith(&#34;#&#34;):
                        # Check if there are multiple colons (potential issue)
                        parts = line.split(&#34;:&#34;, 1)
                        if len(parts) == 2 and &#34;:&#34; in parts[1]:
                            # Quote the value if it contains colons
                            indent = len(line) - len(line.lstrip())
                            key = parts[0].strip()
                            value = parts[1].strip()
                            if not (value.startswith(&#39;&#34;&#39;) or value.startswith(&#34;&#39;&#34;)):
                                fixed_lines.append(f&#34;{&#39; &#39; * indent}{key}: &#39;{value}&#39;&#34;)
                            else:
                                fixed_lines.append(line)
                        else:
                            fixed_lines.append(line)
                    else:
                        fixed_lines.append(line)

                fixed_yaml = &#34;\n&#34;.join(fixed_lines)
                data = yaml.safe_load(fixed_yaml)

                if data is None:
                    return None, [&#34;YAML is empty after attempted fix&#34;]

                if not isinstance(data, dict):
                    return None, [f&#34;YAML must be a dictionary, got {type(data).__name__}&#34;]

                logger.info(&#34;Successfully fixed YAML syntax error&#34;)
                return data, []

            except yaml.YAMLError as e2:
                error_msg = f&#34;YAML parsing error (even after attempted fix): {e2!s}&#34;
                logger.error(error_msg)
                return None, [error_msg]

        except Exception as e:
            error_msg = f&#34;Unexpected error during YAML parsing: {e!s}&#34;
            logger.error(error_msg)
            return None, [error_msg]

    def correct_plot(self, raw_output: str) -&gt; CorrectionResult:
        &#34;&#34;&#34;Attempt to correct common errors in plot outline YAML.

        Fixes:
            - Missing required fields (plot_points, characters, conflicts)
            - Invalid ID formats
            - Descriptions too short
            - YAML syntax errors

        Args:
            raw_output: Raw YAML string containing plot outline data.

        Returns:
            CorrectionResult with corrected YAML, list of corrections,
            validation result, and success status.

        Example:
            &gt;&gt;&gt; corrector = OutputCorrector()
            &gt;&gt;&gt; result = corrector.correct_plot(invalid_plot_yaml)
            &gt;&gt;&gt; if result.success:
            ...     print(f&#34;Plot corrected with {len(result.corrections)} changes&#34;)
        &#34;&#34;&#34;
        logger.info(&#34;Attempting to correct plot outline YAML&#34;)
        corrections: list[str] = []

        # Parse YAML
        data, parse_errors = self._parse_yaml_safe(raw_output)
        if parse_errors:
            # Can&#39;t fix unparseable YAML beyond basic syntax fixes already attempted
            validation_result = ValidationResult(valid=False, data=None, errors=parse_errors)
            return CorrectionResult(
                corrected_yaml=raw_output,
                corrections=corrections,
                validation_result=validation_result,
                success=False,
            )

        # Type guard: data is guaranteed to be dict here
        assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

        # Add missing required fields
        if &#34;title&#34; not in data:
            data[&#34;title&#34;] = &#34;Untitled Plot&#34;
            corrections.append(&#34;Added missing &#39;title&#39; field with default value&#34;)
            logger.info(&#34;Added missing &#39;title&#39; field&#34;)

        if &#34;setting&#34; not in data:
            data[&#34;setting&#34;] = self._extend_short_description(
                &#34;A dark and atmospheric setting for the narrative.&#34;, 50
            )
            corrections.append(&#34;Added missing &#39;setting&#39; field with default value&#34;)
            logger.info(&#34;Added missing &#39;setting&#39; field&#34;)
        elif len(data[&#34;setting&#34;]) &lt; 50:
            original_setting = data[&#34;setting&#34;]
            data[&#34;setting&#34;] = self._extend_short_description(data[&#34;setting&#34;], 50)
            corrections.append(
                f&#34;Extended short &#39;setting&#39; field (was {len(original_setting)} chars)&#34;
            )
            logger.info(&#34;Extended &#39;setting&#39; field&#34;)

        if &#34;themes&#34; not in data or not data[&#34;themes&#34;]:
            data[&#34;themes&#34;] = [&#34;survival&#34;, &#34;conflict&#34;]
            corrections.append(&#34;Added missing &#39;themes&#39; field with default values&#34;)
            logger.info(&#34;Added missing &#39;themes&#39; field&#34;)

        if &#34;tone&#34; not in data:
            data[&#34;tone&#34;] = &#34;Dark and atmospheric&#34;
            corrections.append(&#34;Added missing &#39;tone&#39; field with default value&#34;)
            logger.info(&#34;Added missing &#39;tone&#39; field&#34;)
        elif len(data[&#34;tone&#34;]) &lt; 10:
            original_tone = data[&#34;tone&#34;]
            data[&#34;tone&#34;] = self._extend_short_description(data[&#34;tone&#34;], 10)
            corrections.append(f&#34;Extended short &#39;tone&#39; field (was {len(original_tone)} chars)&#34;)
            logger.info(&#34;Extended &#39;tone&#39; field&#34;)

        if &#34;plot_points&#34; not in data or not data[&#34;plot_points&#34;]:
            data[&#34;plot_points&#34;] = [
                {
                    &#34;id&#34;: &#34;pp_01_opening&#34;,
                    &#34;name&#34;: &#34;Opening&#34;,
                    &#34;description&#34;: self._extend_short_description(
                        &#34;The story begins with the initial situation.&#34;, 50
                    ),
                },
                {
                    &#34;id&#34;: &#34;pp_02_development&#34;,
                    &#34;name&#34;: &#34;Development&#34;,
                    &#34;description&#34;: self._extend_short_description(
                        &#34;The plot develops as events unfold.&#34;, 50
                    ),
                },
                {
                    &#34;id&#34;: &#34;pp_03_conclusion&#34;,
                    &#34;name&#34;: &#34;Conclusion&#34;,
                    &#34;description&#34;: self._extend_short_description(
                        &#34;The story reaches its conclusion and resolution.&#34;, 50
                    ),
                },
            ]
            corrections.append(&#34;Added missing &#39;plot_points&#39; field with minimal defaults&#34;)
            logger.info(&#34;Added missing &#39;plot_points&#39; field&#34;)

        if &#34;characters&#34; not in data or not data[&#34;characters&#34;]:
            data[&#34;characters&#34;] = [
                {
                    &#34;name&#34;: &#34;Protagonist&#34;,
                    &#34;role&#34;: &#34;Main character&#34;,
                    &#34;backstory&#34;: self._extend_short_description(
                        &#34;The protagonist&#39;s background and history.&#34;, 50
                    ),
                }
            ]
            corrections.append(&#34;Added missing &#39;characters&#39; field with minimal default&#34;)
            logger.info(&#34;Added missing &#39;characters&#39; field&#34;)

        if &#34;conflicts&#34; not in data or not data[&#34;conflicts&#34;]:
            data[&#34;conflicts&#34;] = [
                {
                    &#34;type&#34;: &#34;Main Conflict&#34;,
                    &#34;description&#34;: self._extend_short_description(
                        &#34;The primary conflict driving the narrative.&#34;, 50
                    ),
                }
            ]
            corrections.append(&#34;Added missing &#39;conflicts&#39; field with minimal default&#34;)
            logger.info(&#34;Added missing &#39;conflicts&#39; field&#34;)

        # Fix plot point IDs and descriptions
        if &#34;plot_points&#34; in data and isinstance(data[&#34;plot_points&#34;], list):
            for _i, pp in enumerate(data[&#34;plot_points&#34;]):
                if isinstance(pp, dict):
                    # Fix ID format
                    if &#34;id&#34; in pp:
                        original_id = pp[&#34;id&#34;]
                        fixed_id = self._fix_id_format(original_id)
                        if original_id != fixed_id:
                            pp[&#34;id&#34;] = fixed_id
                            corrections.append(
                                f&#34;Fixed plot point ID format: &#39;{original_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;
                            )
                            logger.info(f&#34;Fixed plot point ID: {original_id} -&gt; {fixed_id}&#34;)

                    # Extend short descriptions
                    if &#34;description&#34; in pp and len(pp[&#34;description&#34;]) &lt; 50:
                        original_desc = pp[&#34;description&#34;]
                        pp[&#34;description&#34;] = self._extend_short_description(pp[&#34;description&#34;], 50)
                        corrections.append(
                            f&#34;Extended short plot point description &#34;
                            f&#34;(was {len(original_desc)} chars)&#34;
                        )
                        logger.info(
                            f&#34;Extended plot point description from {len(original_desc)} &#34;
                            f&#34;to {len(pp[&#39;description&#39;])} chars&#34;
                        )

        # Fix character backstories
        if &#34;characters&#34; in data and isinstance(data[&#34;characters&#34;], list):
            for char in data[&#34;characters&#34;]:
                if isinstance(char, dict) and &#34;backstory&#34; in char and len(char[&#34;backstory&#34;]) &lt; 50:
                    original_backstory = char[&#34;backstory&#34;]
                    char[&#34;backstory&#34;] = self._extend_short_description(char[&#34;backstory&#34;], 50)
                    corrections.append(
                        f&#34;Extended short character backstory (was {len(original_backstory)} chars)&#34;
                    )
                    logger.info(
                        f&#34;Extended character backstory from {len(original_backstory)} &#34;
                        f&#34;to {len(char[&#39;backstory&#39;])} chars&#34;
                    )

        # Fix conflict descriptions
        if &#34;conflicts&#34; in data and isinstance(data[&#34;conflicts&#34;], list):
            for conflict in data[&#34;conflicts&#34;]:
                if (
                    isinstance(conflict, dict)
                    and &#34;description&#34; in conflict
                    and len(conflict[&#34;description&#34;]) &lt; 50
                ):
                    original_desc = conflict[&#34;description&#34;]
                    conflict[&#34;description&#34;] = self._extend_short_description(
                        conflict[&#34;description&#34;], 50
                    )
                    corrections.append(
                        f&#34;Extended short conflict description (was {len(original_desc)} chars)&#34;
                    )
                    logger.info(
                        f&#34;Extended conflict description from {len(original_desc)} &#34;
                        f&#34;to {len(conflict[&#39;description&#39;])} chars&#34;
                    )

        # Convert back to YAML
        try:
            corrected_yaml = yaml.dump(
                data, default_flow_style=False, sort_keys=False, allow_unicode=True
            )
        except Exception as e:
            logger.error(f&#34;Error converting corrected data to YAML: {e}&#34;)
            validation_result = ValidationResult(
                valid=False, data=None, errors=[f&#34;Error converting to YAML: {e!s}&#34;]
            )
            return CorrectionResult(
                corrected_yaml=raw_output,
                corrections=corrections,
                validation_result=validation_result,
                success=False,
            )

        # Validate corrected output
        validation_result = self.validator.validate_plot(corrected_yaml)

        logger.info(
            f&#34;Plot correction complete: {len(corrections)} corrections, &#34;
            f&#34;valid={validation_result.valid}&#34;
        )

        return CorrectionResult(
            corrected_yaml=corrected_yaml,
            corrections=corrections,
            validation_result=validation_result,
            success=validation_result.valid,
        )

    def correct_narrative_map(self, raw_output: str) -&gt; CorrectionResult:
        &#34;&#34;&#34;Attempt to correct common errors in narrative map YAML.

        Fixes:
            - Missing required fields (start_scene, scenes)
            - Invalid ID formats
            - Descriptions too short
            - YAML syntax errors

        Args:
            raw_output: Raw YAML string containing narrative map data.

        Returns:
            CorrectionResult with corrected YAML, list of corrections,
            validation result, and success status.

        Example:
            &gt;&gt;&gt; corrector = OutputCorrector()
            &gt;&gt;&gt; result = corrector.correct_narrative_map(invalid_map_yaml)
            &gt;&gt;&gt; if result.success:
            ...     print(f&#34;Map corrected with {len(result.corrections)} changes&#34;)
        &#34;&#34;&#34;
        logger.info(&#34;Attempting to correct narrative map YAML&#34;)
        corrections: list[str] = []

        # Parse YAML
        data, parse_errors = self._parse_yaml_safe(raw_output)
        if parse_errors:
            validation_result = ValidationResult(valid=False, data=None, errors=parse_errors)
            return CorrectionResult(
                corrected_yaml=raw_output,
                corrections=corrections,
                validation_result=validation_result,
                success=False,
            )

        assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

        # Add missing required fields
        if &#34;scenes&#34; not in data or not data[&#34;scenes&#34;]:
            data[&#34;scenes&#34;] = {
                &#34;scene_default&#34;: {
                    &#34;name&#34;: &#34;Default Scene&#34;,
                    &#34;description&#34;: self._extend_short_description(
                        &#34;A default scene in the narrative.&#34;, 50
                    ),
                    &#34;connections&#34;: [],
                }
            }
            corrections.append(&#34;Added missing &#39;scenes&#39; field with minimal default&#34;)
            logger.info(&#34;Added missing &#39;scenes&#39; field&#34;)

        if &#34;start_scene&#34; not in data:
            # Use the first scene as the start scene
            if isinstance(data.get(&#34;scenes&#34;), dict) and data[&#34;scenes&#34;]:
                first_scene_id = next(iter(data[&#34;scenes&#34;].keys()))
                data[&#34;start_scene&#34;] = first_scene_id
                corrections.append(f&#34;Added missing &#39;start_scene&#39; field (set to &#39;{first_scene_id}&#39;)&#34;)
                logger.info(f&#34;Added missing &#39;start_scene&#39; field: {first_scene_id}&#34;)
            else:
                data[&#34;start_scene&#34;] = &#34;scene_default&#34;
                corrections.append(&#34;Added missing &#39;start_scene&#39; field with default value&#34;)
                logger.info(&#34;Added missing &#39;start_scene&#39; field&#34;)

        # Fix scene IDs and descriptions
        if &#34;scenes&#34; in data and isinstance(data[&#34;scenes&#34;], dict):
            fixed_scenes = {}
            for scene_id, scene in data[&#34;scenes&#34;].items():
                # Fix scene ID format
                fixed_id = self._fix_id_format(scene_id)
                if scene_id != fixed_id:
                    corrections.append(f&#34;Fixed scene ID format: &#39;{scene_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;)
                    logger.info(f&#34;Fixed scene ID: {scene_id} -&gt; {fixed_id}&#34;)
                    # Update start_scene if it matches the old ID
                    if data.get(&#34;start_scene&#34;) == scene_id:
                        data[&#34;start_scene&#34;] = fixed_id
                        corrections.append(f&#34;Updated &#39;start_scene&#39; to match fixed ID: &#39;{fixed_id}&#39;&#34;)

                if isinstance(scene, dict):
                    # Extend short descriptions
                    if &#34;description&#34; in scene and len(scene[&#34;description&#34;]) &lt; 50:
                        original_desc = scene[&#34;description&#34;]
                        scene[&#34;description&#34;] = self._extend_short_description(
                            scene[&#34;description&#34;], 50
                        )
                        corrections.append(
                            f&#34;Extended short scene description (was {len(original_desc)} chars)&#34;
                            f&#34;Extended short scene description (was {len(original_desc)} chars)&#34;
                        )
                        logger.info(
                            f&#34;Extended scene description from {len(original_desc)} &#34;
                            f&#34;to {len(scene[&#39;description&#39;])} chars&#34;
                        )

                    # Ensure connections is a list
                    if &#34;connections&#34; not in scene:
                        scene[&#34;connections&#34;] = []
                        corrections.append(
                            f&#34;Added missing &#39;connections&#39; field to scene &#39;{fixed_id}&#39;&#34;
                        )

                    # Fix connection target IDs
                    if &#34;connections&#34; in scene and isinstance(scene[&#34;connections&#34;], list):
                        for conn in scene[&#34;connections&#34;]:
                            if isinstance(conn, dict) and &#34;target&#34; in conn:
                                original_target = conn[&#34;target&#34;]
                                fixed_target = self._fix_id_format(original_target)
                                if original_target != fixed_target:
                                    conn[&#34;target&#34;] = fixed_target
                                    corrections.append(
                                        f&#34;Fixed connection target ID: &#34;
                                        f&#34;&#39;{original_target}&#39; -&gt; &#39;{fixed_target}&#39;&#34;
                                    )

                fixed_scenes[fixed_id] = scene

            data[&#34;scenes&#34;] = fixed_scenes

        # Convert back to YAML
        try:
            corrected_yaml = yaml.dump(
                data, default_flow_style=False, sort_keys=False, allow_unicode=True
            )
        except Exception as e:
            logger.error(f&#34;Error converting corrected data to YAML: {e}&#34;)
            validation_result = ValidationResult(
                valid=False, data=None, errors=[f&#34;Error converting to YAML: {e!s}&#34;]
            )
            return CorrectionResult(
                corrected_yaml=raw_output,
                corrections=corrections,
                validation_result=validation_result,
                success=False,
            )

        # Validate corrected output
        validation_result = self.validator.validate_narrative_map(corrected_yaml)

        logger.info(
            f&#34;Narrative map correction complete: {len(corrections)} corrections, &#34;
            f&#34;valid={validation_result.valid}&#34;
        )

        return CorrectionResult(
            corrected_yaml=corrected_yaml,
            corrections=corrections,
            validation_result=validation_result,
            success=validation_result.valid,
        )

    def correct_puzzle_design(self, raw_output: str) -&gt; CorrectionResult:
        &#34;&#34;&#34;Attempt to correct common errors in puzzle design YAML.

        Fixes:
            - Missing required fields (puzzles, artifacts, monsters, npcs)
            - Invalid ID formats
            - Descriptions too short
            - YAML syntax errors

        Args:
            raw_output: Raw YAML string containing puzzle design data.

        Returns:
            CorrectionResult with corrected YAML, list of corrections,
            validation result, and success status.

        Example:
            &gt;&gt;&gt; corrector = OutputCorrector()
            &gt;&gt;&gt; result = corrector.correct_puzzle_design(invalid_puzzle_yaml)
            &gt;&gt;&gt; if result.success:
            ...     print(f&#34;Puzzle design corrected with {len(result.corrections)} changes&#34;)
        &#34;&#34;&#34;
        logger.info(&#34;Attempting to correct puzzle design YAML&#34;)
        corrections: list[str] = []

        # Parse YAML
        data, parse_errors = self._parse_yaml_safe(raw_output)
        if parse_errors:
            validation_result = ValidationResult(valid=False, data=None, errors=parse_errors)
            return CorrectionResult(
                corrected_yaml=raw_output,
                corrections=corrections,
                validation_result=validation_result,
                success=False,
            )

        assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

        # Add missing required fields
        if &#34;puzzles&#34; not in data or not data[&#34;puzzles&#34;]:
            data[&#34;puzzles&#34;] = [
                {
                    &#34;id&#34;: &#34;puzzle_default&#34;,
                    &#34;name&#34;: &#34;Default Puzzle&#34;,
                    &#34;description&#34;: self._extend_short_description(
                        &#34;A puzzle in the game that requires solving.&#34;, 50
                    ),
                    &#34;location&#34;: &#34;scene_default&#34;,
                    &#34;narrative_purpose&#34;: &#34;Provides a challenge for the player to overcome.&#34;,
                    &#34;solution&#34;: {
                        &#34;type&#34;: &#34;multi-step&#34;,
                        &#34;steps&#34;: [{&#34;step&#34;: &#34;Complete the required actions to solve this puzzle.&#34;}],
                    },
                    &#34;difficulty&#34;: &#34;medium&#34;,
                }
            ]
            corrections.append(&#34;Added missing &#39;puzzles&#39; field with minimal default&#34;)
            logger.info(&#34;Added missing &#39;puzzles&#39; field&#34;)

        if &#34;artifacts&#34; not in data or not data[&#34;artifacts&#34;]:
            data[&#34;artifacts&#34;] = [
                {
                    &#34;id&#34;: &#34;artifact_default&#34;,
                    &#34;name&#34;: &#34;Default Artifact&#34;,
                    &#34;description&#34;: &#34;An artifact found in the game world.&#34;,
                    &#34;location&#34;: &#34;scene_default&#34;,
                    &#34;narrative_significance&#34;: &#34;Holds narrative importance to the story.&#34;,
                    &#34;properties&#34;: [{&#34;property&#34;: &#34;Has special properties or effects&#34;}],
                }
            ]
            corrections.append(&#34;Added missing &#39;artifacts&#39; field with minimal default&#34;)
            logger.info(&#34;Added missing &#39;artifacts&#39; field&#34;)

        if &#34;monsters&#34; not in data or not data[&#34;monsters&#34;]:
            data[&#34;monsters&#34;] = [
                {
                    &#34;id&#34;: &#34;monster_default&#34;,
                    &#34;name&#34;: &#34;Default Monster&#34;,
                    &#34;description&#34;: &#34;A hostile entity encountered in the game.&#34;,
                    &#34;locations&#34;: [&#34;scene_default&#34;],
                    &#34;narrative_role&#34;: &#34;Provides combat challenge and threat.&#34;,
                    &#34;abilities&#34;: [&#34;Attack&#34;],
                }
            ]
            corrections.append(&#34;Added missing &#39;monsters&#39; field with minimal default&#34;)
            logger.info(&#34;Added missing &#39;monsters&#39; field&#34;)

        if &#34;npcs&#34; not in data or not data[&#34;npcs&#34;]:
            data[&#34;npcs&#34;] = [
                {
                    &#34;id&#34;: &#34;npc_default&#34;,
                    &#34;name&#34;: &#34;Default NPC&#34;,
                    &#34;role&#34;: &#34;Supporting character&#34;,
                    &#34;description&#34;: &#34;A non-player character in the game.&#34;,
                    &#34;locations&#34;: [&#34;scene_default&#34;],
                    &#34;dialogue_themes&#34;: [&#34;General conversation&#34;],
                }
            ]
            corrections.append(&#34;Added missing &#39;npcs&#39; field with minimal default&#34;)
            logger.info(&#34;Added missing &#39;npcs&#39; field&#34;)

        # Fix puzzle IDs and descriptions
        if &#34;puzzles&#34; in data and isinstance(data[&#34;puzzles&#34;], list):
            for puzzle in data[&#34;puzzles&#34;]:
                if isinstance(puzzle, dict):
                    # Fix ID format
                    if &#34;id&#34; in puzzle:
                        original_id = puzzle[&#34;id&#34;]
                        fixed_id = self._fix_id_format(original_id)
                        if original_id != fixed_id:
                            puzzle[&#34;id&#34;] = fixed_id
                            corrections.append(
                                f&#34;Fixed puzzle ID format: &#39;{original_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;
                            )
                            logger.info(f&#34;Fixed puzzle ID: {original_id} -&gt; {fixed_id}&#34;)

                    # Extend short descriptions
                    if &#34;description&#34; in puzzle and len(puzzle[&#34;description&#34;]) &lt; 50:
                        original_desc = puzzle[&#34;description&#34;]
                        puzzle[&#34;description&#34;] = self._extend_short_description(
                            puzzle[&#34;description&#34;], 50
                        )
                        corrections.append(
                            f&#34;Extended short puzzle description (was {len(original_desc)} chars)&#34;
                        )

        # Fix artifact IDs
        if &#34;artifacts&#34; in data and isinstance(data[&#34;artifacts&#34;], list):
            for artifact in data[&#34;artifacts&#34;]:
                if isinstance(artifact, dict) and &#34;id&#34; in artifact:
                    original_id = artifact[&#34;id&#34;]
                    fixed_id = self._fix_id_format(original_id)
                    if original_id != fixed_id:
                        artifact[&#34;id&#34;] = fixed_id
                        corrections.append(
                            f&#34;Fixed artifact ID format: &#39;{original_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;
                        )
                        logger.info(f&#34;Fixed artifact ID: {original_id} -&gt; {fixed_id}&#34;)

        # Fix monster IDs
        if &#34;monsters&#34; in data and isinstance(data[&#34;monsters&#34;], list):
            for monster in data[&#34;monsters&#34;]:
                if isinstance(monster, dict) and &#34;id&#34; in monster:
                    original_id = monster[&#34;id&#34;]
                    fixed_id = self._fix_id_format(original_id)
                    if original_id != fixed_id:
                        monster[&#34;id&#34;] = fixed_id
                        corrections.append(
                            f&#34;Fixed monster ID format: &#39;{original_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;
                        )
                        logger.info(f&#34;Fixed monster ID: {original_id} -&gt; {fixed_id}&#34;)

        # Fix NPC IDs
        if &#34;npcs&#34; in data and isinstance(data[&#34;npcs&#34;], list):
            for npc in data[&#34;npcs&#34;]:
                if isinstance(npc, dict) and &#34;id&#34; in npc:
                    original_id = npc[&#34;id&#34;]
                    fixed_id = self._fix_id_format(original_id)
                    if original_id != fixed_id:
                        npc[&#34;id&#34;] = fixed_id
                        corrections.append(f&#34;Fixed NPC ID format: &#39;{original_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;)
                        logger.info(f&#34;Fixed NPC ID: {original_id} -&gt; {fixed_id}&#34;)

        # Convert back to YAML
        try:
            corrected_yaml = yaml.dump(
                data, default_flow_style=False, sort_keys=False, allow_unicode=True
            )
        except Exception as e:
            logger.error(f&#34;Error converting corrected data to YAML: {e}&#34;)
            validation_result = ValidationResult(
                valid=False, data=None, errors=[f&#34;Error converting to YAML: {e!s}&#34;]
            )
            return CorrectionResult(
                corrected_yaml=raw_output,
                corrections=corrections,
                validation_result=validation_result,
                success=False,
            )

        # Validate corrected output
        validation_result = self.validator.validate_puzzle_design(corrected_yaml)

        logger.info(
            f&#34;Puzzle design correction complete: {len(corrections)} corrections, &#34;
            f&#34;valid={validation_result.valid}&#34;
        )

        return CorrectionResult(
            corrected_yaml=corrected_yaml,
            corrections=corrections,
            validation_result=validation_result,
            success=validation_result.valid,
        )

    def correct_scene_texts(self, raw_output: str) -&gt; CorrectionResult:
        &#34;&#34;&#34;Attempt to correct common errors in scene texts YAML.

        Fixes:
            - Missing required fields (scenes)
            - Invalid ID formats
            - Descriptions too short
            - YAML syntax errors

        Args:
            raw_output: Raw YAML string containing scene texts data.

        Returns:
            CorrectionResult with corrected YAML, list of corrections,
            validation result, and success status.

        Example:
            &gt;&gt;&gt; corrector = OutputCorrector()
            &gt;&gt;&gt; result = corrector.correct_scene_texts(invalid_scene_yaml)
            &gt;&gt;&gt; if result.success:
            ...     print(f&#34;Scene texts corrected with {len(result.corrections)} changes&#34;)
        &#34;&#34;&#34;
        logger.info(&#34;Attempting to correct scene texts YAML&#34;)
        corrections: list[str] = []

        # Parse YAML
        data, parse_errors = self._parse_yaml_safe(raw_output)
        if parse_errors:
            validation_result = ValidationResult(valid=False, data=None, errors=parse_errors)
            return CorrectionResult(
                corrected_yaml=raw_output,
                corrections=corrections,
                validation_result=validation_result,
                success=False,
            )

        assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

        # Add missing required fields
        if &#34;scenes&#34; not in data or not data[&#34;scenes&#34;]:
            data[&#34;scenes&#34;] = {
                &#34;scene_default&#34;: {
                    &#34;name&#34;: &#34;Default Scene&#34;,
                    &#34;description&#34;: self._extend_short_description(
                        &#34;A detailed description of this scene in the narrative, &#34;
                        &#34;providing context and atmosphere for the player.&#34;,
                        100,
                    ),
                    &#34;atmosphere&#34;: &#34;Atmospheric and immersive&#34;,
                    &#34;initial_text&#34;: &#34;You find yourself in this scene.&#34;,
                    &#34;examination_texts&#34;: {},
                    &#34;dialogue&#34;: [],
                }
            }
            corrections.append(&#34;Added missing &#39;scenes&#39; field with minimal default&#34;)
            logger.info(&#34;Added missing &#39;scenes&#39; field&#34;)

        # Fix scene IDs and descriptions
        if &#34;scenes&#34; in data and isinstance(data[&#34;scenes&#34;], dict):
            fixed_scenes = {}
            for scene_id, scene in data[&#34;scenes&#34;].items():
                # Fix scene ID format
                fixed_id = self._fix_id_format(scene_id)
                if scene_id != fixed_id:
                    corrections.append(f&#34;Fixed scene ID format: &#39;{scene_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;)
                    logger.info(f&#34;Fixed scene ID: {scene_id} -&gt; {fixed_id}&#34;)

                if isinstance(scene, dict):
                    # Extend short descriptions (scene texts require 100 chars minimum)
                    if &#34;description&#34; in scene and len(scene[&#34;description&#34;]) &lt; 100:
                        original_desc = scene[&#34;description&#34;]
                        scene[&#34;description&#34;] = self._extend_short_description(
                            scene[&#34;description&#34;], 100
                        )
                        corrections.append(
                            f&#34;Extended short scene description (was {len(original_desc)} chars)&#34;
                            f&#34;Extended short scene description (was {len(original_desc)} chars)&#34;
                        )
                        logger.info(
                            f&#34;Extended scene description from {len(original_desc)} &#34;
                            f&#34;to {len(scene[&#39;description&#39;])} chars&#34;
                        )

                    # Ensure required fields exist
                    if &#34;atmosphere&#34; not in scene:
                        scene[&#34;atmosphere&#34;] = &#34;Atmospheric and immersive&#34;
                        corrections.append(
                            f&#34;Added missing &#39;atmosphere&#39; field to scene &#39;{fixed_id}&#39;&#34;
                        )
                    elif len(scene[&#34;atmosphere&#34;]) &lt; 10:
                        original_atmo = scene[&#34;atmosphere&#34;]
                        scene[&#34;atmosphere&#34;] = self._extend_short_description(
                            scene[&#34;atmosphere&#34;], 10
                        )
                        corrections.append(
                            f&#34;Extended short &#39;atmosphere&#39; field in scene &#39;{fixed_id}&#39; &#34;
                            f&#34;(was {len(original_atmo)} chars)&#34;
                        )

                    if &#34;initial_text&#34; not in scene:
                        scene[&#34;initial_text&#34;] = &#34;You find yourself in this scene.&#34;
                        corrections.append(
                            f&#34;Added missing &#39;initial_text&#39; field to scene &#39;{fixed_id}&#39;&#34;
                        )
                    elif len(scene[&#34;initial_text&#34;]) &lt; 20:
                        original_text = scene[&#34;initial_text&#34;]
                        scene[&#34;initial_text&#34;] = self._extend_short_description(
                            scene[&#34;initial_text&#34;], 20
                        )
                        corrections.append(
                            f&#34;Extended short &#39;initial_text&#39; field in scene &#39;{fixed_id}&#39; &#34;
                            f&#34;(was {len(original_text)} chars)&#34;
                        )

                    if &#34;examination_texts&#34; not in scene:
                        scene[&#34;examination_texts&#34;] = {}
                        corrections.append(
                            f&#34;Added missing &#39;examination_texts&#39; field to scene &#39;{fixed_id}&#39;&#34;
                        )

                    if &#34;dialogue&#34; not in scene:
                        scene[&#34;dialogue&#34;] = []
                        corrections.append(f&#34;Added missing &#39;dialogue&#39; field to scene &#39;{fixed_id}&#39;&#34;)

                fixed_scenes[fixed_id] = scene

            data[&#34;scenes&#34;] = fixed_scenes

        # Convert back to YAML
        try:
            corrected_yaml = yaml.dump(
                data, default_flow_style=False, sort_keys=False, allow_unicode=True
            )
        except Exception as e:
            logger.error(f&#34;Error converting corrected data to YAML: {e}&#34;)
            validation_result = ValidationResult(
                valid=False, data=None, errors=[f&#34;Error converting to YAML: {e!s}&#34;]
            )
            return CorrectionResult(
                corrected_yaml=raw_output,
                corrections=corrections,
                validation_result=validation_result,
                success=False,
            )

        # Validate corrected output
        validation_result = self.validator.validate_scene_texts(corrected_yaml)

        logger.info(
            f&#34;Scene texts correction complete: {len(corrections)} corrections, &#34;
            f&#34;valid={validation_result.valid}&#34;
        )

        return CorrectionResult(
            corrected_yaml=corrected_yaml,
            corrections=corrections,
            validation_result=validation_result,
            success=validation_result.valid,
        )

    def correct_game_mechanics(self, raw_output: str) -&gt; CorrectionResult:
        &#34;&#34;&#34;Attempt to correct common errors in game mechanics YAML.

        Fixes:
            - Missing required fields (game_systems, game_state, technical_requirements)
            - Descriptions too short
            - YAML syntax errors

        Args:
            raw_output: Raw YAML string containing game mechanics data.

        Returns:
            CorrectionResult with corrected YAML, list of corrections,
            validation result, and success status.

        Example:
            &gt;&gt;&gt; corrector = OutputCorrector()
            &gt;&gt;&gt; result = corrector.correct_game_mechanics(invalid_mechanics_yaml)
            &gt;&gt;&gt; if result.success:
            ...     print(f&#34;Game mechanics corrected with {len(result.corrections)} changes&#34;)
        &#34;&#34;&#34;
        logger.info(&#34;Attempting to correct game mechanics YAML&#34;)
        corrections: list[str] = []

        # Parse YAML
        data, parse_errors = self._parse_yaml_safe(raw_output)
        if parse_errors:
            validation_result = ValidationResult(valid=False, data=None, errors=parse_errors)
            return CorrectionResult(
                corrected_yaml=raw_output,
                corrections=corrections,
                validation_result=validation_result,
                success=False,
            )

        assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

        # Add missing required fields
        if &#34;game_title&#34; not in data:
            data[&#34;game_title&#34;] = &#34;Untitled Game&#34;
            corrections.append(&#34;Added missing &#39;game_title&#39; field with default value&#34;)
            logger.info(&#34;Added missing &#39;game_title&#39; field&#34;)

        if &#34;game_systems&#34; not in data:
            data[&#34;game_systems&#34;] = {}
            corrections.append(&#34;Added missing &#39;game_systems&#39; field&#34;)
            logger.info(&#34;Added missing &#39;game_systems&#39; field&#34;)

        # Ensure game_systems has all required subsystems
        game_systems = data[&#34;game_systems&#34;]
        if not isinstance(game_systems, dict):
            game_systems = {}
            data[&#34;game_systems&#34;] = game_systems
            corrections.append(&#34;Converted &#39;game_systems&#39; to dictionary&#34;)

        if &#34;movement&#34; not in game_systems:
            game_systems[&#34;movement&#34;] = {
                &#34;description&#34;: self._extend_short_description(
                    &#34;Movement system for navigating the game world.&#34;, 50
                ),
                &#34;commands&#34;: [&#34;move&#34;],
                &#34;narrative_purpose&#34;: self._extend_short_description(
                    &#34;Allows players to explore and navigate the environment.&#34;, 50
                ),
            }
            corrections.append(&#34;Added missing &#39;movement&#39; system&#34;)
            logger.info(&#34;Added missing &#39;movement&#39; system&#34;)

        if &#34;inventory&#34; not in game_systems:
            game_systems[&#34;inventory&#34;] = {
                &#34;description&#34;: self._extend_short_description(
                    &#34;Inventory system for managing items and equipment.&#34;, 50
                ),
                &#34;capacity&#34;: 10,
                &#34;commands&#34;: [&#34;take&#34;, &#34;drop&#34;, &#34;use&#34;],
                &#34;narrative_purpose&#34;: self._extend_short_description(
                    &#34;Allows players to collect and manage resources.&#34;, 50
                ),
            }
            corrections.append(&#34;Added missing &#39;inventory&#39; system&#34;)
            logger.info(&#34;Added missing &#39;inventory&#39; system&#34;)

        if &#34;combat&#34; not in game_systems:
            game_systems[&#34;combat&#34;] = {
                &#34;description&#34;: self._extend_short_description(
                    &#34;Combat system for engaging with enemies and threats.&#34;, 50
                ),
                &#34;mechanics&#34;: [
                    {
                        &#34;name&#34;: &#34;Attack&#34;,
                        &#34;rules&#34;: &#34;Basic attack mechanic for engaging enemies in combat.&#34;,
                    }
                ],
                &#34;narrative_purpose&#34;: self._extend_short_description(
                    &#34;Provides challenge and conflict resolution.&#34;, 50
                ),
            }
            corrections.append(&#34;Added missing &#39;combat&#39; system&#34;)
            logger.info(&#34;Added missing &#39;combat&#39; system&#34;)

        if &#34;interaction&#34; not in game_systems:
            game_systems[&#34;interaction&#34;] = {
                &#34;description&#34;: self._extend_short_description(
                    &#34;Interaction system for engaging with the environment and NPCs.&#34;, 50
                ),
                &#34;commands&#34;: [&#34;examine&#34;, &#34;talk&#34;],
                &#34;narrative_purpose&#34;: self._extend_short_description(
                    &#34;Allows players to discover information and progress the story.&#34;, 50
                ),
            }
            corrections.append(&#34;Added missing &#39;interaction&#39; system&#34;)
            logger.info(&#34;Added missing &#39;interaction&#39; system&#34;)

        if &#34;game_state&#34; not in data:
            data[&#34;game_state&#34;] = {
                &#34;tracked_variables&#34;: [
                    {
                        &#34;variable&#34;: &#34;progress&#34;,
                        &#34;purpose&#34;: &#34;Tracks player progress through the game.&#34;,
                    }
                ],
                &#34;win_conditions&#34;: [{&#34;condition&#34;: &#34;Successfully complete the primary objective.&#34;}],
                &#34;lose_conditions&#34;: [
                    {&#34;condition&#34;: &#34;Player character is defeated or incapacitated.&#34;}
                ],
            }
            corrections.append(&#34;Added missing &#39;game_state&#39; field with minimal defaults&#34;)
            logger.info(&#34;Added missing &#39;game_state&#39; field&#34;)

        if &#34;technical_requirements&#34; not in data or not data[&#34;technical_requirements&#34;]:
            data[&#34;technical_requirements&#34;] = [
                {
                    &#34;requirement&#34;: (
                        &#34;Basic game engine functionality for managing game state and logic.&#34;
                        &#34;Basic game engine functionality for managing game state and logic.&#34;
                    ),
                    &#34;justification&#34;: &#34;Required for the game to function properly.&#34;,
                }
            ]
            corrections.append(&#34;Added missing &#39;technical_requirements&#39; field with minimal default&#34;)
            logger.info(&#34;Added missing &#39;technical_requirements&#39; field&#34;)

        # Convert back to YAML
        try:
            corrected_yaml = yaml.dump(
                data, default_flow_style=False, sort_keys=False, allow_unicode=True
            )
        except Exception as e:
            logger.error(f&#34;Error converting corrected data to YAML: {e}&#34;)
            validation_result = ValidationResult(
                valid=False, data=None, errors=[f&#34;Error converting to YAML: {e!s}&#34;]
            )
            return CorrectionResult(
                corrected_yaml=raw_output,
                corrections=corrections,
                validation_result=validation_result,
                success=False,
            )

        # Validate corrected output
        validation_result = self.validator.validate_game_mechanics(corrected_yaml)

        logger.info(
            f&#34;Game mechanics correction complete: {len(corrections)} corrections, &#34;
            f&#34;valid={validation_result.valid}&#34;
        )

        return CorrectionResult(
            corrected_yaml=corrected_yaml,
            corrections=corrections,
            validation_result=validation_result,
            success=validation_result.valid,
        )</code></pre>
</details>
<div class="desc"><p>Auto-corrector for YAML validation outputs.</p>
<p>This class provides methods to automatically fix common validation errors
in YAML outputs from AI agents. It attempts to add missing required fields,
fix syntax errors, normalize field names, and correct ID format violations.</p>
<h2 id="features">Features</h2>
<ul>
<li>Fixes missing required fields with sensible defaults</li>
<li>Repairs common YAML syntax errors</li>
<li>Normalizes field names (e.g., camelCase to snake_case)</li>
<li>Corrects ID format violations (lowercase, underscores, alphanumeric)</li>
<li>Logs all corrections transparently</li>
<li>Validates corrected output</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; corrector = OutputCorrector()
&gt;&gt;&gt; result = corrector.correct_plot(invalid_yaml_string)
&gt;&gt;&gt; if result.success:
...     print(f&quot;Corrections applied: {result.corrections}&quot;)
...     with open('output.yaml', 'w') as f:
...         f.write(result.corrected_yaml)
... else:
...     print(f&quot;Correction failed: {result.validation_result.errors}&quot;)
</code></pre>
<p>Initialize the output corrector with a validator instance.</p></div>
<h3>Methods</h3>
<dl>
<dt id="space_hulk_game.validation.OutputCorrector.correct_game_mechanics"><code class="name flex">
<span>def <span class="ident">correct_game_mechanics</span></span>(<span>self, raw_output: str) ‑> <a title="space_hulk_game.validation.corrector.CorrectionResult" href="corrector.html#space_hulk_game.validation.corrector.CorrectionResult">CorrectionResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def correct_game_mechanics(self, raw_output: str) -&gt; CorrectionResult:
    &#34;&#34;&#34;Attempt to correct common errors in game mechanics YAML.

    Fixes:
        - Missing required fields (game_systems, game_state, technical_requirements)
        - Descriptions too short
        - YAML syntax errors

    Args:
        raw_output: Raw YAML string containing game mechanics data.

    Returns:
        CorrectionResult with corrected YAML, list of corrections,
        validation result, and success status.

    Example:
        &gt;&gt;&gt; corrector = OutputCorrector()
        &gt;&gt;&gt; result = corrector.correct_game_mechanics(invalid_mechanics_yaml)
        &gt;&gt;&gt; if result.success:
        ...     print(f&#34;Game mechanics corrected with {len(result.corrections)} changes&#34;)
    &#34;&#34;&#34;
    logger.info(&#34;Attempting to correct game mechanics YAML&#34;)
    corrections: list[str] = []

    # Parse YAML
    data, parse_errors = self._parse_yaml_safe(raw_output)
    if parse_errors:
        validation_result = ValidationResult(valid=False, data=None, errors=parse_errors)
        return CorrectionResult(
            corrected_yaml=raw_output,
            corrections=corrections,
            validation_result=validation_result,
            success=False,
        )

    assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

    # Add missing required fields
    if &#34;game_title&#34; not in data:
        data[&#34;game_title&#34;] = &#34;Untitled Game&#34;
        corrections.append(&#34;Added missing &#39;game_title&#39; field with default value&#34;)
        logger.info(&#34;Added missing &#39;game_title&#39; field&#34;)

    if &#34;game_systems&#34; not in data:
        data[&#34;game_systems&#34;] = {}
        corrections.append(&#34;Added missing &#39;game_systems&#39; field&#34;)
        logger.info(&#34;Added missing &#39;game_systems&#39; field&#34;)

    # Ensure game_systems has all required subsystems
    game_systems = data[&#34;game_systems&#34;]
    if not isinstance(game_systems, dict):
        game_systems = {}
        data[&#34;game_systems&#34;] = game_systems
        corrections.append(&#34;Converted &#39;game_systems&#39; to dictionary&#34;)

    if &#34;movement&#34; not in game_systems:
        game_systems[&#34;movement&#34;] = {
            &#34;description&#34;: self._extend_short_description(
                &#34;Movement system for navigating the game world.&#34;, 50
            ),
            &#34;commands&#34;: [&#34;move&#34;],
            &#34;narrative_purpose&#34;: self._extend_short_description(
                &#34;Allows players to explore and navigate the environment.&#34;, 50
            ),
        }
        corrections.append(&#34;Added missing &#39;movement&#39; system&#34;)
        logger.info(&#34;Added missing &#39;movement&#39; system&#34;)

    if &#34;inventory&#34; not in game_systems:
        game_systems[&#34;inventory&#34;] = {
            &#34;description&#34;: self._extend_short_description(
                &#34;Inventory system for managing items and equipment.&#34;, 50
            ),
            &#34;capacity&#34;: 10,
            &#34;commands&#34;: [&#34;take&#34;, &#34;drop&#34;, &#34;use&#34;],
            &#34;narrative_purpose&#34;: self._extend_short_description(
                &#34;Allows players to collect and manage resources.&#34;, 50
            ),
        }
        corrections.append(&#34;Added missing &#39;inventory&#39; system&#34;)
        logger.info(&#34;Added missing &#39;inventory&#39; system&#34;)

    if &#34;combat&#34; not in game_systems:
        game_systems[&#34;combat&#34;] = {
            &#34;description&#34;: self._extend_short_description(
                &#34;Combat system for engaging with enemies and threats.&#34;, 50
            ),
            &#34;mechanics&#34;: [
                {
                    &#34;name&#34;: &#34;Attack&#34;,
                    &#34;rules&#34;: &#34;Basic attack mechanic for engaging enemies in combat.&#34;,
                }
            ],
            &#34;narrative_purpose&#34;: self._extend_short_description(
                &#34;Provides challenge and conflict resolution.&#34;, 50
            ),
        }
        corrections.append(&#34;Added missing &#39;combat&#39; system&#34;)
        logger.info(&#34;Added missing &#39;combat&#39; system&#34;)

    if &#34;interaction&#34; not in game_systems:
        game_systems[&#34;interaction&#34;] = {
            &#34;description&#34;: self._extend_short_description(
                &#34;Interaction system for engaging with the environment and NPCs.&#34;, 50
            ),
            &#34;commands&#34;: [&#34;examine&#34;, &#34;talk&#34;],
            &#34;narrative_purpose&#34;: self._extend_short_description(
                &#34;Allows players to discover information and progress the story.&#34;, 50
            ),
        }
        corrections.append(&#34;Added missing &#39;interaction&#39; system&#34;)
        logger.info(&#34;Added missing &#39;interaction&#39; system&#34;)

    if &#34;game_state&#34; not in data:
        data[&#34;game_state&#34;] = {
            &#34;tracked_variables&#34;: [
                {
                    &#34;variable&#34;: &#34;progress&#34;,
                    &#34;purpose&#34;: &#34;Tracks player progress through the game.&#34;,
                }
            ],
            &#34;win_conditions&#34;: [{&#34;condition&#34;: &#34;Successfully complete the primary objective.&#34;}],
            &#34;lose_conditions&#34;: [
                {&#34;condition&#34;: &#34;Player character is defeated or incapacitated.&#34;}
            ],
        }
        corrections.append(&#34;Added missing &#39;game_state&#39; field with minimal defaults&#34;)
        logger.info(&#34;Added missing &#39;game_state&#39; field&#34;)

    if &#34;technical_requirements&#34; not in data or not data[&#34;technical_requirements&#34;]:
        data[&#34;technical_requirements&#34;] = [
            {
                &#34;requirement&#34;: (
                    &#34;Basic game engine functionality for managing game state and logic.&#34;
                    &#34;Basic game engine functionality for managing game state and logic.&#34;
                ),
                &#34;justification&#34;: &#34;Required for the game to function properly.&#34;,
            }
        ]
        corrections.append(&#34;Added missing &#39;technical_requirements&#39; field with minimal default&#34;)
        logger.info(&#34;Added missing &#39;technical_requirements&#39; field&#34;)

    # Convert back to YAML
    try:
        corrected_yaml = yaml.dump(
            data, default_flow_style=False, sort_keys=False, allow_unicode=True
        )
    except Exception as e:
        logger.error(f&#34;Error converting corrected data to YAML: {e}&#34;)
        validation_result = ValidationResult(
            valid=False, data=None, errors=[f&#34;Error converting to YAML: {e!s}&#34;]
        )
        return CorrectionResult(
            corrected_yaml=raw_output,
            corrections=corrections,
            validation_result=validation_result,
            success=False,
        )

    # Validate corrected output
    validation_result = self.validator.validate_game_mechanics(corrected_yaml)

    logger.info(
        f&#34;Game mechanics correction complete: {len(corrections)} corrections, &#34;
        f&#34;valid={validation_result.valid}&#34;
    )

    return CorrectionResult(
        corrected_yaml=corrected_yaml,
        corrections=corrections,
        validation_result=validation_result,
        success=validation_result.valid,
    )</code></pre>
</details>
<div class="desc"><p>Attempt to correct common errors in game mechanics YAML.</p>
<h2 id="fixes">Fixes</h2>
<ul>
<li>Missing required fields (game_systems, game_state, technical_requirements)</li>
<li>Descriptions too short</li>
<li>YAML syntax errors</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_output</code></strong></dt>
<dd>Raw YAML string containing game mechanics data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>CorrectionResult with corrected YAML, list of corrections,
validation result, and success status.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; corrector = OutputCorrector()
&gt;&gt;&gt; result = corrector.correct_game_mechanics(invalid_mechanics_yaml)
&gt;&gt;&gt; if result.success:
...     print(f&quot;Game mechanics corrected with {len(result.corrections)} changes&quot;)
</code></pre></div>
</dd>
<dt id="space_hulk_game.validation.OutputCorrector.correct_narrative_map"><code class="name flex">
<span>def <span class="ident">correct_narrative_map</span></span>(<span>self, raw_output: str) ‑> <a title="space_hulk_game.validation.corrector.CorrectionResult" href="corrector.html#space_hulk_game.validation.corrector.CorrectionResult">CorrectionResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def correct_narrative_map(self, raw_output: str) -&gt; CorrectionResult:
    &#34;&#34;&#34;Attempt to correct common errors in narrative map YAML.

    Fixes:
        - Missing required fields (start_scene, scenes)
        - Invalid ID formats
        - Descriptions too short
        - YAML syntax errors

    Args:
        raw_output: Raw YAML string containing narrative map data.

    Returns:
        CorrectionResult with corrected YAML, list of corrections,
        validation result, and success status.

    Example:
        &gt;&gt;&gt; corrector = OutputCorrector()
        &gt;&gt;&gt; result = corrector.correct_narrative_map(invalid_map_yaml)
        &gt;&gt;&gt; if result.success:
        ...     print(f&#34;Map corrected with {len(result.corrections)} changes&#34;)
    &#34;&#34;&#34;
    logger.info(&#34;Attempting to correct narrative map YAML&#34;)
    corrections: list[str] = []

    # Parse YAML
    data, parse_errors = self._parse_yaml_safe(raw_output)
    if parse_errors:
        validation_result = ValidationResult(valid=False, data=None, errors=parse_errors)
        return CorrectionResult(
            corrected_yaml=raw_output,
            corrections=corrections,
            validation_result=validation_result,
            success=False,
        )

    assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

    # Add missing required fields
    if &#34;scenes&#34; not in data or not data[&#34;scenes&#34;]:
        data[&#34;scenes&#34;] = {
            &#34;scene_default&#34;: {
                &#34;name&#34;: &#34;Default Scene&#34;,
                &#34;description&#34;: self._extend_short_description(
                    &#34;A default scene in the narrative.&#34;, 50
                ),
                &#34;connections&#34;: [],
            }
        }
        corrections.append(&#34;Added missing &#39;scenes&#39; field with minimal default&#34;)
        logger.info(&#34;Added missing &#39;scenes&#39; field&#34;)

    if &#34;start_scene&#34; not in data:
        # Use the first scene as the start scene
        if isinstance(data.get(&#34;scenes&#34;), dict) and data[&#34;scenes&#34;]:
            first_scene_id = next(iter(data[&#34;scenes&#34;].keys()))
            data[&#34;start_scene&#34;] = first_scene_id
            corrections.append(f&#34;Added missing &#39;start_scene&#39; field (set to &#39;{first_scene_id}&#39;)&#34;)
            logger.info(f&#34;Added missing &#39;start_scene&#39; field: {first_scene_id}&#34;)
        else:
            data[&#34;start_scene&#34;] = &#34;scene_default&#34;
            corrections.append(&#34;Added missing &#39;start_scene&#39; field with default value&#34;)
            logger.info(&#34;Added missing &#39;start_scene&#39; field&#34;)

    # Fix scene IDs and descriptions
    if &#34;scenes&#34; in data and isinstance(data[&#34;scenes&#34;], dict):
        fixed_scenes = {}
        for scene_id, scene in data[&#34;scenes&#34;].items():
            # Fix scene ID format
            fixed_id = self._fix_id_format(scene_id)
            if scene_id != fixed_id:
                corrections.append(f&#34;Fixed scene ID format: &#39;{scene_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;)
                logger.info(f&#34;Fixed scene ID: {scene_id} -&gt; {fixed_id}&#34;)
                # Update start_scene if it matches the old ID
                if data.get(&#34;start_scene&#34;) == scene_id:
                    data[&#34;start_scene&#34;] = fixed_id
                    corrections.append(f&#34;Updated &#39;start_scene&#39; to match fixed ID: &#39;{fixed_id}&#39;&#34;)

            if isinstance(scene, dict):
                # Extend short descriptions
                if &#34;description&#34; in scene and len(scene[&#34;description&#34;]) &lt; 50:
                    original_desc = scene[&#34;description&#34;]
                    scene[&#34;description&#34;] = self._extend_short_description(
                        scene[&#34;description&#34;], 50
                    )
                    corrections.append(
                        f&#34;Extended short scene description (was {len(original_desc)} chars)&#34;
                        f&#34;Extended short scene description (was {len(original_desc)} chars)&#34;
                    )
                    logger.info(
                        f&#34;Extended scene description from {len(original_desc)} &#34;
                        f&#34;to {len(scene[&#39;description&#39;])} chars&#34;
                    )

                # Ensure connections is a list
                if &#34;connections&#34; not in scene:
                    scene[&#34;connections&#34;] = []
                    corrections.append(
                        f&#34;Added missing &#39;connections&#39; field to scene &#39;{fixed_id}&#39;&#34;
                    )

                # Fix connection target IDs
                if &#34;connections&#34; in scene and isinstance(scene[&#34;connections&#34;], list):
                    for conn in scene[&#34;connections&#34;]:
                        if isinstance(conn, dict) and &#34;target&#34; in conn:
                            original_target = conn[&#34;target&#34;]
                            fixed_target = self._fix_id_format(original_target)
                            if original_target != fixed_target:
                                conn[&#34;target&#34;] = fixed_target
                                corrections.append(
                                    f&#34;Fixed connection target ID: &#34;
                                    f&#34;&#39;{original_target}&#39; -&gt; &#39;{fixed_target}&#39;&#34;
                                )

            fixed_scenes[fixed_id] = scene

        data[&#34;scenes&#34;] = fixed_scenes

    # Convert back to YAML
    try:
        corrected_yaml = yaml.dump(
            data, default_flow_style=False, sort_keys=False, allow_unicode=True
        )
    except Exception as e:
        logger.error(f&#34;Error converting corrected data to YAML: {e}&#34;)
        validation_result = ValidationResult(
            valid=False, data=None, errors=[f&#34;Error converting to YAML: {e!s}&#34;]
        )
        return CorrectionResult(
            corrected_yaml=raw_output,
            corrections=corrections,
            validation_result=validation_result,
            success=False,
        )

    # Validate corrected output
    validation_result = self.validator.validate_narrative_map(corrected_yaml)

    logger.info(
        f&#34;Narrative map correction complete: {len(corrections)} corrections, &#34;
        f&#34;valid={validation_result.valid}&#34;
    )

    return CorrectionResult(
        corrected_yaml=corrected_yaml,
        corrections=corrections,
        validation_result=validation_result,
        success=validation_result.valid,
    )</code></pre>
</details>
<div class="desc"><p>Attempt to correct common errors in narrative map YAML.</p>
<h2 id="fixes">Fixes</h2>
<ul>
<li>Missing required fields (start_scene, scenes)</li>
<li>Invalid ID formats</li>
<li>Descriptions too short</li>
<li>YAML syntax errors</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_output</code></strong></dt>
<dd>Raw YAML string containing narrative map data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>CorrectionResult with corrected YAML, list of corrections,
validation result, and success status.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; corrector = OutputCorrector()
&gt;&gt;&gt; result = corrector.correct_narrative_map(invalid_map_yaml)
&gt;&gt;&gt; if result.success:
...     print(f&quot;Map corrected with {len(result.corrections)} changes&quot;)
</code></pre></div>
</dd>
<dt id="space_hulk_game.validation.OutputCorrector.correct_plot"><code class="name flex">
<span>def <span class="ident">correct_plot</span></span>(<span>self, raw_output: str) ‑> <a title="space_hulk_game.validation.corrector.CorrectionResult" href="corrector.html#space_hulk_game.validation.corrector.CorrectionResult">CorrectionResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def correct_plot(self, raw_output: str) -&gt; CorrectionResult:
    &#34;&#34;&#34;Attempt to correct common errors in plot outline YAML.

    Fixes:
        - Missing required fields (plot_points, characters, conflicts)
        - Invalid ID formats
        - Descriptions too short
        - YAML syntax errors

    Args:
        raw_output: Raw YAML string containing plot outline data.

    Returns:
        CorrectionResult with corrected YAML, list of corrections,
        validation result, and success status.

    Example:
        &gt;&gt;&gt; corrector = OutputCorrector()
        &gt;&gt;&gt; result = corrector.correct_plot(invalid_plot_yaml)
        &gt;&gt;&gt; if result.success:
        ...     print(f&#34;Plot corrected with {len(result.corrections)} changes&#34;)
    &#34;&#34;&#34;
    logger.info(&#34;Attempting to correct plot outline YAML&#34;)
    corrections: list[str] = []

    # Parse YAML
    data, parse_errors = self._parse_yaml_safe(raw_output)
    if parse_errors:
        # Can&#39;t fix unparseable YAML beyond basic syntax fixes already attempted
        validation_result = ValidationResult(valid=False, data=None, errors=parse_errors)
        return CorrectionResult(
            corrected_yaml=raw_output,
            corrections=corrections,
            validation_result=validation_result,
            success=False,
        )

    # Type guard: data is guaranteed to be dict here
    assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

    # Add missing required fields
    if &#34;title&#34; not in data:
        data[&#34;title&#34;] = &#34;Untitled Plot&#34;
        corrections.append(&#34;Added missing &#39;title&#39; field with default value&#34;)
        logger.info(&#34;Added missing &#39;title&#39; field&#34;)

    if &#34;setting&#34; not in data:
        data[&#34;setting&#34;] = self._extend_short_description(
            &#34;A dark and atmospheric setting for the narrative.&#34;, 50
        )
        corrections.append(&#34;Added missing &#39;setting&#39; field with default value&#34;)
        logger.info(&#34;Added missing &#39;setting&#39; field&#34;)
    elif len(data[&#34;setting&#34;]) &lt; 50:
        original_setting = data[&#34;setting&#34;]
        data[&#34;setting&#34;] = self._extend_short_description(data[&#34;setting&#34;], 50)
        corrections.append(
            f&#34;Extended short &#39;setting&#39; field (was {len(original_setting)} chars)&#34;
        )
        logger.info(&#34;Extended &#39;setting&#39; field&#34;)

    if &#34;themes&#34; not in data or not data[&#34;themes&#34;]:
        data[&#34;themes&#34;] = [&#34;survival&#34;, &#34;conflict&#34;]
        corrections.append(&#34;Added missing &#39;themes&#39; field with default values&#34;)
        logger.info(&#34;Added missing &#39;themes&#39; field&#34;)

    if &#34;tone&#34; not in data:
        data[&#34;tone&#34;] = &#34;Dark and atmospheric&#34;
        corrections.append(&#34;Added missing &#39;tone&#39; field with default value&#34;)
        logger.info(&#34;Added missing &#39;tone&#39; field&#34;)
    elif len(data[&#34;tone&#34;]) &lt; 10:
        original_tone = data[&#34;tone&#34;]
        data[&#34;tone&#34;] = self._extend_short_description(data[&#34;tone&#34;], 10)
        corrections.append(f&#34;Extended short &#39;tone&#39; field (was {len(original_tone)} chars)&#34;)
        logger.info(&#34;Extended &#39;tone&#39; field&#34;)

    if &#34;plot_points&#34; not in data or not data[&#34;plot_points&#34;]:
        data[&#34;plot_points&#34;] = [
            {
                &#34;id&#34;: &#34;pp_01_opening&#34;,
                &#34;name&#34;: &#34;Opening&#34;,
                &#34;description&#34;: self._extend_short_description(
                    &#34;The story begins with the initial situation.&#34;, 50
                ),
            },
            {
                &#34;id&#34;: &#34;pp_02_development&#34;,
                &#34;name&#34;: &#34;Development&#34;,
                &#34;description&#34;: self._extend_short_description(
                    &#34;The plot develops as events unfold.&#34;, 50
                ),
            },
            {
                &#34;id&#34;: &#34;pp_03_conclusion&#34;,
                &#34;name&#34;: &#34;Conclusion&#34;,
                &#34;description&#34;: self._extend_short_description(
                    &#34;The story reaches its conclusion and resolution.&#34;, 50
                ),
            },
        ]
        corrections.append(&#34;Added missing &#39;plot_points&#39; field with minimal defaults&#34;)
        logger.info(&#34;Added missing &#39;plot_points&#39; field&#34;)

    if &#34;characters&#34; not in data or not data[&#34;characters&#34;]:
        data[&#34;characters&#34;] = [
            {
                &#34;name&#34;: &#34;Protagonist&#34;,
                &#34;role&#34;: &#34;Main character&#34;,
                &#34;backstory&#34;: self._extend_short_description(
                    &#34;The protagonist&#39;s background and history.&#34;, 50
                ),
            }
        ]
        corrections.append(&#34;Added missing &#39;characters&#39; field with minimal default&#34;)
        logger.info(&#34;Added missing &#39;characters&#39; field&#34;)

    if &#34;conflicts&#34; not in data or not data[&#34;conflicts&#34;]:
        data[&#34;conflicts&#34;] = [
            {
                &#34;type&#34;: &#34;Main Conflict&#34;,
                &#34;description&#34;: self._extend_short_description(
                    &#34;The primary conflict driving the narrative.&#34;, 50
                ),
            }
        ]
        corrections.append(&#34;Added missing &#39;conflicts&#39; field with minimal default&#34;)
        logger.info(&#34;Added missing &#39;conflicts&#39; field&#34;)

    # Fix plot point IDs and descriptions
    if &#34;plot_points&#34; in data and isinstance(data[&#34;plot_points&#34;], list):
        for _i, pp in enumerate(data[&#34;plot_points&#34;]):
            if isinstance(pp, dict):
                # Fix ID format
                if &#34;id&#34; in pp:
                    original_id = pp[&#34;id&#34;]
                    fixed_id = self._fix_id_format(original_id)
                    if original_id != fixed_id:
                        pp[&#34;id&#34;] = fixed_id
                        corrections.append(
                            f&#34;Fixed plot point ID format: &#39;{original_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;
                        )
                        logger.info(f&#34;Fixed plot point ID: {original_id} -&gt; {fixed_id}&#34;)

                # Extend short descriptions
                if &#34;description&#34; in pp and len(pp[&#34;description&#34;]) &lt; 50:
                    original_desc = pp[&#34;description&#34;]
                    pp[&#34;description&#34;] = self._extend_short_description(pp[&#34;description&#34;], 50)
                    corrections.append(
                        f&#34;Extended short plot point description &#34;
                        f&#34;(was {len(original_desc)} chars)&#34;
                    )
                    logger.info(
                        f&#34;Extended plot point description from {len(original_desc)} &#34;
                        f&#34;to {len(pp[&#39;description&#39;])} chars&#34;
                    )

    # Fix character backstories
    if &#34;characters&#34; in data and isinstance(data[&#34;characters&#34;], list):
        for char in data[&#34;characters&#34;]:
            if isinstance(char, dict) and &#34;backstory&#34; in char and len(char[&#34;backstory&#34;]) &lt; 50:
                original_backstory = char[&#34;backstory&#34;]
                char[&#34;backstory&#34;] = self._extend_short_description(char[&#34;backstory&#34;], 50)
                corrections.append(
                    f&#34;Extended short character backstory (was {len(original_backstory)} chars)&#34;
                )
                logger.info(
                    f&#34;Extended character backstory from {len(original_backstory)} &#34;
                    f&#34;to {len(char[&#39;backstory&#39;])} chars&#34;
                )

    # Fix conflict descriptions
    if &#34;conflicts&#34; in data and isinstance(data[&#34;conflicts&#34;], list):
        for conflict in data[&#34;conflicts&#34;]:
            if (
                isinstance(conflict, dict)
                and &#34;description&#34; in conflict
                and len(conflict[&#34;description&#34;]) &lt; 50
            ):
                original_desc = conflict[&#34;description&#34;]
                conflict[&#34;description&#34;] = self._extend_short_description(
                    conflict[&#34;description&#34;], 50
                )
                corrections.append(
                    f&#34;Extended short conflict description (was {len(original_desc)} chars)&#34;
                )
                logger.info(
                    f&#34;Extended conflict description from {len(original_desc)} &#34;
                    f&#34;to {len(conflict[&#39;description&#39;])} chars&#34;
                )

    # Convert back to YAML
    try:
        corrected_yaml = yaml.dump(
            data, default_flow_style=False, sort_keys=False, allow_unicode=True
        )
    except Exception as e:
        logger.error(f&#34;Error converting corrected data to YAML: {e}&#34;)
        validation_result = ValidationResult(
            valid=False, data=None, errors=[f&#34;Error converting to YAML: {e!s}&#34;]
        )
        return CorrectionResult(
            corrected_yaml=raw_output,
            corrections=corrections,
            validation_result=validation_result,
            success=False,
        )

    # Validate corrected output
    validation_result = self.validator.validate_plot(corrected_yaml)

    logger.info(
        f&#34;Plot correction complete: {len(corrections)} corrections, &#34;
        f&#34;valid={validation_result.valid}&#34;
    )

    return CorrectionResult(
        corrected_yaml=corrected_yaml,
        corrections=corrections,
        validation_result=validation_result,
        success=validation_result.valid,
    )</code></pre>
</details>
<div class="desc"><p>Attempt to correct common errors in plot outline YAML.</p>
<h2 id="fixes">Fixes</h2>
<ul>
<li>Missing required fields (plot_points, characters, conflicts)</li>
<li>Invalid ID formats</li>
<li>Descriptions too short</li>
<li>YAML syntax errors</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_output</code></strong></dt>
<dd>Raw YAML string containing plot outline data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>CorrectionResult with corrected YAML, list of corrections,
validation result, and success status.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; corrector = OutputCorrector()
&gt;&gt;&gt; result = corrector.correct_plot(invalid_plot_yaml)
&gt;&gt;&gt; if result.success:
...     print(f&quot;Plot corrected with {len(result.corrections)} changes&quot;)
</code></pre></div>
</dd>
<dt id="space_hulk_game.validation.OutputCorrector.correct_puzzle_design"><code class="name flex">
<span>def <span class="ident">correct_puzzle_design</span></span>(<span>self, raw_output: str) ‑> <a title="space_hulk_game.validation.corrector.CorrectionResult" href="corrector.html#space_hulk_game.validation.corrector.CorrectionResult">CorrectionResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def correct_puzzle_design(self, raw_output: str) -&gt; CorrectionResult:
    &#34;&#34;&#34;Attempt to correct common errors in puzzle design YAML.

    Fixes:
        - Missing required fields (puzzles, artifacts, monsters, npcs)
        - Invalid ID formats
        - Descriptions too short
        - YAML syntax errors

    Args:
        raw_output: Raw YAML string containing puzzle design data.

    Returns:
        CorrectionResult with corrected YAML, list of corrections,
        validation result, and success status.

    Example:
        &gt;&gt;&gt; corrector = OutputCorrector()
        &gt;&gt;&gt; result = corrector.correct_puzzle_design(invalid_puzzle_yaml)
        &gt;&gt;&gt; if result.success:
        ...     print(f&#34;Puzzle design corrected with {len(result.corrections)} changes&#34;)
    &#34;&#34;&#34;
    logger.info(&#34;Attempting to correct puzzle design YAML&#34;)
    corrections: list[str] = []

    # Parse YAML
    data, parse_errors = self._parse_yaml_safe(raw_output)
    if parse_errors:
        validation_result = ValidationResult(valid=False, data=None, errors=parse_errors)
        return CorrectionResult(
            corrected_yaml=raw_output,
            corrections=corrections,
            validation_result=validation_result,
            success=False,
        )

    assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

    # Add missing required fields
    if &#34;puzzles&#34; not in data or not data[&#34;puzzles&#34;]:
        data[&#34;puzzles&#34;] = [
            {
                &#34;id&#34;: &#34;puzzle_default&#34;,
                &#34;name&#34;: &#34;Default Puzzle&#34;,
                &#34;description&#34;: self._extend_short_description(
                    &#34;A puzzle in the game that requires solving.&#34;, 50
                ),
                &#34;location&#34;: &#34;scene_default&#34;,
                &#34;narrative_purpose&#34;: &#34;Provides a challenge for the player to overcome.&#34;,
                &#34;solution&#34;: {
                    &#34;type&#34;: &#34;multi-step&#34;,
                    &#34;steps&#34;: [{&#34;step&#34;: &#34;Complete the required actions to solve this puzzle.&#34;}],
                },
                &#34;difficulty&#34;: &#34;medium&#34;,
            }
        ]
        corrections.append(&#34;Added missing &#39;puzzles&#39; field with minimal default&#34;)
        logger.info(&#34;Added missing &#39;puzzles&#39; field&#34;)

    if &#34;artifacts&#34; not in data or not data[&#34;artifacts&#34;]:
        data[&#34;artifacts&#34;] = [
            {
                &#34;id&#34;: &#34;artifact_default&#34;,
                &#34;name&#34;: &#34;Default Artifact&#34;,
                &#34;description&#34;: &#34;An artifact found in the game world.&#34;,
                &#34;location&#34;: &#34;scene_default&#34;,
                &#34;narrative_significance&#34;: &#34;Holds narrative importance to the story.&#34;,
                &#34;properties&#34;: [{&#34;property&#34;: &#34;Has special properties or effects&#34;}],
            }
        ]
        corrections.append(&#34;Added missing &#39;artifacts&#39; field with minimal default&#34;)
        logger.info(&#34;Added missing &#39;artifacts&#39; field&#34;)

    if &#34;monsters&#34; not in data or not data[&#34;monsters&#34;]:
        data[&#34;monsters&#34;] = [
            {
                &#34;id&#34;: &#34;monster_default&#34;,
                &#34;name&#34;: &#34;Default Monster&#34;,
                &#34;description&#34;: &#34;A hostile entity encountered in the game.&#34;,
                &#34;locations&#34;: [&#34;scene_default&#34;],
                &#34;narrative_role&#34;: &#34;Provides combat challenge and threat.&#34;,
                &#34;abilities&#34;: [&#34;Attack&#34;],
            }
        ]
        corrections.append(&#34;Added missing &#39;monsters&#39; field with minimal default&#34;)
        logger.info(&#34;Added missing &#39;monsters&#39; field&#34;)

    if &#34;npcs&#34; not in data or not data[&#34;npcs&#34;]:
        data[&#34;npcs&#34;] = [
            {
                &#34;id&#34;: &#34;npc_default&#34;,
                &#34;name&#34;: &#34;Default NPC&#34;,
                &#34;role&#34;: &#34;Supporting character&#34;,
                &#34;description&#34;: &#34;A non-player character in the game.&#34;,
                &#34;locations&#34;: [&#34;scene_default&#34;],
                &#34;dialogue_themes&#34;: [&#34;General conversation&#34;],
            }
        ]
        corrections.append(&#34;Added missing &#39;npcs&#39; field with minimal default&#34;)
        logger.info(&#34;Added missing &#39;npcs&#39; field&#34;)

    # Fix puzzle IDs and descriptions
    if &#34;puzzles&#34; in data and isinstance(data[&#34;puzzles&#34;], list):
        for puzzle in data[&#34;puzzles&#34;]:
            if isinstance(puzzle, dict):
                # Fix ID format
                if &#34;id&#34; in puzzle:
                    original_id = puzzle[&#34;id&#34;]
                    fixed_id = self._fix_id_format(original_id)
                    if original_id != fixed_id:
                        puzzle[&#34;id&#34;] = fixed_id
                        corrections.append(
                            f&#34;Fixed puzzle ID format: &#39;{original_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;
                        )
                        logger.info(f&#34;Fixed puzzle ID: {original_id} -&gt; {fixed_id}&#34;)

                # Extend short descriptions
                if &#34;description&#34; in puzzle and len(puzzle[&#34;description&#34;]) &lt; 50:
                    original_desc = puzzle[&#34;description&#34;]
                    puzzle[&#34;description&#34;] = self._extend_short_description(
                        puzzle[&#34;description&#34;], 50
                    )
                    corrections.append(
                        f&#34;Extended short puzzle description (was {len(original_desc)} chars)&#34;
                    )

    # Fix artifact IDs
    if &#34;artifacts&#34; in data and isinstance(data[&#34;artifacts&#34;], list):
        for artifact in data[&#34;artifacts&#34;]:
            if isinstance(artifact, dict) and &#34;id&#34; in artifact:
                original_id = artifact[&#34;id&#34;]
                fixed_id = self._fix_id_format(original_id)
                if original_id != fixed_id:
                    artifact[&#34;id&#34;] = fixed_id
                    corrections.append(
                        f&#34;Fixed artifact ID format: &#39;{original_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;
                    )
                    logger.info(f&#34;Fixed artifact ID: {original_id} -&gt; {fixed_id}&#34;)

    # Fix monster IDs
    if &#34;monsters&#34; in data and isinstance(data[&#34;monsters&#34;], list):
        for monster in data[&#34;monsters&#34;]:
            if isinstance(monster, dict) and &#34;id&#34; in monster:
                original_id = monster[&#34;id&#34;]
                fixed_id = self._fix_id_format(original_id)
                if original_id != fixed_id:
                    monster[&#34;id&#34;] = fixed_id
                    corrections.append(
                        f&#34;Fixed monster ID format: &#39;{original_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;
                    )
                    logger.info(f&#34;Fixed monster ID: {original_id} -&gt; {fixed_id}&#34;)

    # Fix NPC IDs
    if &#34;npcs&#34; in data and isinstance(data[&#34;npcs&#34;], list):
        for npc in data[&#34;npcs&#34;]:
            if isinstance(npc, dict) and &#34;id&#34; in npc:
                original_id = npc[&#34;id&#34;]
                fixed_id = self._fix_id_format(original_id)
                if original_id != fixed_id:
                    npc[&#34;id&#34;] = fixed_id
                    corrections.append(f&#34;Fixed NPC ID format: &#39;{original_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;)
                    logger.info(f&#34;Fixed NPC ID: {original_id} -&gt; {fixed_id}&#34;)

    # Convert back to YAML
    try:
        corrected_yaml = yaml.dump(
            data, default_flow_style=False, sort_keys=False, allow_unicode=True
        )
    except Exception as e:
        logger.error(f&#34;Error converting corrected data to YAML: {e}&#34;)
        validation_result = ValidationResult(
            valid=False, data=None, errors=[f&#34;Error converting to YAML: {e!s}&#34;]
        )
        return CorrectionResult(
            corrected_yaml=raw_output,
            corrections=corrections,
            validation_result=validation_result,
            success=False,
        )

    # Validate corrected output
    validation_result = self.validator.validate_puzzle_design(corrected_yaml)

    logger.info(
        f&#34;Puzzle design correction complete: {len(corrections)} corrections, &#34;
        f&#34;valid={validation_result.valid}&#34;
    )

    return CorrectionResult(
        corrected_yaml=corrected_yaml,
        corrections=corrections,
        validation_result=validation_result,
        success=validation_result.valid,
    )</code></pre>
</details>
<div class="desc"><p>Attempt to correct common errors in puzzle design YAML.</p>
<h2 id="fixes">Fixes</h2>
<ul>
<li>Missing required fields (puzzles, artifacts, monsters, npcs)</li>
<li>Invalid ID formats</li>
<li>Descriptions too short</li>
<li>YAML syntax errors</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_output</code></strong></dt>
<dd>Raw YAML string containing puzzle design data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>CorrectionResult with corrected YAML, list of corrections,
validation result, and success status.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; corrector = OutputCorrector()
&gt;&gt;&gt; result = corrector.correct_puzzle_design(invalid_puzzle_yaml)
&gt;&gt;&gt; if result.success:
...     print(f&quot;Puzzle design corrected with {len(result.corrections)} changes&quot;)
</code></pre></div>
</dd>
<dt id="space_hulk_game.validation.OutputCorrector.correct_scene_texts"><code class="name flex">
<span>def <span class="ident">correct_scene_texts</span></span>(<span>self, raw_output: str) ‑> <a title="space_hulk_game.validation.corrector.CorrectionResult" href="corrector.html#space_hulk_game.validation.corrector.CorrectionResult">CorrectionResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def correct_scene_texts(self, raw_output: str) -&gt; CorrectionResult:
    &#34;&#34;&#34;Attempt to correct common errors in scene texts YAML.

    Fixes:
        - Missing required fields (scenes)
        - Invalid ID formats
        - Descriptions too short
        - YAML syntax errors

    Args:
        raw_output: Raw YAML string containing scene texts data.

    Returns:
        CorrectionResult with corrected YAML, list of corrections,
        validation result, and success status.

    Example:
        &gt;&gt;&gt; corrector = OutputCorrector()
        &gt;&gt;&gt; result = corrector.correct_scene_texts(invalid_scene_yaml)
        &gt;&gt;&gt; if result.success:
        ...     print(f&#34;Scene texts corrected with {len(result.corrections)} changes&#34;)
    &#34;&#34;&#34;
    logger.info(&#34;Attempting to correct scene texts YAML&#34;)
    corrections: list[str] = []

    # Parse YAML
    data, parse_errors = self._parse_yaml_safe(raw_output)
    if parse_errors:
        validation_result = ValidationResult(valid=False, data=None, errors=parse_errors)
        return CorrectionResult(
            corrected_yaml=raw_output,
            corrections=corrections,
            validation_result=validation_result,
            success=False,
        )

    assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

    # Add missing required fields
    if &#34;scenes&#34; not in data or not data[&#34;scenes&#34;]:
        data[&#34;scenes&#34;] = {
            &#34;scene_default&#34;: {
                &#34;name&#34;: &#34;Default Scene&#34;,
                &#34;description&#34;: self._extend_short_description(
                    &#34;A detailed description of this scene in the narrative, &#34;
                    &#34;providing context and atmosphere for the player.&#34;,
                    100,
                ),
                &#34;atmosphere&#34;: &#34;Atmospheric and immersive&#34;,
                &#34;initial_text&#34;: &#34;You find yourself in this scene.&#34;,
                &#34;examination_texts&#34;: {},
                &#34;dialogue&#34;: [],
            }
        }
        corrections.append(&#34;Added missing &#39;scenes&#39; field with minimal default&#34;)
        logger.info(&#34;Added missing &#39;scenes&#39; field&#34;)

    # Fix scene IDs and descriptions
    if &#34;scenes&#34; in data and isinstance(data[&#34;scenes&#34;], dict):
        fixed_scenes = {}
        for scene_id, scene in data[&#34;scenes&#34;].items():
            # Fix scene ID format
            fixed_id = self._fix_id_format(scene_id)
            if scene_id != fixed_id:
                corrections.append(f&#34;Fixed scene ID format: &#39;{scene_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;)
                logger.info(f&#34;Fixed scene ID: {scene_id} -&gt; {fixed_id}&#34;)

            if isinstance(scene, dict):
                # Extend short descriptions (scene texts require 100 chars minimum)
                if &#34;description&#34; in scene and len(scene[&#34;description&#34;]) &lt; 100:
                    original_desc = scene[&#34;description&#34;]
                    scene[&#34;description&#34;] = self._extend_short_description(
                        scene[&#34;description&#34;], 100
                    )
                    corrections.append(
                        f&#34;Extended short scene description (was {len(original_desc)} chars)&#34;
                        f&#34;Extended short scene description (was {len(original_desc)} chars)&#34;
                    )
                    logger.info(
                        f&#34;Extended scene description from {len(original_desc)} &#34;
                        f&#34;to {len(scene[&#39;description&#39;])} chars&#34;
                    )

                # Ensure required fields exist
                if &#34;atmosphere&#34; not in scene:
                    scene[&#34;atmosphere&#34;] = &#34;Atmospheric and immersive&#34;
                    corrections.append(
                        f&#34;Added missing &#39;atmosphere&#39; field to scene &#39;{fixed_id}&#39;&#34;
                    )
                elif len(scene[&#34;atmosphere&#34;]) &lt; 10:
                    original_atmo = scene[&#34;atmosphere&#34;]
                    scene[&#34;atmosphere&#34;] = self._extend_short_description(
                        scene[&#34;atmosphere&#34;], 10
                    )
                    corrections.append(
                        f&#34;Extended short &#39;atmosphere&#39; field in scene &#39;{fixed_id}&#39; &#34;
                        f&#34;(was {len(original_atmo)} chars)&#34;
                    )

                if &#34;initial_text&#34; not in scene:
                    scene[&#34;initial_text&#34;] = &#34;You find yourself in this scene.&#34;
                    corrections.append(
                        f&#34;Added missing &#39;initial_text&#39; field to scene &#39;{fixed_id}&#39;&#34;
                    )
                elif len(scene[&#34;initial_text&#34;]) &lt; 20:
                    original_text = scene[&#34;initial_text&#34;]
                    scene[&#34;initial_text&#34;] = self._extend_short_description(
                        scene[&#34;initial_text&#34;], 20
                    )
                    corrections.append(
                        f&#34;Extended short &#39;initial_text&#39; field in scene &#39;{fixed_id}&#39; &#34;
                        f&#34;(was {len(original_text)} chars)&#34;
                    )

                if &#34;examination_texts&#34; not in scene:
                    scene[&#34;examination_texts&#34;] = {}
                    corrections.append(
                        f&#34;Added missing &#39;examination_texts&#39; field to scene &#39;{fixed_id}&#39;&#34;
                    )

                if &#34;dialogue&#34; not in scene:
                    scene[&#34;dialogue&#34;] = []
                    corrections.append(f&#34;Added missing &#39;dialogue&#39; field to scene &#39;{fixed_id}&#39;&#34;)

            fixed_scenes[fixed_id] = scene

        data[&#34;scenes&#34;] = fixed_scenes

    # Convert back to YAML
    try:
        corrected_yaml = yaml.dump(
            data, default_flow_style=False, sort_keys=False, allow_unicode=True
        )
    except Exception as e:
        logger.error(f&#34;Error converting corrected data to YAML: {e}&#34;)
        validation_result = ValidationResult(
            valid=False, data=None, errors=[f&#34;Error converting to YAML: {e!s}&#34;]
        )
        return CorrectionResult(
            corrected_yaml=raw_output,
            corrections=corrections,
            validation_result=validation_result,
            success=False,
        )

    # Validate corrected output
    validation_result = self.validator.validate_scene_texts(corrected_yaml)

    logger.info(
        f&#34;Scene texts correction complete: {len(corrections)} corrections, &#34;
        f&#34;valid={validation_result.valid}&#34;
    )

    return CorrectionResult(
        corrected_yaml=corrected_yaml,
        corrections=corrections,
        validation_result=validation_result,
        success=validation_result.valid,
    )</code></pre>
</details>
<div class="desc"><p>Attempt to correct common errors in scene texts YAML.</p>
<h2 id="fixes">Fixes</h2>
<ul>
<li>Missing required fields (scenes)</li>
<li>Invalid ID formats</li>
<li>Descriptions too short</li>
<li>YAML syntax errors</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_output</code></strong></dt>
<dd>Raw YAML string containing scene texts data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>CorrectionResult with corrected YAML, list of corrections,
validation result, and success status.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; corrector = OutputCorrector()
&gt;&gt;&gt; result = corrector.correct_scene_texts(invalid_scene_yaml)
&gt;&gt;&gt; if result.success:
...     print(f&quot;Scene texts corrected with {len(result.corrections)} changes&quot;)
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.validation.OutputValidator"><code class="flex name class">
<span>class <span class="ident">OutputValidator</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OutputValidator:
    &#34;&#34;&#34;Validator for YAML outputs against Pydantic schemas.

    This class provides methods to parse and validate YAML strings
    against specific Pydantic schemas for different game design outputs.

    Features:
        - Handles markdown-wrapped YAML (common in AI outputs)
        - Provides detailed, helpful error messages
        - Validates against all schema constraints

    Example:
        &gt;&gt;&gt; validator = OutputValidator()
        &gt;&gt;&gt; result = validator.validate_plot(yaml_string)
        &gt;&gt;&gt; if result.valid:
        ...     print(f&#34;Valid plot: {result.data.title}&#34;)
        ... else:
        ...     for error in result.errors:
        ...         print(f&#34;Error: {error}&#34;)
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialize the output validator.&#34;&#34;&#34;
        logger.info(&#34;OutputValidator initialized&#34;)

    def _parse_yaml(self, raw_output: str) -&gt; tuple[dict | None, list[str]]:
        &#34;&#34;&#34;Parse YAML string into a dictionary.

        Args:
            raw_output: Raw YAML string to parse.

        Returns:
            Tuple of (parsed_data, errors). If parsing succeeds, parsed_data
            is a dict and errors is empty. If parsing fails, parsed_data is None
            and errors contains the error message.
        &#34;&#34;&#34;
        try:
            # Strip markdown fences first
            clean_yaml = strip_markdown_yaml_blocks(raw_output)
            clean_yaml = strip_markdown_yaml_blocks(raw_output)

            # Parse YAML
            data = yaml.safe_load(clean_yaml)

            if data is None:
                return None, [&#34;YAML is empty or contains only whitespace&#34;]

            if not isinstance(data, dict):
                return None, [f&#34;YAML must be a dictionary, got {type(data).__name__}&#34;]

            return data, []

        except yaml.YAMLError as e:
            error_msg = f&#34;YAML parsing error: {e!s}&#34;
            logger.error(error_msg)
            return None, [error_msg]
        except Exception as e:
            error_msg = f&#34;Unexpected error during YAML parsing: {e!s}&#34;
            logger.error(error_msg)
            return None, [error_msg]

    def _format_pydantic_errors(self, validation_error: ValidationError) -&gt; list[str]:
        &#34;&#34;&#34;Format Pydantic validation errors into helpful messages.

        Pydantic errors can be complex. This method extracts the key information
        and formats it in a user-friendly way.

        Args:
            validation_error: Pydantic ValidationError to format.

        Returns:
            List of formatted error messages.
        &#34;&#34;&#34;
        errors = []
        for error in validation_error.errors():
            loc = &#34; -&gt; &#34;.join(str(x) for x in error[&#34;loc&#34;])
            msg = error[&#34;msg&#34;]
            error_type = error[&#34;type&#34;]

            # Create a detailed error message
            ctx_dict = error.get(&#34;ctx&#34;)
            if ctx_dict:
                ctx = &#34;, &#34;.join(f&#34;{k}={v}&#34; for k, v in ctx_dict.items())
            ctx_dict = error.get(&#34;ctx&#34;)
            if ctx_dict:
                ctx = &#34;, &#34;.join(f&#34;{k}={v}&#34; for k, v in ctx_dict.items())
                error_msg = f&#34;Field &#39;{loc}&#39;: {msg} (type={error_type}, {ctx})&#34;
            else:
                error_msg = f&#34;Field &#39;{loc}&#39;: {msg} (type={error_type})&#34;

            errors.append(error_msg)

        return errors

    def validate_plot(self, raw_output: str) -&gt; ValidationResult:
        &#34;&#34;&#34;Parse and validate plot outline YAML against PlotOutline schema.

        Args:
            raw_output: Raw YAML string containing plot outline data.

        Returns:
            ValidationResult with validation status, parsed data if valid,
            and error messages if invalid.

        Example:
            &gt;&gt;&gt; validator = OutputValidator()
            &gt;&gt;&gt; yaml_str = &#39;&#39;&#39;
            ... title: &#34;Test Plot&#34;
            ... setting: &#34;A dark and atmospheric setting with lots of detail...&#34;
            ... themes: [&#34;survival&#34;, &#34;horror&#34;]
            ... tone: &#34;Dark and gritty atmosphere&#34;
            ... plot_points: [...]
            ... characters: [...]
            ... conflicts: [...]
            ... &#39;&#39;&#39;
            &gt;&gt;&gt; result = validator.validate_plot(yaml_str)
            &gt;&gt;&gt; if result.valid:
            ...     print(f&#34;Valid plot: {result.data.title}&#34;)
        &#34;&#34;&#34;
        logger.info(&#34;Validating plot outline&#34;)

        # Parse YAML
        data, parse_errors = self._parse_yaml(raw_output)
        if parse_errors:
            return ValidationResult(valid=False, data=None, errors=parse_errors)

        # Type guard: data is guaranteed to be dict here since parse_errors is empty
        assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

        # Validate against schema
        try:
            plot = PlotOutline(**data)
            logger.info(f&#34;Plot outline validation successful: {plot.title}&#34;)
            return ValidationResult(valid=True, data=plot, errors=[])

        except ValidationError as e:
            errors = self._format_pydantic_errors(e)
            logger.error(f&#34;Plot outline validation failed: {len(errors)} errors&#34;)
            return ValidationResult(valid=False, data=None, errors=errors)

        except Exception as e:
            error_msg = f&#34;Unexpected error during plot outline validation: {e!s}&#34;
            logger.error(error_msg)
            return ValidationResult(valid=False, data=None, errors=[error_msg])

    def validate_narrative_map(self, raw_output: str) -&gt; ValidationResult:
        &#34;&#34;&#34;Parse and validate narrative map YAML against NarrativeMap schema.

        Args:
            raw_output: Raw YAML string containing narrative map data.

        Returns:
            ValidationResult with validation status, parsed data if valid,
            and error messages if invalid.

        Example:
            &gt;&gt;&gt; validator = OutputValidator()
            &gt;&gt;&gt; yaml_str = &#39;&#39;&#39;
            ... start_scene: &#34;scene_1&#34;
            ... scenes:
            ...   scene_1:
            ...     name: &#34;Opening Scene&#34;
            ...     description: &#34;A detailed description of the opening scene...&#34;
            ...     connections: []
            ... &#39;&#39;&#39;
            &gt;&gt;&gt; result = validator.validate_narrative_map(yaml_str)
            &gt;&gt;&gt; if result.valid:
            ...     print(f&#34;Valid map: {len(result.data.scenes)} scenes&#34;)
        &#34;&#34;&#34;
        logger.info(&#34;Validating narrative map&#34;)

        # Parse YAML
        data, parse_errors = self._parse_yaml(raw_output)
        if parse_errors:
            return ValidationResult(valid=False, data=None, errors=parse_errors)

        # Type guard: data is guaranteed to be dict here since parse_errors is empty
        assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

        # Validate against schema
        try:
            narrative_map = NarrativeMap(**data)
            logger.info(f&#34;Narrative map validation successful: {len(narrative_map.scenes)} scenes&#34;)
            return ValidationResult(valid=True, data=narrative_map, errors=[])

        except ValidationError as e:
            errors = self._format_pydantic_errors(e)
            logger.error(f&#34;Narrative map validation failed: {len(errors)} errors&#34;)
            return ValidationResult(valid=False, data=None, errors=errors)

        except Exception as e:
            error_msg = f&#34;Unexpected error during narrative map validation: {e!s}&#34;
            logger.error(error_msg)
            return ValidationResult(valid=False, data=None, errors=[error_msg])

    def validate_puzzle_design(self, raw_output: str) -&gt; ValidationResult:
        &#34;&#34;&#34;Parse and validate puzzle design YAML against PuzzleDesign schema.

        Args:
            raw_output: Raw YAML string containing puzzle design data.

        Returns:
            ValidationResult with validation status, parsed data if valid,
            and error messages if invalid.

        Example:
            &gt;&gt;&gt; validator = OutputValidator()
            &gt;&gt;&gt; yaml_str = &#39;&#39;&#39;
            ... puzzles: [...]
            ... artifacts: [...]
            ... monsters: [...]
            ... npcs: [...]
            ... &#39;&#39;&#39;
            &gt;&gt;&gt; result = validator.validate_puzzle_design(yaml_str)
            &gt;&gt;&gt; if result.valid:
            ...     print(f&#34;Valid design: {len(result.data.puzzles)} puzzles&#34;)
        &#34;&#34;&#34;
        logger.info(&#34;Validating puzzle design&#34;)

        # Parse YAML
        data, parse_errors = self._parse_yaml(raw_output)
        if parse_errors:
            return ValidationResult(valid=False, data=None, errors=parse_errors)

        # Type guard: data is guaranteed to be dict here since parse_errors is empty
        assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

        # Validate against schema
        try:
            puzzle_design = PuzzleDesign(**data)
            logger.info(
                f&#34;Puzzle design validation successful: {len(puzzle_design.puzzles)} puzzles&#34;
            )
            return ValidationResult(valid=True, data=puzzle_design, errors=[])

        except ValidationError as e:
            errors = self._format_pydantic_errors(e)
            logger.error(f&#34;Puzzle design validation failed: {len(errors)} errors&#34;)
            return ValidationResult(valid=False, data=None, errors=errors)

        except Exception as e:
            error_msg = f&#34;Unexpected error during puzzle design validation: {e!s}&#34;
            logger.error(error_msg)
            return ValidationResult(valid=False, data=None, errors=[error_msg])

    def validate_scene_texts(self, raw_output: str) -&gt; ValidationResult:
        &#34;&#34;&#34;Parse and validate scene texts YAML against SceneTexts schema.

        Args:
            raw_output: Raw YAML string containing scene texts data.

        Returns:
            ValidationResult with validation status, parsed data if valid,
            and error messages if invalid.

        Example:
            &gt;&gt;&gt; validator = OutputValidator()
            &gt;&gt;&gt; yaml_str = &#39;&#39;&#39;
            ... scenes:
            ...   scene_1:
            ...     name: &#34;Scene 1&#34;
            ...     description: &#34;A very detailed description of what happens in this scene...&#34;
            ...     atmosphere: &#34;Dark and foreboding atmosphere&#34;
            ...     initial_text: &#34;You enter the dark corridor...&#34;
            ...     examination_texts: {}
            ...     dialogue: []
            ... &#39;&#39;&#39;
            &gt;&gt;&gt; result = validator.validate_scene_texts(yaml_str)
            &gt;&gt;&gt; if result.valid:
            ...     print(f&#34;Valid texts: {len(result.data.scenes)} scenes&#34;)
        &#34;&#34;&#34;
        logger.info(&#34;Validating scene texts&#34;)

        # Parse YAML
        data, parse_errors = self._parse_yaml(raw_output)
        if parse_errors:
            return ValidationResult(valid=False, data=None, errors=parse_errors)

        # Type guard: data is guaranteed to be dict here since parse_errors is empty
        assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

        # Validate against schema
        try:
            scene_texts = SceneTexts(**data)
            logger.info(f&#34;Scene texts validation successful: {len(scene_texts.scenes)} scenes&#34;)
            return ValidationResult(valid=True, data=scene_texts, errors=[])

        except ValidationError as e:
            errors = self._format_pydantic_errors(e)
            logger.error(f&#34;Scene texts validation failed: {len(errors)} errors&#34;)
            return ValidationResult(valid=False, data=None, errors=errors)

        except Exception as e:
            error_msg = f&#34;Unexpected error during scene texts validation: {e!s}&#34;
            logger.error(error_msg)
            return ValidationResult(valid=False, data=None, errors=[error_msg])

    def validate_game_mechanics(self, raw_output: str) -&gt; ValidationResult:
        &#34;&#34;&#34;Parse and validate game mechanics YAML against GameMechanics schema.

        Args:
            raw_output: Raw YAML string containing game mechanics data.

        Returns:
            ValidationResult with validation status, parsed data if valid,
            and error messages if invalid.

        Example:
            &gt;&gt;&gt; validator = OutputValidator()
            &gt;&gt;&gt; yaml_str = &#39;&#39;&#39;
            ... game_title: &#34;Test Game&#34;
            ... game_systems:
            ...   movement: {...}
            ...   inventory: {...}
            ...   combat: {...}
            ...   interaction: {...}
            ... game_state: {...}
            ... technical_requirements: [...]
            ... &#39;&#39;&#39;
            &gt;&gt;&gt; result = validator.validate_game_mechanics(yaml_str)
            &gt;&gt;&gt; if result.valid:
            ...     print(f&#34;Valid mechanics: {result.data.game_title}&#34;)
        &#34;&#34;&#34;
        logger.info(&#34;Validating game mechanics&#34;)

        # Parse YAML
        data, parse_errors = self._parse_yaml(raw_output)
        if parse_errors:
            return ValidationResult(valid=False, data=None, errors=parse_errors)

        # Type guard: data is guaranteed to be dict here since parse_errors is empty
        assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

        # Validate against schema
        try:
            game_mechanics = GameMechanics(**data)
            logger.info(f&#34;Game mechanics validation successful: {game_mechanics.game_title}&#34;)
            return ValidationResult(valid=True, data=game_mechanics, errors=[])

        except ValidationError as e:
            errors = self._format_pydantic_errors(e)
            logger.error(f&#34;Game mechanics validation failed: {len(errors)} errors&#34;)
            return ValidationResult(valid=False, data=None, errors=errors)

        except Exception as e:
            error_msg = f&#34;Unexpected error during game mechanics validation: {e!s}&#34;
            logger.error(error_msg)
            return ValidationResult(valid=False, data=None, errors=[error_msg])</code></pre>
</details>
<div class="desc"><p>Validator for YAML outputs against Pydantic schemas.</p>
<p>This class provides methods to parse and validate YAML strings
against specific Pydantic schemas for different game design outputs.</p>
<h2 id="features">Features</h2>
<ul>
<li>Handles markdown-wrapped YAML (common in AI outputs)</li>
<li>Provides detailed, helpful error messages</li>
<li>Validates against all schema constraints</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; validator = OutputValidator()
&gt;&gt;&gt; result = validator.validate_plot(yaml_string)
&gt;&gt;&gt; if result.valid:
...     print(f&quot;Valid plot: {result.data.title}&quot;)
... else:
...     for error in result.errors:
...         print(f&quot;Error: {error}&quot;)
</code></pre>
<p>Initialize the output validator.</p></div>
<h3>Methods</h3>
<dl>
<dt id="space_hulk_game.validation.OutputValidator.validate_game_mechanics"><code class="name flex">
<span>def <span class="ident">validate_game_mechanics</span></span>(<span>self, raw_output: str) ‑> <a title="space_hulk_game.validation.validator.ValidationResult" href="validator.html#space_hulk_game.validation.validator.ValidationResult">ValidationResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_game_mechanics(self, raw_output: str) -&gt; ValidationResult:
    &#34;&#34;&#34;Parse and validate game mechanics YAML against GameMechanics schema.

    Args:
        raw_output: Raw YAML string containing game mechanics data.

    Returns:
        ValidationResult with validation status, parsed data if valid,
        and error messages if invalid.

    Example:
        &gt;&gt;&gt; validator = OutputValidator()
        &gt;&gt;&gt; yaml_str = &#39;&#39;&#39;
        ... game_title: &#34;Test Game&#34;
        ... game_systems:
        ...   movement: {...}
        ...   inventory: {...}
        ...   combat: {...}
        ...   interaction: {...}
        ... game_state: {...}
        ... technical_requirements: [...]
        ... &#39;&#39;&#39;
        &gt;&gt;&gt; result = validator.validate_game_mechanics(yaml_str)
        &gt;&gt;&gt; if result.valid:
        ...     print(f&#34;Valid mechanics: {result.data.game_title}&#34;)
    &#34;&#34;&#34;
    logger.info(&#34;Validating game mechanics&#34;)

    # Parse YAML
    data, parse_errors = self._parse_yaml(raw_output)
    if parse_errors:
        return ValidationResult(valid=False, data=None, errors=parse_errors)

    # Type guard: data is guaranteed to be dict here since parse_errors is empty
    assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

    # Validate against schema
    try:
        game_mechanics = GameMechanics(**data)
        logger.info(f&#34;Game mechanics validation successful: {game_mechanics.game_title}&#34;)
        return ValidationResult(valid=True, data=game_mechanics, errors=[])

    except ValidationError as e:
        errors = self._format_pydantic_errors(e)
        logger.error(f&#34;Game mechanics validation failed: {len(errors)} errors&#34;)
        return ValidationResult(valid=False, data=None, errors=errors)

    except Exception as e:
        error_msg = f&#34;Unexpected error during game mechanics validation: {e!s}&#34;
        logger.error(error_msg)
        return ValidationResult(valid=False, data=None, errors=[error_msg])</code></pre>
</details>
<div class="desc"><p>Parse and validate game mechanics YAML against GameMechanics schema.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_output</code></strong></dt>
<dd>Raw YAML string containing game mechanics data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ValidationResult with validation status, parsed data if valid,
and error messages if invalid.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; validator = OutputValidator()
&gt;&gt;&gt; yaml_str = '''
... game_title: &quot;Test Game&quot;
... game_systems:
...   movement: {...}
...   inventory: {...}
...   combat: {...}
...   interaction: {...}
... game_state: {...}
... technical_requirements: [...]
... '''
&gt;&gt;&gt; result = validator.validate_game_mechanics(yaml_str)
&gt;&gt;&gt; if result.valid:
...     print(f&quot;Valid mechanics: {result.data.game_title}&quot;)
</code></pre></div>
</dd>
<dt id="space_hulk_game.validation.OutputValidator.validate_narrative_map"><code class="name flex">
<span>def <span class="ident">validate_narrative_map</span></span>(<span>self, raw_output: str) ‑> <a title="space_hulk_game.validation.validator.ValidationResult" href="validator.html#space_hulk_game.validation.validator.ValidationResult">ValidationResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_narrative_map(self, raw_output: str) -&gt; ValidationResult:
    &#34;&#34;&#34;Parse and validate narrative map YAML against NarrativeMap schema.

    Args:
        raw_output: Raw YAML string containing narrative map data.

    Returns:
        ValidationResult with validation status, parsed data if valid,
        and error messages if invalid.

    Example:
        &gt;&gt;&gt; validator = OutputValidator()
        &gt;&gt;&gt; yaml_str = &#39;&#39;&#39;
        ... start_scene: &#34;scene_1&#34;
        ... scenes:
        ...   scene_1:
        ...     name: &#34;Opening Scene&#34;
        ...     description: &#34;A detailed description of the opening scene...&#34;
        ...     connections: []
        ... &#39;&#39;&#39;
        &gt;&gt;&gt; result = validator.validate_narrative_map(yaml_str)
        &gt;&gt;&gt; if result.valid:
        ...     print(f&#34;Valid map: {len(result.data.scenes)} scenes&#34;)
    &#34;&#34;&#34;
    logger.info(&#34;Validating narrative map&#34;)

    # Parse YAML
    data, parse_errors = self._parse_yaml(raw_output)
    if parse_errors:
        return ValidationResult(valid=False, data=None, errors=parse_errors)

    # Type guard: data is guaranteed to be dict here since parse_errors is empty
    assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

    # Validate against schema
    try:
        narrative_map = NarrativeMap(**data)
        logger.info(f&#34;Narrative map validation successful: {len(narrative_map.scenes)} scenes&#34;)
        return ValidationResult(valid=True, data=narrative_map, errors=[])

    except ValidationError as e:
        errors = self._format_pydantic_errors(e)
        logger.error(f&#34;Narrative map validation failed: {len(errors)} errors&#34;)
        return ValidationResult(valid=False, data=None, errors=errors)

    except Exception as e:
        error_msg = f&#34;Unexpected error during narrative map validation: {e!s}&#34;
        logger.error(error_msg)
        return ValidationResult(valid=False, data=None, errors=[error_msg])</code></pre>
</details>
<div class="desc"><p>Parse and validate narrative map YAML against NarrativeMap schema.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_output</code></strong></dt>
<dd>Raw YAML string containing narrative map data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ValidationResult with validation status, parsed data if valid,
and error messages if invalid.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; validator = OutputValidator()
&gt;&gt;&gt; yaml_str = '''
... start_scene: &quot;scene_1&quot;
... scenes:
...   scene_1:
...     name: &quot;Opening Scene&quot;
...     description: &quot;A detailed description of the opening scene...&quot;
...     connections: []
... '''
&gt;&gt;&gt; result = validator.validate_narrative_map(yaml_str)
&gt;&gt;&gt; if result.valid:
...     print(f&quot;Valid map: {len(result.data.scenes)} scenes&quot;)
</code></pre></div>
</dd>
<dt id="space_hulk_game.validation.OutputValidator.validate_plot"><code class="name flex">
<span>def <span class="ident">validate_plot</span></span>(<span>self, raw_output: str) ‑> <a title="space_hulk_game.validation.validator.ValidationResult" href="validator.html#space_hulk_game.validation.validator.ValidationResult">ValidationResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_plot(self, raw_output: str) -&gt; ValidationResult:
    &#34;&#34;&#34;Parse and validate plot outline YAML against PlotOutline schema.

    Args:
        raw_output: Raw YAML string containing plot outline data.

    Returns:
        ValidationResult with validation status, parsed data if valid,
        and error messages if invalid.

    Example:
        &gt;&gt;&gt; validator = OutputValidator()
        &gt;&gt;&gt; yaml_str = &#39;&#39;&#39;
        ... title: &#34;Test Plot&#34;
        ... setting: &#34;A dark and atmospheric setting with lots of detail...&#34;
        ... themes: [&#34;survival&#34;, &#34;horror&#34;]
        ... tone: &#34;Dark and gritty atmosphere&#34;
        ... plot_points: [...]
        ... characters: [...]
        ... conflicts: [...]
        ... &#39;&#39;&#39;
        &gt;&gt;&gt; result = validator.validate_plot(yaml_str)
        &gt;&gt;&gt; if result.valid:
        ...     print(f&#34;Valid plot: {result.data.title}&#34;)
    &#34;&#34;&#34;
    logger.info(&#34;Validating plot outline&#34;)

    # Parse YAML
    data, parse_errors = self._parse_yaml(raw_output)
    if parse_errors:
        return ValidationResult(valid=False, data=None, errors=parse_errors)

    # Type guard: data is guaranteed to be dict here since parse_errors is empty
    assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

    # Validate against schema
    try:
        plot = PlotOutline(**data)
        logger.info(f&#34;Plot outline validation successful: {plot.title}&#34;)
        return ValidationResult(valid=True, data=plot, errors=[])

    except ValidationError as e:
        errors = self._format_pydantic_errors(e)
        logger.error(f&#34;Plot outline validation failed: {len(errors)} errors&#34;)
        return ValidationResult(valid=False, data=None, errors=errors)

    except Exception as e:
        error_msg = f&#34;Unexpected error during plot outline validation: {e!s}&#34;
        logger.error(error_msg)
        return ValidationResult(valid=False, data=None, errors=[error_msg])</code></pre>
</details>
<div class="desc"><p>Parse and validate plot outline YAML against PlotOutline schema.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_output</code></strong></dt>
<dd>Raw YAML string containing plot outline data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ValidationResult with validation status, parsed data if valid,
and error messages if invalid.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; validator = OutputValidator()
&gt;&gt;&gt; yaml_str = '''
... title: &quot;Test Plot&quot;
... setting: &quot;A dark and atmospheric setting with lots of detail...&quot;
... themes: [&quot;survival&quot;, &quot;horror&quot;]
... tone: &quot;Dark and gritty atmosphere&quot;
... plot_points: [...]
... characters: [...]
... conflicts: [...]
... '''
&gt;&gt;&gt; result = validator.validate_plot(yaml_str)
&gt;&gt;&gt; if result.valid:
...     print(f&quot;Valid plot: {result.data.title}&quot;)
</code></pre></div>
</dd>
<dt id="space_hulk_game.validation.OutputValidator.validate_puzzle_design"><code class="name flex">
<span>def <span class="ident">validate_puzzle_design</span></span>(<span>self, raw_output: str) ‑> <a title="space_hulk_game.validation.validator.ValidationResult" href="validator.html#space_hulk_game.validation.validator.ValidationResult">ValidationResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_puzzle_design(self, raw_output: str) -&gt; ValidationResult:
    &#34;&#34;&#34;Parse and validate puzzle design YAML against PuzzleDesign schema.

    Args:
        raw_output: Raw YAML string containing puzzle design data.

    Returns:
        ValidationResult with validation status, parsed data if valid,
        and error messages if invalid.

    Example:
        &gt;&gt;&gt; validator = OutputValidator()
        &gt;&gt;&gt; yaml_str = &#39;&#39;&#39;
        ... puzzles: [...]
        ... artifacts: [...]
        ... monsters: [...]
        ... npcs: [...]
        ... &#39;&#39;&#39;
        &gt;&gt;&gt; result = validator.validate_puzzle_design(yaml_str)
        &gt;&gt;&gt; if result.valid:
        ...     print(f&#34;Valid design: {len(result.data.puzzles)} puzzles&#34;)
    &#34;&#34;&#34;
    logger.info(&#34;Validating puzzle design&#34;)

    # Parse YAML
    data, parse_errors = self._parse_yaml(raw_output)
    if parse_errors:
        return ValidationResult(valid=False, data=None, errors=parse_errors)

    # Type guard: data is guaranteed to be dict here since parse_errors is empty
    assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

    # Validate against schema
    try:
        puzzle_design = PuzzleDesign(**data)
        logger.info(
            f&#34;Puzzle design validation successful: {len(puzzle_design.puzzles)} puzzles&#34;
        )
        return ValidationResult(valid=True, data=puzzle_design, errors=[])

    except ValidationError as e:
        errors = self._format_pydantic_errors(e)
        logger.error(f&#34;Puzzle design validation failed: {len(errors)} errors&#34;)
        return ValidationResult(valid=False, data=None, errors=errors)

    except Exception as e:
        error_msg = f&#34;Unexpected error during puzzle design validation: {e!s}&#34;
        logger.error(error_msg)
        return ValidationResult(valid=False, data=None, errors=[error_msg])</code></pre>
</details>
<div class="desc"><p>Parse and validate puzzle design YAML against PuzzleDesign schema.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_output</code></strong></dt>
<dd>Raw YAML string containing puzzle design data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ValidationResult with validation status, parsed data if valid,
and error messages if invalid.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; validator = OutputValidator()
&gt;&gt;&gt; yaml_str = '''
... puzzles: [...]
... artifacts: [...]
... monsters: [...]
... npcs: [...]
... '''
&gt;&gt;&gt; result = validator.validate_puzzle_design(yaml_str)
&gt;&gt;&gt; if result.valid:
...     print(f&quot;Valid design: {len(result.data.puzzles)} puzzles&quot;)
</code></pre></div>
</dd>
<dt id="space_hulk_game.validation.OutputValidator.validate_scene_texts"><code class="name flex">
<span>def <span class="ident">validate_scene_texts</span></span>(<span>self, raw_output: str) ‑> <a title="space_hulk_game.validation.validator.ValidationResult" href="validator.html#space_hulk_game.validation.validator.ValidationResult">ValidationResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_scene_texts(self, raw_output: str) -&gt; ValidationResult:
    &#34;&#34;&#34;Parse and validate scene texts YAML against SceneTexts schema.

    Args:
        raw_output: Raw YAML string containing scene texts data.

    Returns:
        ValidationResult with validation status, parsed data if valid,
        and error messages if invalid.

    Example:
        &gt;&gt;&gt; validator = OutputValidator()
        &gt;&gt;&gt; yaml_str = &#39;&#39;&#39;
        ... scenes:
        ...   scene_1:
        ...     name: &#34;Scene 1&#34;
        ...     description: &#34;A very detailed description of what happens in this scene...&#34;
        ...     atmosphere: &#34;Dark and foreboding atmosphere&#34;
        ...     initial_text: &#34;You enter the dark corridor...&#34;
        ...     examination_texts: {}
        ...     dialogue: []
        ... &#39;&#39;&#39;
        &gt;&gt;&gt; result = validator.validate_scene_texts(yaml_str)
        &gt;&gt;&gt; if result.valid:
        ...     print(f&#34;Valid texts: {len(result.data.scenes)} scenes&#34;)
    &#34;&#34;&#34;
    logger.info(&#34;Validating scene texts&#34;)

    # Parse YAML
    data, parse_errors = self._parse_yaml(raw_output)
    if parse_errors:
        return ValidationResult(valid=False, data=None, errors=parse_errors)

    # Type guard: data is guaranteed to be dict here since parse_errors is empty
    assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

    # Validate against schema
    try:
        scene_texts = SceneTexts(**data)
        logger.info(f&#34;Scene texts validation successful: {len(scene_texts.scenes)} scenes&#34;)
        return ValidationResult(valid=True, data=scene_texts, errors=[])

    except ValidationError as e:
        errors = self._format_pydantic_errors(e)
        logger.error(f&#34;Scene texts validation failed: {len(errors)} errors&#34;)
        return ValidationResult(valid=False, data=None, errors=errors)

    except Exception as e:
        error_msg = f&#34;Unexpected error during scene texts validation: {e!s}&#34;
        logger.error(error_msg)
        return ValidationResult(valid=False, data=None, errors=[error_msg])</code></pre>
</details>
<div class="desc"><p>Parse and validate scene texts YAML against SceneTexts schema.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_output</code></strong></dt>
<dd>Raw YAML string containing scene texts data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ValidationResult with validation status, parsed data if valid,
and error messages if invalid.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; validator = OutputValidator()
&gt;&gt;&gt; yaml_str = '''
... scenes:
...   scene_1:
...     name: &quot;Scene 1&quot;
...     description: &quot;A very detailed description of what happens in this scene...&quot;
...     atmosphere: &quot;Dark and foreboding atmosphere&quot;
...     initial_text: &quot;You enter the dark corridor...&quot;
...     examination_texts: {}
...     dialogue: []
... '''
&gt;&gt;&gt; result = validator.validate_scene_texts(yaml_str)
&gt;&gt;&gt; if result.valid:
...     print(f&quot;Valid texts: {len(result.data.scenes)} scenes&quot;)
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.validation.ProcessingResult"><code class="flex name class">
<span>class <span class="ident">ProcessingResult</span></span>
<span>(</span><span>success: bool,<br>data: typing.Any | None = None,<br>errors: list[str] = &lt;factory&gt;,<br>warnings: list[str] = &lt;factory&gt;,<br>corrections: list[str] = &lt;factory&gt;,<br>metadata: dict[str, typing.Any] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ProcessingResult:
    &#34;&#34;&#34;Unified result type for YAML processing operations.

    This replaces ValidationResult, CorrectionResult, and parts of QualityScore
    to provide consistent error/warning/info reporting across all processing layers.

    Attributes:
        success: Whether the operation succeeded
        data: The processed data (if successful)
        errors: List of error messages (failures)
        warnings: List of warning messages (non-critical issues)
        corrections: List of corrections applied
        metadata: Additional context (e.g., score for quality checks)

    Examples:
        &gt;&gt;&gt; result = ProcessingResult(
        ...     success=True,
        ...     data={&#39;title&#39;: &#39;Game&#39;},
        ...     errors=[],
        ...     warnings=[&#39;Missing optional field&#39;],
        ...     corrections=[&#39;Added default value&#39;],
        ...     metadata={&#39;score&#39;: 8.5}
        ... )
        &gt;&gt;&gt; result.is_valid
        True
    &#34;&#34;&#34;

    success: bool
    data: Any | None = None
    errors: list[str] = field(default_factory=list)
    warnings: list[str] = field(default_factory=list)
    corrections: list[str] = field(default_factory=list)
    metadata: dict[str, Any] = field(default_factory=dict)

    @property
    def is_valid(self) -&gt; bool:
        &#34;&#34;&#34;Check if result is valid (successful and no errors).&#34;&#34;&#34;
        return self.success and not self.errors

    @property
    def has_issues(self) -&gt; bool:
        &#34;&#34;&#34;Check if result has any issues (errors or warnings).&#34;&#34;&#34;
        return bool(self.errors or self.warnings)

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;String representation of result.&#34;&#34;&#34;
        status = &#34;SUCCESS&#34; if self.success else &#34;FAILED&#34;
        parts = [f&#34;ProcessingResult({status})&#34;]

        if self.errors:
            parts.append(f&#34;{len(self.errors)} errors&#34;)
        if self.warnings:
            parts.append(f&#34;{len(self.warnings)} warnings&#34;)
        if self.corrections:
            parts.append(f&#34;{len(self.corrections)} corrections&#34;)

        return &#34; - &#34;.join(parts)</code></pre>
</details>
<div class="desc"><p>Unified result type for YAML processing operations.</p>
<p>This replaces ValidationResult, CorrectionResult, and parts of QualityScore
to provide consistent error/warning/info reporting across all processing layers.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>success</code></strong></dt>
<dd>Whether the operation succeeded</dd>
<dt><strong><code>data</code></strong></dt>
<dd>The processed data (if successful)</dd>
<dt><strong><code>errors</code></strong></dt>
<dd>List of error messages (failures)</dd>
<dt><strong><code>warnings</code></strong></dt>
<dd>List of warning messages (non-critical issues)</dd>
<dt><strong><code>corrections</code></strong></dt>
<dd>List of corrections applied</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Additional context (e.g., score for quality checks)</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; result = ProcessingResult(
...     success=True,
...     data={'title': 'Game'},
...     errors=[],
...     warnings=['Missing optional field'],
...     corrections=['Added default value'],
...     metadata={'score': 8.5}
... )
&gt;&gt;&gt; result.is_valid
True
</code></pre></div>
<h3>Instance variables</h3>
<dl>
<dt id="space_hulk_game.validation.ProcessingResult.corrections"><code class="name">var <span class="ident">corrections</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.validation.ProcessingResult.data"><code class="name">var <span class="ident">data</span> : typing.Any | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.validation.ProcessingResult.errors"><code class="name">var <span class="ident">errors</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.validation.ProcessingResult.has_issues"><code class="name">prop <span class="ident">has_issues</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def has_issues(self) -&gt; bool:
    &#34;&#34;&#34;Check if result has any issues (errors or warnings).&#34;&#34;&#34;
    return bool(self.errors or self.warnings)</code></pre>
</details>
<div class="desc"><p>Check if result has any issues (errors or warnings).</p></div>
</dd>
<dt id="space_hulk_game.validation.ProcessingResult.is_valid"><code class="name">prop <span class="ident">is_valid</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_valid(self) -&gt; bool:
    &#34;&#34;&#34;Check if result is valid (successful and no errors).&#34;&#34;&#34;
    return self.success and not self.errors</code></pre>
</details>
<div class="desc"><p>Check if result is valid (successful and no errors).</p></div>
</dd>
<dt id="space_hulk_game.validation.ProcessingResult.metadata"><code class="name">var <span class="ident">metadata</span> : dict[str, typing.Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.validation.ProcessingResult.success"><code class="name">var <span class="ident">success</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.validation.ProcessingResult.warnings"><code class="name">var <span class="ident">warnings</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.validation.ProcessingResult"><code class="flex name class">
<span>class <span class="ident">ProcessingResult</span></span>
<span>(</span><span>success: bool,<br>data: typing.Any | None = None,<br>errors: list[str] = &lt;factory&gt;,<br>warnings: list[str] = &lt;factory&gt;,<br>corrections: list[str] = &lt;factory&gt;,<br>metadata: dict[str, typing.Any] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ProcessingResult:
    &#34;&#34;&#34;Unified result type for YAML processing operations.

    This replaces ValidationResult, CorrectionResult, and parts of QualityScore
    to provide consistent error/warning/info reporting across all processing layers.

    Attributes:
        success: Whether the operation succeeded
        data: The processed data (if successful)
        errors: List of error messages (failures)
        warnings: List of warning messages (non-critical issues)
        corrections: List of corrections applied
        metadata: Additional context (e.g., score for quality checks)

    Examples:
        &gt;&gt;&gt; result = ProcessingResult(
        ...     success=True,
        ...     data={&#39;title&#39;: &#39;Game&#39;},
        ...     errors=[],
        ...     warnings=[&#39;Missing optional field&#39;],
        ...     corrections=[&#39;Added default value&#39;],
        ...     metadata={&#39;score&#39;: 8.5}
        ... )
        &gt;&gt;&gt; result.is_valid
        True
    &#34;&#34;&#34;

    success: bool
    data: Any | None = None
    errors: list[str] = field(default_factory=list)
    warnings: list[str] = field(default_factory=list)
    corrections: list[str] = field(default_factory=list)
    metadata: dict[str, Any] = field(default_factory=dict)

    @property
    def is_valid(self) -&gt; bool:
        &#34;&#34;&#34;Check if result is valid (successful and no errors).&#34;&#34;&#34;
        return self.success and not self.errors

    @property
    def has_issues(self) -&gt; bool:
        &#34;&#34;&#34;Check if result has any issues (errors or warnings).&#34;&#34;&#34;
        return bool(self.errors or self.warnings)

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;String representation of result.&#34;&#34;&#34;
        status = &#34;SUCCESS&#34; if self.success else &#34;FAILED&#34;
        parts = [f&#34;ProcessingResult({status})&#34;]

        if self.errors:
            parts.append(f&#34;{len(self.errors)} errors&#34;)
        if self.warnings:
            parts.append(f&#34;{len(self.warnings)} warnings&#34;)
        if self.corrections:
            parts.append(f&#34;{len(self.corrections)} corrections&#34;)

        return &#34; - &#34;.join(parts)</code></pre>
</details>
<div class="desc"><p>Unified result type for YAML processing operations.</p>
<p>This replaces ValidationResult, CorrectionResult, and parts of QualityScore
to provide consistent error/warning/info reporting across all processing layers.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>success</code></strong></dt>
<dd>Whether the operation succeeded</dd>
<dt><strong><code>data</code></strong></dt>
<dd>The processed data (if successful)</dd>
<dt><strong><code>errors</code></strong></dt>
<dd>List of error messages (failures)</dd>
<dt><strong><code>warnings</code></strong></dt>
<dd>List of warning messages (non-critical issues)</dd>
<dt><strong><code>corrections</code></strong></dt>
<dd>List of corrections applied</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Additional context (e.g., score for quality checks)</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; result = ProcessingResult(
...     success=True,
...     data={'title': 'Game'},
...     errors=[],
...     warnings=['Missing optional field'],
...     corrections=['Added default value'],
...     metadata={'score': 8.5}
... )
&gt;&gt;&gt; result.is_valid
True
</code></pre></div>
<h3>Instance variables</h3>
<dl>
<dt id="space_hulk_game.validation.ProcessingResult.corrections"><code class="name">var <span class="ident">corrections</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.validation.ProcessingResult.data"><code class="name">var <span class="ident">data</span> : typing.Any | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.validation.ProcessingResult.errors"><code class="name">var <span class="ident">errors</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.validation.ProcessingResult.has_issues"><code class="name">prop <span class="ident">has_issues</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def has_issues(self) -&gt; bool:
    &#34;&#34;&#34;Check if result has any issues (errors or warnings).&#34;&#34;&#34;
    return bool(self.errors or self.warnings)</code></pre>
</details>
<div class="desc"><p>Check if result has any issues (errors or warnings).</p></div>
</dd>
<dt id="space_hulk_game.validation.ProcessingResult.is_valid"><code class="name">prop <span class="ident">is_valid</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_valid(self) -&gt; bool:
    &#34;&#34;&#34;Check if result is valid (successful and no errors).&#34;&#34;&#34;
    return self.success and not self.errors</code></pre>
</details>
<div class="desc"><p>Check if result is valid (successful and no errors).</p></div>
</dd>
<dt id="space_hulk_game.validation.ProcessingResult.metadata"><code class="name">var <span class="ident">metadata</span> : dict[str, typing.Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.validation.ProcessingResult.success"><code class="name">var <span class="ident">success</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.validation.ProcessingResult.warnings"><code class="name">var <span class="ident">warnings</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.validation.ValidationResult"><code class="flex name class">
<span>class <span class="ident">ValidationResult</span></span>
<span>(</span><span>valid: bool,<br>data: Any | None,<br>errors: list[str],<br>warnings: list[str] = &lt;factory&gt;)</span>
<span>(</span><span>valid: bool,<br>data: Any | None,<br>errors: list[str],<br>warnings: list[str] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ValidationResult:
    &#34;&#34;&#34;Result of validating YAML output against a schema.

    NOTE: ValidationResult is kept for backward compatibility.
    New code should use ProcessingResult from validation.types

    NOTE: ValidationResult is kept for backward compatibility.
    New code should use ProcessingResult from validation.types

    Attributes:
        valid: Whether the validation succeeded.
        data: Parsed Pydantic model if validation succeeded, None otherwise.
        errors: List of error messages if validation failed, empty list otherwise.
        warnings: List of warning messages (non-critical issues).
        warnings: List of warning messages (non-critical issues).

    Example:
        &gt;&gt;&gt; result = ValidationResult(valid=True, data=plot_outline, errors=[])
        &gt;&gt;&gt; if result.valid:
        ...     print(f&#34;Validation succeeded: {result.data.title}&#34;)
        ... else:
        ...     print(f&#34;Errors: {result.errors}&#34;)
    &#34;&#34;&#34;

    valid: bool
    data: Any | None
    errors: list[str]
    warnings: list[str] = field(default_factory=list)

    def to_processing_result(self) -&gt; ProcessingResult:
        &#34;&#34;&#34;Convert to unified ProcessingResult type.

        Returns:
            ProcessingResult instance with equivalent data.

        Example:
            &gt;&gt;&gt; result = ValidationResult(valid=True, data=plot, errors=[])
            &gt;&gt;&gt; processing_result = result.to_processing_result()
            &gt;&gt;&gt; processing_result.is_valid
            True
        &#34;&#34;&#34;
        from space_hulk_game.validation.types import ProcessingResult  # noqa: PLC0415

        return ProcessingResult(
            success=self.valid,
            data=self.data,
            errors=self.errors,
            warnings=self.warnings,
            corrections=[],
            metadata={},
        )</code></pre>
    errors: list[str]
    warnings: list[str] = field(default_factory=list)

    def to_processing_result(self) -&gt; ProcessingResult:
        &#34;&#34;&#34;Convert to unified ProcessingResult type.

        Returns:
            ProcessingResult instance with equivalent data.

        Example:
            &gt;&gt;&gt; result = ValidationResult(valid=True, data=plot, errors=[])
            &gt;&gt;&gt; processing_result = result.to_processing_result()
            &gt;&gt;&gt; processing_result.is_valid
            True
        &#34;&#34;&#34;
        from space_hulk_game.validation.types import ProcessingResult  # noqa: PLC0415

        return ProcessingResult(
            success=self.valid,
            data=self.data,
            errors=self.errors,
            warnings=self.warnings,
            corrections=[],
            metadata={},
        )</code></pre>
</details>
<div class="desc"><p>Result of validating YAML output against a schema.</p>
<p>NOTE: ValidationResult is kept for backward compatibility.
New code should use ProcessingResult from validation.types</p>
<p>NOTE: ValidationResult is kept for backward compatibility.
New code should use ProcessingResult from validation.types</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>valid</code></strong></dt>
<dd>Whether the validation succeeded.</dd>
<dt><strong><code>data</code></strong></dt>
<dd>Parsed Pydantic model if validation succeeded, None otherwise.</dd>
<dt><strong><code>errors</code></strong></dt>
<dd>List of error messages if validation failed, empty list otherwise.</dd>
<dt><strong><code>warnings</code></strong></dt>
<dd>List of warning messages (non-critical issues).</dd>
<dt><strong><code>warnings</code></strong></dt>
<dd>List of warning messages (non-critical issues).</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; result = ValidationResult(valid=True, data=plot_outline, errors=[])
&gt;&gt;&gt; if result.valid:
...     print(f&quot;Validation succeeded: {result.data.title}&quot;)
... else:
...     print(f&quot;Errors: {result.errors}&quot;)
</code></pre></div>
<h3>Instance variables</h3>
<dl>
<dt id="space_hulk_game.validation.ValidationResult.data"><code class="name">var <span class="ident">data</span> : typing.Any | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.validation.ValidationResult.errors"><code class="name">var <span class="ident">errors</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.validation.ValidationResult.valid"><code class="name">var <span class="ident">valid</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.validation.ValidationResult.warnings"><code class="name">var <span class="ident">warnings</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="space_hulk_game.validation.ValidationResult.to_processing_result"><code class="name flex">
<span>def <span class="ident">to_processing_result</span></span>(<span>self) ‑> <a title="space_hulk_game.validation.ProcessingResult" href="#space_hulk_game.validation.ProcessingResult">ProcessingResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_processing_result(self) -&gt; ProcessingResult:
    &#34;&#34;&#34;Convert to unified ProcessingResult type.

    Returns:
        ProcessingResult instance with equivalent data.

    Example:
        &gt;&gt;&gt; result = ValidationResult(valid=True, data=plot, errors=[])
        &gt;&gt;&gt; processing_result = result.to_processing_result()
        &gt;&gt;&gt; processing_result.is_valid
        True
    &#34;&#34;&#34;
    from space_hulk_game.validation.types import ProcessingResult  # noqa: PLC0415

    return ProcessingResult(
        success=self.valid,
        data=self.data,
        errors=self.errors,
        warnings=self.warnings,
        corrections=[],
        metadata={},
    )</code></pre>
</details>
<div class="desc"><p>Convert to unified ProcessingResult type.</p>
<h2 id="returns">Returns</h2>
<p>ProcessingResult instance with equivalent data.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; result = ValidationResult(valid=True, data=plot, errors=[])
&gt;&gt;&gt; processing_result = result.to_processing_result()
&gt;&gt;&gt; processing_result.is_valid
True
</code></pre></div>
</dd>
<dt id="space_hulk_game.validation.ValidationResult.warnings"><code class="name">var <span class="ident">warnings</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="space_hulk_game.validation.ValidationResult.to_processing_result"><code class="name flex">
<span>def <span class="ident">to_processing_result</span></span>(<span>self) ‑> <a title="space_hulk_game.validation.ProcessingResult" href="#space_hulk_game.validation.ProcessingResult">ProcessingResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_processing_result(self) -&gt; ProcessingResult:
    &#34;&#34;&#34;Convert to unified ProcessingResult type.

    Returns:
        ProcessingResult instance with equivalent data.

    Example:
        &gt;&gt;&gt; result = ValidationResult(valid=True, data=plot, errors=[])
        &gt;&gt;&gt; processing_result = result.to_processing_result()
        &gt;&gt;&gt; processing_result.is_valid
        True
    &#34;&#34;&#34;
    from space_hulk_game.validation.types import ProcessingResult  # noqa: PLC0415

    return ProcessingResult(
        success=self.valid,
        data=self.data,
        errors=self.errors,
        warnings=self.warnings,
        corrections=[],
        metadata={},
    )</code></pre>
</details>
<div class="desc"><p>Convert to unified ProcessingResult type.</p>
<h2 id="returns">Returns</h2>
<p>ProcessingResult instance with equivalent data.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; result = ValidationResult(valid=True, data=plot, errors=[])
&gt;&gt;&gt; processing_result = result.to_processing_result()
&gt;&gt;&gt; processing_result.is_valid
True
</code></pre></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="space_hulk_game" href="../index.html">space_hulk_game</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="space_hulk_game.validation.corrector" href="corrector.html">space_hulk_game.validation.corrector</a></code></li>
<li><code><a title="space_hulk_game.validation.types" href="types.html">space_hulk_game.validation.types</a></code></li>
<li><code><a title="space_hulk_game.validation.types" href="types.html">space_hulk_game.validation.types</a></code></li>
<li><code><a title="space_hulk_game.validation.validator" href="validator.html">space_hulk_game.validation.validator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="space_hulk_game.validation.CorrectionResult" href="#space_hulk_game.validation.CorrectionResult">CorrectionResult</a></code></h4>
<ul class="">
<li><code><a title="space_hulk_game.validation.CorrectionResult.corrected_yaml" href="#space_hulk_game.validation.CorrectionResult.corrected_yaml">corrected_yaml</a></code></li>
<li><code><a title="space_hulk_game.validation.CorrectionResult.corrections" href="#space_hulk_game.validation.CorrectionResult.corrections">corrections</a></code></li>
<li><code><a title="space_hulk_game.validation.CorrectionResult.success" href="#space_hulk_game.validation.CorrectionResult.success">success</a></code></li>
<li><code><a title="space_hulk_game.validation.CorrectionResult.to_processing_result" href="#space_hulk_game.validation.CorrectionResult.to_processing_result">to_processing_result</a></code></li>
<li><code><a title="space_hulk_game.validation.CorrectionResult.to_processing_result" href="#space_hulk_game.validation.CorrectionResult.to_processing_result">to_processing_result</a></code></li>
<li><code><a title="space_hulk_game.validation.CorrectionResult.validation_result" href="#space_hulk_game.validation.CorrectionResult.validation_result">validation_result</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.validation.OutputCorrector" href="#space_hulk_game.validation.OutputCorrector">OutputCorrector</a></code></h4>
<ul class="">
<li><code><a title="space_hulk_game.validation.OutputCorrector.correct_game_mechanics" href="#space_hulk_game.validation.OutputCorrector.correct_game_mechanics">correct_game_mechanics</a></code></li>
<li><code><a title="space_hulk_game.validation.OutputCorrector.correct_narrative_map" href="#space_hulk_game.validation.OutputCorrector.correct_narrative_map">correct_narrative_map</a></code></li>
<li><code><a title="space_hulk_game.validation.OutputCorrector.correct_plot" href="#space_hulk_game.validation.OutputCorrector.correct_plot">correct_plot</a></code></li>
<li><code><a title="space_hulk_game.validation.OutputCorrector.correct_puzzle_design" href="#space_hulk_game.validation.OutputCorrector.correct_puzzle_design">correct_puzzle_design</a></code></li>
<li><code><a title="space_hulk_game.validation.OutputCorrector.correct_scene_texts" href="#space_hulk_game.validation.OutputCorrector.correct_scene_texts">correct_scene_texts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.validation.OutputValidator" href="#space_hulk_game.validation.OutputValidator">OutputValidator</a></code></h4>
<ul class="">
<li><code><a title="space_hulk_game.validation.OutputValidator.validate_game_mechanics" href="#space_hulk_game.validation.OutputValidator.validate_game_mechanics">validate_game_mechanics</a></code></li>
<li><code><a title="space_hulk_game.validation.OutputValidator.validate_narrative_map" href="#space_hulk_game.validation.OutputValidator.validate_narrative_map">validate_narrative_map</a></code></li>
<li><code><a title="space_hulk_game.validation.OutputValidator.validate_plot" href="#space_hulk_game.validation.OutputValidator.validate_plot">validate_plot</a></code></li>
<li><code><a title="space_hulk_game.validation.OutputValidator.validate_puzzle_design" href="#space_hulk_game.validation.OutputValidator.validate_puzzle_design">validate_puzzle_design</a></code></li>
<li><code><a title="space_hulk_game.validation.OutputValidator.validate_scene_texts" href="#space_hulk_game.validation.OutputValidator.validate_scene_texts">validate_scene_texts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.validation.ProcessingResult" href="#space_hulk_game.validation.ProcessingResult">ProcessingResult</a></code></h4>
<ul class="two-column">
<li><code><a title="space_hulk_game.validation.ProcessingResult.corrections" href="#space_hulk_game.validation.ProcessingResult.corrections">corrections</a></code></li>
<li><code><a title="space_hulk_game.validation.ProcessingResult.data" href="#space_hulk_game.validation.ProcessingResult.data">data</a></code></li>
<li><code><a title="space_hulk_game.validation.ProcessingResult.errors" href="#space_hulk_game.validation.ProcessingResult.errors">errors</a></code></li>
<li><code><a title="space_hulk_game.validation.ProcessingResult.has_issues" href="#space_hulk_game.validation.ProcessingResult.has_issues">has_issues</a></code></li>
<li><code><a title="space_hulk_game.validation.ProcessingResult.is_valid" href="#space_hulk_game.validation.ProcessingResult.is_valid">is_valid</a></code></li>
<li><code><a title="space_hulk_game.validation.ProcessingResult.metadata" href="#space_hulk_game.validation.ProcessingResult.metadata">metadata</a></code></li>
<li><code><a title="space_hulk_game.validation.ProcessingResult.success" href="#space_hulk_game.validation.ProcessingResult.success">success</a></code></li>
<li><code><a title="space_hulk_game.validation.ProcessingResult.warnings" href="#space_hulk_game.validation.ProcessingResult.warnings">warnings</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.validation.ProcessingResult" href="#space_hulk_game.validation.ProcessingResult">ProcessingResult</a></code></h4>
<ul class="two-column">
<li><code><a title="space_hulk_game.validation.ProcessingResult.corrections" href="#space_hulk_game.validation.ProcessingResult.corrections">corrections</a></code></li>
<li><code><a title="space_hulk_game.validation.ProcessingResult.data" href="#space_hulk_game.validation.ProcessingResult.data">data</a></code></li>
<li><code><a title="space_hulk_game.validation.ProcessingResult.errors" href="#space_hulk_game.validation.ProcessingResult.errors">errors</a></code></li>
<li><code><a title="space_hulk_game.validation.ProcessingResult.has_issues" href="#space_hulk_game.validation.ProcessingResult.has_issues">has_issues</a></code></li>
<li><code><a title="space_hulk_game.validation.ProcessingResult.is_valid" href="#space_hulk_game.validation.ProcessingResult.is_valid">is_valid</a></code></li>
<li><code><a title="space_hulk_game.validation.ProcessingResult.metadata" href="#space_hulk_game.validation.ProcessingResult.metadata">metadata</a></code></li>
<li><code><a title="space_hulk_game.validation.ProcessingResult.success" href="#space_hulk_game.validation.ProcessingResult.success">success</a></code></li>
<li><code><a title="space_hulk_game.validation.ProcessingResult.warnings" href="#space_hulk_game.validation.ProcessingResult.warnings">warnings</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.validation.ValidationResult" href="#space_hulk_game.validation.ValidationResult">ValidationResult</a></code></h4>
<ul class="">
<li><code><a title="space_hulk_game.validation.ValidationResult.data" href="#space_hulk_game.validation.ValidationResult.data">data</a></code></li>
<li><code><a title="space_hulk_game.validation.ValidationResult.errors" href="#space_hulk_game.validation.ValidationResult.errors">errors</a></code></li>
<li><code><a title="space_hulk_game.validation.ValidationResult.to_processing_result" href="#space_hulk_game.validation.ValidationResult.to_processing_result">to_processing_result</a></code></li>
<li><code><a title="space_hulk_game.validation.ValidationResult.to_processing_result" href="#space_hulk_game.validation.ValidationResult.to_processing_result">to_processing_result</a></code></li>
<li><code><a title="space_hulk_game.validation.ValidationResult.valid" href="#space_hulk_game.validation.ValidationResult.valid">valid</a></code></li>
<li><code><a title="space_hulk_game.validation.ValidationResult.warnings" href="#space_hulk_game.validation.ValidationResult.warnings">warnings</a></code></li>
<li><code><a title="space_hulk_game.validation.ValidationResult.warnings" href="#space_hulk_game.validation.ValidationResult.warnings">warnings</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
