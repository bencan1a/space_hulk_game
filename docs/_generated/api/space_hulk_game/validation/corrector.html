<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, minimum-scale=1"
    />
    <meta name="generator" content="pdoc3 0.11.6" />
    <title>space_hulk_game.validation.corrector API documentation</title>
    <meta
      name="description"
      content="Auto-correction for YAML validation outputs …"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css"
      integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA=="
      crossorigin
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css"
      integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA=="
      crossorigin
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css"
      crossorigin
    />
    <style>
      :root {
        --highlight-color: #fe9;
      }
      .flex {
        display: flex !important;
      }
      body {
        line-height: 1.5em;
      }
      #content {
        padding: 20px;
      }
      #sidebar {
        padding: 1.5em;
        overflow: hidden;
      }
      #sidebar > *:last-child {
        margin-bottom: 2cm;
      }
      .http-server-breadcrumbs {
        font-size: 130%;
        margin: 0 0 15px 0;
      }
      #footer {
        font-size: 0.75em;
        padding: 5px 30px;
        border-top: 1px solid #ddd;
        text-align: right;
      }
      #footer p {
        margin: 0 0 0 1em;
        display: inline-block;
      }
      #footer p:last-child {
        margin-right: 30px;
      }
      h1,
      h2,
      h3,
      h4,
      h5 {
        font-weight: 300;
      }
      h1 {
        font-size: 2.5em;
        line-height: 1.1em;
      }
      h2 {
        font-size: 1.75em;
        margin: 2em 0 0.5em 0;
      }
      h3 {
        font-size: 1.4em;
        margin: 1.6em 0 0.7em 0;
      }
      h4 {
        margin: 0;
        font-size: 105%;
      }
      h1:target,
      h2:target,
      h3:target,
      h4:target,
      h5:target,
      h6:target {
        background: var(--highlight-color);
        padding: 0.2em 0;
      }
      a {
        color: #058;
        text-decoration: none;
        transition: color 0.2s ease-in-out;
      }
      a:visited {
        color: #503;
      }
      a:hover {
        color: #b62;
      }
      .title code {
        font-weight: bold;
      }
      h2[id^="header-"] {
        margin-top: 2em;
      }
      .ident {
        color: #900;
        font-weight: bold;
      }
      pre code {
        font-size: 0.8em;
        line-height: 1.4em;
        padding: 1em;
        display: block;
      }
      code {
        background: #f3f3f3;
        font-family: "DejaVu Sans Mono", monospace;
        padding: 1px 4px;
        overflow-wrap: break-word;
      }
      h1 code {
        background: transparent;
      }
      pre {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        margin: 1em 0;
      }
      #http-server-module-list {
        display: flex;
        flex-flow: column;
      }
      #http-server-module-list div {
        display: flex;
      }
      #http-server-module-list dt {
        min-width: 10%;
      }
      #http-server-module-list p {
        margin-top: 0;
      }
      .toc ul,
      #index {
        list-style-type: none;
        margin: 0;
        padding: 0;
      }
      #index code {
        background: transparent;
      }
      #index h3 {
        border-bottom: 1px solid #ddd;
      }
      #index ul {
        padding: 0;
      }
      #index h4 {
        margin-top: 0.6em;
        font-weight: bold;
      }
      @media (min-width: 200ex) {
        #index .two-column {
          column-count: 2;
        }
      }
      @media (min-width: 300ex) {
        #index .two-column {
          column-count: 3;
        }
      }
      dl {
        margin-bottom: 2em;
      }
      dl dl:last-child {
        margin-bottom: 4em;
      }
      dd {
        margin: 0 0 1em 3em;
      }
      #header-classes + dl > dd {
        margin-bottom: 3em;
      }
      dd dd {
        margin-left: 2em;
      }
      dd p {
        margin: 10px 0;
      }
      .name {
        background: #eee;
        font-size: 0.85em;
        padding: 5px 10px;
        display: inline-block;
        min-width: 40%;
      }
      .name:hover {
        background: #e0e0e0;
      }
      dt:target .name {
        background: var(--highlight-color);
      }
      .name > span:first-child {
        white-space: nowrap;
      }
      .name.class > span:nth-child(2) {
        margin-left: 0.4em;
      }
      .inherited {
        color: #999;
        border-left: 5px solid #eee;
        padding-left: 1em;
      }
      .inheritance em {
        font-style: normal;
        font-weight: bold;
      }
      .desc h2 {
        font-weight: 400;
        font-size: 1.25em;
      }
      .desc h3 {
        font-size: 1em;
      }
      .desc dt code {
        background: inherit;
      }
      .source > summary,
      .git-link-div {
        color: #666;
        text-align: right;
        font-weight: 400;
        font-size: 0.8em;
        text-transform: uppercase;
      }
      .source summary > * {
        white-space: nowrap;
        cursor: pointer;
      }
      .git-link {
        color: inherit;
        margin-left: 1em;
      }
      .source pre {
        max-height: 500px;
        overflow: auto;
        margin: 0;
      }
      .source pre code {
        font-size: 12px;
        overflow: visible;
        min-width: max-content;
      }
      .hlist {
        list-style: none;
      }
      .hlist li {
        display: inline;
      }
      .hlist li:after {
        content: ",\2002";
      }
      .hlist li:last-child:after {
        content: none;
      }
      .hlist .hlist {
        display: inline;
        padding-left: 1em;
      }
      img {
        max-width: 100%;
      }
      td {
        padding: 0 0.5em;
      }
      .admonition {
        padding: 0.1em 1em;
        margin: 1em 0;
      }
      .admonition-title {
        font-weight: bold;
      }
      .admonition.note,
      .admonition.info,
      .admonition.important {
        background: #aef;
      }
      .admonition.todo,
      .admonition.versionadded,
      .admonition.tip,
      .admonition.hint {
        background: #dfd;
      }
      .admonition.warning,
      .admonition.versionchanged,
      .admonition.deprecated {
        background: #fd4;
      }
      .admonition.error,
      .admonition.danger,
      .admonition.caution {
        background: lightpink;
      }
    </style>
    <style media="screen and (min-width: 700px)">
      @media screen and (min-width: 700px) {
        #sidebar {
          width: 30%;
          height: 100vh;
          overflow: auto;
          position: sticky;
          top: 0;
        }
        #content {
          width: 70%;
          max-width: 100ch;
          padding: 3em 4em;
          border-left: 1px solid #ddd;
        }
        pre code {
          font-size: 1em;
        }
        .name {
          font-size: 1em;
        }
        main {
          display: flex;
          flex-direction: row-reverse;
          justify-content: flex-end;
        }
        .toc ul ul,
        #index ul ul {
          padding-left: 1em;
        }
        .toc > ul > li {
          margin-top: 0.5em;
        }
      }
    </style>
    <style media="print">
      @media print {
        #sidebar h1 {
          page-break-before: always;
        }
        .source {
          display: none;
        }
      }
      @media print {
        * {
          background: transparent !important;
          color: #000 !important;
          box-shadow: none !important;
          text-shadow: none !important;
        }
        a[href]:after {
          content: " (" attr(href) ")";
          font-size: 90%;
        }
        a[href][title]:after {
          content: none;
        }
        abbr[title]:after {
          content: " (" attr(title) ")";
        }
        .ir a:after,
        a[href^="javascript:"]:after,
        a[href^="#"]:after {
          content: "";
        }
        pre,
        blockquote {
          border: 1px solid #999;
          page-break-inside: avoid;
        }
        thead {
          display: table-header-group;
        }
        tr,
        img {
          page-break-inside: avoid;
        }
        img {
          max-width: 100% !important;
        }
        @page {
          margin: 0.5cm;
        }
        p,
        h2,
        h3 {
          orphans: 3;
          widows: 3;
        }
        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
          page-break-after: avoid;
        }
      }
    </style>
    <script
      defer
      src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"
      integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ=="
      crossorigin
    ></script>
    <script>
      window.addEventListener("DOMContentLoaded", () => {
        hljs.configure({
          languages: [
            "bash",
            "css",
            "diff",
            "graphql",
            "ini",
            "javascript",
            "json",
            "plaintext",
            "python",
            "python-repl",
            "rust",
            "shell",
            "sql",
            "typescript",
            "xml",
            "yaml",
          ],
        });
        hljs.highlightAll();
        /* Collapse source docstrings */
        setTimeout(() => {
          [...document.querySelectorAll(".hljs.language-python > .hljs-string")]
            .filter(
              (el) =>
                el.innerHTML.length > 200 &&
                ['"""', "'''"].includes(el.innerHTML.substring(0, 3)),
            )
            .forEach((el) => {
              let d = document.createElement("details");
              d.classList.add("hljs-string");
              d.innerHTML =
                '<summary>"""</summary>' + el.innerHTML.substring(3);
              el.replaceWith(d);
            });
        }, 100);
      });
    </script>
  </head>
  <body>
    <main>
      <article id="content">
        <header>
          <h1 class="title">
            Module <code>space_hulk_game.validation.corrector</code>
          </h1>
        </header>
        <section id="section-intro">
          <p>Auto-correction for YAML validation outputs.</p>
          <p>
            This module provides automatic correction functionality for common
            YAML validation errors in AI agent outputs. It attempts to fix
            missing fields, syntax errors, and format violations while
            preserving the intent of the original content.
          </p>
          <p>
            DEPRECATED: This module is deprecated as the system has migrated to
            JSON outputs. JSON mode in LLMs guarantees valid syntax, eliminating
            the need for syntax correction. This module is kept for backward
            compatibility with old YAML-based workflows only.
          </p>
        </section>
        <section></section>
        <section></section>
        <section></section>
        <section>
          <h2 class="section-title" id="header-classes">Classes</h2>
          <dl>
            <dt id="space_hulk_game.validation.corrector.CorrectionResult">
              <code class="flex name class">
                <span>class <span class="ident">CorrectionResult</span></span>
                <span>(</span
                ><span
                  >corrected_yaml: str,<br />corrections: list[str],<br />validation_result: ValidationResult,<br />success: bool)</span
                >
              </code>
            </dt>
            <dd>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@dataclass
class CorrectionResult:
    &#34;&#34;&#34;Result of attempting to auto-correct YAML output.

    NOTE: CorrectionResult is kept for backward compatibility.
    New code should use ProcessingResult from validation.types

    Attributes:
        corrected_yaml: The corrected YAML string.
        corrections: List of corrections applied.
        validation_result: Result from validating the corrected output.
        success: Whether correction succeeded and output is now valid.

    Example:
        &gt;&gt;&gt; result = CorrectionResult(
        ...     corrected_yaml=&#34;title: Fixed\\n...&#34;,
        ...     corrections=[&#34;Added missing &#39;plot_points&#39; field&#34;],
        ...     validation_result=ValidationResult(...),
        ...     success=True
        ... )
    &#34;&#34;&#34;

    corrected_yaml: str
    corrections: list[str]
    validation_result: ValidationResult
    success: bool

    def to_processing_result(self) -&gt; ProcessingResult:
        &#34;&#34;&#34;Convert to unified ProcessingResult type.

        Returns:
            ProcessingResult instance with equivalent data.

        Example:
            &gt;&gt;&gt; result = CorrectionResult(
            ...     corrected_yaml=&#34;title: Fixed&#34;,
            ...     corrections=[&#34;Fixed ID&#34;],
            ...     validation_result=ValidationResult(valid=True, data=None, errors=[]),
            ...     success=True
            ... )
            &gt;&gt;&gt; processing_result = result.to_processing_result()
            &gt;&gt;&gt; processing_result.is_valid
            True
        &#34;&#34;&#34;
        from space_hulk_game.validation.types import ProcessingResult  # noqa: PLC0415

        return ProcessingResult(
            success=self.success,
            data=None,  # corrected_yaml is in metadata
            errors=self.validation_result.errors if self.validation_result else [],
            warnings=self.validation_result.warnings if self.validation_result else [],
            corrections=self.corrections,
            metadata={&#34;corrected_yaml&#34;: self.corrected_yaml},
        )</code></pre>
              </details>
              <div class="desc">
                <p>Result of attempting to auto-correct YAML output.</p>
                <p>
                  NOTE: CorrectionResult is kept for backward compatibility. New
                  code should use ProcessingResult from validation.types
                </p>
                <h2 id="attributes">Attributes</h2>
                <dl>
                  <dt>
                    <strong><code>corrected_yaml</code></strong>
                  </dt>
                  <dd>The corrected YAML string.</dd>
                  <dt>
                    <strong><code>corrections</code></strong>
                  </dt>
                  <dd>List of corrections applied.</dd>
                  <dt>
                    <strong><code>validation_result</code></strong>
                  </dt>
                  <dd>Result from validating the corrected output.</dd>
                  <dt>
                    <strong><code>success</code></strong>
                  </dt>
                  <dd>Whether correction succeeded and output is now valid.</dd>
                </dl>
                <h2 id="example">Example</h2>
                <pre><code class="language-python-repl">&gt;&gt;&gt; result = CorrectionResult(
...     corrected_yaml=&quot;title: Fixed\n...&quot;,
...     corrections=[&quot;Added missing 'plot_points' field&quot;],
...     validation_result=ValidationResult(...),
...     success=True
... )
</code></pre>
              </div>
              <h3>Instance variables</h3>
              <dl>
                <dt
                  id="space_hulk_game.validation.corrector.CorrectionResult.corrected_yaml"
                >
                  <code class="name"
                    >var <span class="ident">corrected_yaml</span> : str</code
                  >
                </dt>
                <dd>
                  <div class="desc"></div>
                </dd>
                <dt
                  id="space_hulk_game.validation.corrector.CorrectionResult.corrections"
                >
                  <code class="name"
                    >var
                    <span class="ident">corrections</span> : list[str]</code
                  >
                </dt>
                <dd>
                  <div class="desc"></div>
                </dd>
                <dt
                  id="space_hulk_game.validation.corrector.CorrectionResult.success"
                >
                  <code class="name"
                    >var <span class="ident">success</span> : bool</code
                  >
                </dt>
                <dd>
                  <div class="desc"></div>
                </dd>
                <dt
                  id="space_hulk_game.validation.corrector.CorrectionResult.validation_result"
                >
                  <code class="name"
                    >var <span class="ident">validation_result</span> : <a
                      title="space_hulk_game.validation.validator.ValidationResult"
                      href="validator.html#space_hulk_game.validation.validator.ValidationResult"
                      >ValidationResult</a
                    ></code
                  >
                </dt>
                <dd>
                  <div class="desc"></div>
                </dd>
              </dl>
              <h3>Methods</h3>
              <dl>
                <dt
                  id="space_hulk_game.validation.corrector.CorrectionResult.to_processing_result"
                >
                  <code class="name flex">
                    <span
                      >def <span class="ident">to_processing_result</span></span
                    >(<span>self) ‑> ProcessingResult</span>
                  </code>
                </dt>
                <dd>
                  <details class="source">
                    <summary>
                      <span>Expand source code</span>
                    </summary>
                    <pre><code class="python">def to_processing_result(self) -&gt; ProcessingResult:
    &#34;&#34;&#34;Convert to unified ProcessingResult type.

    Returns:
        ProcessingResult instance with equivalent data.

    Example:
        &gt;&gt;&gt; result = CorrectionResult(
        ...     corrected_yaml=&#34;title: Fixed&#34;,
        ...     corrections=[&#34;Fixed ID&#34;],
        ...     validation_result=ValidationResult(valid=True, data=None, errors=[]),
        ...     success=True
        ... )
        &gt;&gt;&gt; processing_result = result.to_processing_result()
        &gt;&gt;&gt; processing_result.is_valid
        True
    &#34;&#34;&#34;
    from space_hulk_game.validation.types import ProcessingResult  # noqa: PLC0415

    return ProcessingResult(
        success=self.success,
        data=None,  # corrected_yaml is in metadata
        errors=self.validation_result.errors if self.validation_result else [],
        warnings=self.validation_result.warnings if self.validation_result else [],
        corrections=self.corrections,
        metadata={&#34;corrected_yaml&#34;: self.corrected_yaml},
    )</code></pre>
                  </details>
                  <div class="desc">
                    <p>Convert to unified ProcessingResult type.</p>
                    <h2 id="returns">Returns</h2>
                    <p>ProcessingResult instance with equivalent data.</p>
                    <h2 id="example">Example</h2>
                    <pre><code class="language-python-repl">&gt;&gt;&gt; result = CorrectionResult(
...     corrected_yaml=&quot;title: Fixed&quot;,
...     corrections=[&quot;Fixed ID&quot;],
...     validation_result=ValidationResult(valid=True, data=None, errors=[]),
...     success=True
... )
&gt;&gt;&gt; processing_result = result.to_processing_result()
&gt;&gt;&gt; processing_result.is_valid
True
</code></pre>
                  </div>
                </dd>
              </dl>
            </dd>
            <dt id="space_hulk_game.validation.corrector.OutputCorrector">
              <code class="flex name class">
                <span>class <span class="ident">OutputCorrector</span></span>
              </code>
            </dt>
            <dd>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">class OutputCorrector:
    &#34;&#34;&#34;Auto-corrector for YAML validation outputs.

    This class provides methods to automatically fix common validation errors
    in YAML outputs from AI agents. It attempts to add missing required fields,
    fix syntax errors, normalize field names, and correct ID format violations.

    Features:
        - Fixes missing required fields with sensible defaults
        - Repairs common YAML syntax errors
        - Normalizes field names (e.g., camelCase to snake_case)
        - Corrects ID format violations (lowercase, underscores, alphanumeric)
        - Logs all corrections transparently
        - Validates corrected output

    Example:
        &gt;&gt;&gt; corrector = OutputCorrector()
        &gt;&gt;&gt; result = corrector.correct_plot(invalid_yaml_string)
        &gt;&gt;&gt; if result.success:
        ...     print(f&#34;Corrections applied: {result.corrections}&#34;)
        ...     with open(&#39;output.yaml&#39;, &#39;w&#39;) as f:
        ...         f.write(result.corrected_yaml)
        ... else:
        ...     print(f&#34;Correction failed: {result.validation_result.errors}&#34;)
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialize the output corrector with a validator instance.&#34;&#34;&#34;
        self.validator = OutputValidator()
        logger.info(&#34;OutputCorrector initialized&#34;)

    def _fix_id_format(self, id_value: str) -&gt; str:
        &#34;&#34;&#34;Fix ID format to match schema requirements.

        Ensures IDs are lowercase, use underscores, and contain only
        alphanumeric characters, underscores, and hyphens.

        Args:
            id_value: Original ID value.

        Returns:
            Corrected ID value.

        Example:
            &gt;&gt;&gt; corrector = OutputCorrector()
            &gt;&gt;&gt; corrector._fix_id_format(&#34;My-Scene ID!&#34;)
            &#39;my_scene_id&#39;
        &#34;&#34;&#34;
        # Convert to lowercase
        fixed = id_value.lower()
        # Replace spaces with underscores
        fixed = fixed.replace(&#34; &#34;, &#34;_&#34;)
        # Remove invalid characters (keep only alphanumeric, underscores, hyphens)
        fixed = re.sub(r&#34;[^a-z0-9_-]&#34;, &#34;&#34;, fixed)
        # Replace multiple underscores/hyphens with single underscore
        fixed = re.sub(r&#34;[_-]+&#34;, &#34;_&#34;, fixed)
        # Remove leading/trailing underscores/hyphens
        fixed = fixed.strip(&#34;_-&#34;)
        return fixed

    def _extend_short_description(self, description: str, min_length: int) -&gt; str:
        &#34;&#34;&#34;Extend a description that is too short to meet minimum length.

        Args:
            description: Original description.
            min_length: Minimum required length.

        Returns:
            Extended description if needed, otherwise original.
        &#34;&#34;&#34;
        if len(description) &gt;= min_length:
            return description

        # Add generic filler text to meet minimum length
        filler = (
            &#34; Additional details and context will be developed further &#34;
            &#34;during the narrative design process.&#34;
        )
        extended = description + filler

        # If still not long enough, add more filler
        while len(extended) &lt; min_length:
            extended += &#34; Further elaboration and refinement will enhance this element.&#34;

        return extended

    def _fix_mixed_quotes(self, content: str) -&gt; str:
        &#34;&#34;&#34;Fix strings with mismatched quote delimiters.

        Handles strings like &#34;entrance&#39; or &#39;corridor_1&#34; where the opening
        and closing quotes don&#39;t match. Normalizes to the opening quote type.

        Args:
            content: Raw YAML string with potential mixed quotes.

        Returns:
            Fixed YAML string with consistent quote usage.

        Example:
            &gt;&gt;&gt; corrector = OutputCorrector()
            &gt;&gt;&gt; corrector._fix_mixed_quotes(&#39;starting_scene: &#34;entrance\\&#39;&#39;)
            &#39;starting_scene: &#34;entrance&#34;&#39;
            &gt;&gt;&gt; corrector._fix_mixed_quotes(&#34;south: &#39;corridor_1\\&#34;&#34;)
            &#34;south: &#39;corridor_1&#39;&#34;
        &#34;&#34;&#34;
        # Strategy: Look for strings that start with one quote type and end with another
        # We need to be careful about apostrophes inside strings
        # Pattern 1: &#34; ... &#39; at end of line (double quote start, single quote end)
        # Pattern 2: &#39; ... &#34; at end of line (single quote start, double quote end)

        # Use line-by-line processing to avoid matching across multiple values
        lines = content.split(&#34;\n&#34;)
        fixed_lines = []

        for line in lines:
            # Check for mismatched quotes on this line
            # Pattern: starts with &#34; and ends with &#39; (at end of line)
            if re.search(r&#39;:\s*&#34;[^&#34;]*\&#39;$&#39;, line):
                # Replace the final &#39; with &#34;
                line = re.sub(r&#34;\&#39;$&#34;, &#39;&#34;&#39;, line)  # noqa: PLW2901
            # Pattern: starts with &#39; and ends with &#34; (at end of line)
            elif re.search(r&#34;:\s*&#39;[^&#39;]*\&#34;$&#34;, line):
                # Replace the final &#34; with &#39;
                line = re.sub(r&#39;&#34;$&#39;, &#34;&#39;&#34;, line)  # noqa: PLW2901

            fixed_lines.append(line)

        content = &#34;\n&#34;.join(fixed_lines)
        logger.debug(&#34;Fixed mixed quote delimiters&#34;)
        return content

    def _fix_invalid_list_markers(self, content: str) -&gt; str:
        &#34;&#34;&#34;Fix invalid YAML list markers with multiple dashes.

        Handles list items marked with multiple dashes (e.g., &#39;---------------- item&#39;)
        and converts them to proper YAML list syntax (&#39;- item&#39;).

        Args:
            content: Raw YAML string with potential invalid list markers.

        Returns:
            Fixed YAML string with proper list markers.

        Example:
            &gt;&gt;&gt; corrector = OutputCorrector()
            &gt;&gt;&gt; corrector._fix_invalid_list_markers(&#39;items:\\n  ---------------- flashlight&#39;)
            &#39;items:\\n  - flashlight&#39;
        &#34;&#34;&#34;
        # Pattern: line starting with indentation, followed by 4+ dashes, then content
        # Captures: (indentation) (4+ dashes) (optional spaces) (rest of line)
        # Replace with: (indentation) - (rest of line)
        content = re.sub(
            r&#34;^(\s*)-{4,}\s*(.+)$&#34;,
            r&#34;\1- \2&#34;,
            content,
            flags=re.MULTILINE,
        )

        logger.debug(&#34;Fixed invalid list markers&#34;)
        return content

    def _fix_unescaped_apostrophes(self, content: str) -&gt; str:
        &#34;&#34;&#34;Fix unescaped apostrophes in single-quoted strings.

        Handles apostrophes inside single-quoted strings (e.g., &#39;Ship&#39;s Bridge&#39;)
        by converting them to double-quoted strings to avoid escaping.

        Args:
            content: Raw YAML string with potential unescaped apostrophes.

        Returns:
            Fixed YAML string with apostrophes properly handled.

        Example:
            &gt;&gt;&gt; corrector = OutputCorrector()
            &gt;&gt;&gt; corrector._fix_unescaped_apostrophes(&#34;name: &#39;Ship&#39;s Bridge&#39;&#34;)
            &#39;name: &#34;Ship\\&#39;s Bridge&#34;&#39;
            &gt;&gt;&gt; corrector._fix_unescaped_apostrophes(&#34;description: &#39;The captain&#39;s quarters&#39;&#34;)
            &#39;description: &#34;The captain\\&#39;s quarters&#34;&#39;
        &#34;&#34;&#34;
        # Pattern: find single-quoted strings that contain apostrophes
        # We need to match the entire string including any apostrophes inside
        # Strategy: Look for : &#39;some text with potential apostrophe&#39; pattern
        # Use a greedy match to get everything between the outer quotes

        def replace_single_quoted_with_apostrophe(match):
            &#34;&#34;&#34;Replace single-quoted string containing apostrophe with double-quoted version.&#34;&#34;&#34;
            prefix = match.group(1)  # Everything before the opening quote (: and spaces)
            inner_content = match.group(2)  # Content inside the outer quotes

            # Check if content contains an apostrophe (but not just the closing quote)
            # We need to look for apostrophes that are NOT the final closing quote
            if &#34;&#39;&#34; in inner_content:
                # Convert to double-quoted string
                # The content already has the apostrophes, just change the delimiters
                return f&#39;{prefix}&#34;{inner_content}&#34;&#39;
            else:
                # Keep as-is
                return match.group(0)

        # Pattern: (: + optional spaces) &#39; (everything until last &#39;) &#39;
        # This uses a possessive quantifier to match everything between outer quotes
        # The pattern matches: colon, spaces, opening single quote, content (greedy), closing single quote
        # We need to match the full quoted string, even if it contains apostrophes
        # The key insight: match from &#39; to the LAST &#39; on the line
        lines = content.split(&#34;\n&#34;)
        fixed_lines = []

        for line in lines:
            # Look for pattern: key: &#39;value with potential apostrophes&#39;
            # Use a more sophisticated approach: find : &#39; pairs and match to closing &#39;
            if &#34;: &#39;&#34; in line or &#34;:\t&#39;&#34; in line:
                # Find the position of &#34;: &#39;&#34;
                match = re.search(r&#34;(\s*:\s*)&#39;(.+)&#39;$&#34;, line)
                if match:
                    prefix = match.group(1)
                    inner = match.group(2)
                    # Check if inner content has apostrophes
                    if &#34;&#39;&#34; in inner:
                        # Replace the line with double-quoted version
                        fixed_line = line[: match.start()] + f&#39;{prefix}&#34;{inner}&#34;&#39;
                        fixed_lines.append(fixed_line)
                        continue
            # No match or no apostrophes, keep original
            fixed_lines.append(line)

        result = &#34;\n&#34;.join(fixed_lines)
        logger.debug(&#34;Fixed unescaped apostrophes in single-quoted strings&#34;)
        return result

    def _parse_yaml_safe(self, raw_output: str) -&gt; tuple[dict | None, list[str]]:
        &#34;&#34;&#34;Safely parse YAML with error recovery.

        Attempts to parse YAML and apply basic syntax fixes if parsing fails.

        Args:
            raw_output: Raw YAML string.

        Returns:
            Tuple of (parsed_data, errors). If parsing succeeds, parsed_data
            is a dict and errors is empty. If parsing fails, parsed_data is None
            and errors contains the error messages.
        &#34;&#34;&#34;
        try:
            # Strip markdown fences first
            clean_yaml = strip_markdown_yaml_blocks(raw_output)

            # Apply syntax fixes BEFORE parsing
            clean_yaml = self._fix_mixed_quotes(clean_yaml)
            clean_yaml = self._fix_invalid_list_markers(clean_yaml)
            clean_yaml = self._fix_unescaped_apostrophes(clean_yaml)

            # Try to parse
            data = yaml.safe_load(clean_yaml)

            if data is None:
                return None, [&#34;YAML is empty or contains only whitespace&#34;]

            if not isinstance(data, dict):
                return None, [f&#34;YAML must be a dictionary, got {type(data).__name__}&#34;]

            return data, []

        except yaml.YAMLError as e:
            # Attempt basic syntax fixes
            logger.warning(f&#34;YAML parsing error, attempting fixes: {e}&#34;)

            try:
                # Common fix: remove duplicate colons, fix indentation issues
                clean_yaml = strip_markdown_yaml_blocks(raw_output)

                # NOTE: This is the ONLY implementation of colon-in-values fixing.
                # Other modules (evaluator, crew) have been refactored to rely on this.
                # Do not duplicate this logic elsewhere.
                #
                # Try to fix &#34;mapping values are not allowed here&#34; by escaping colons in values
                # This is a simple heuristic and may not catch all cases
                lines = clean_yaml.split(&#34;\n&#34;)
                fixed_lines = []
                for line in lines:
                    if &#34;:&#34; in line and not line.strip().startswith(&#34;#&#34;):
                        # Check if there are multiple colons (potential issue)
                        parts = line.split(&#34;:&#34;, 1)
                        if len(parts) == 2 and &#34;:&#34; in parts[1]:
                            # Quote the value if it contains colons
                            indent = len(line) - len(line.lstrip())
                            key = parts[0].strip()
                            value = parts[1].strip()
                            if not (value.startswith(&#39;&#34;&#39;) or value.startswith(&#34;&#39;&#34;)):
                                fixed_lines.append(f&#34;{&#39; &#39; * indent}{key}: &#39;{value}&#39;&#34;)
                            else:
                                fixed_lines.append(line)
                        else:
                            fixed_lines.append(line)
                    else:
                        fixed_lines.append(line)

                fixed_yaml = &#34;\n&#34;.join(fixed_lines)
                data = yaml.safe_load(fixed_yaml)

                if data is None:
                    return None, [&#34;YAML is empty after attempted fix&#34;]

                if not isinstance(data, dict):
                    return None, [f&#34;YAML must be a dictionary, got {type(data).__name__}&#34;]

                logger.info(&#34;Successfully fixed YAML syntax error&#34;)
                return data, []

            except yaml.YAMLError as e2:
                error_msg = f&#34;YAML parsing error (even after attempted fix): {e2!s}&#34;
                logger.error(error_msg)
                return None, [error_msg]

        except Exception as e:
            error_msg = f&#34;Unexpected error during YAML parsing: {e!s}&#34;
            logger.error(error_msg)
            return None, [error_msg]

    def correct_plot(self, raw_output: str) -&gt; CorrectionResult:
        &#34;&#34;&#34;Attempt to correct common errors in plot outline YAML.

        Fixes:
            - Missing required fields (plot_points, characters, conflicts)
            - Invalid ID formats
            - Descriptions too short
            - YAML syntax errors

        Args:
            raw_output: Raw YAML string containing plot outline data.

        Returns:
            CorrectionResult with corrected YAML, list of corrections,
            validation result, and success status.

        Example:
            &gt;&gt;&gt; corrector = OutputCorrector()
            &gt;&gt;&gt; result = corrector.correct_plot(invalid_plot_yaml)
            &gt;&gt;&gt; if result.success:
            ...     print(f&#34;Plot corrected with {len(result.corrections)} changes&#34;)
        &#34;&#34;&#34;
        logger.info(&#34;Attempting to correct plot outline YAML&#34;)
        corrections: list[str] = []

        # Parse YAML
        data, parse_errors = self._parse_yaml_safe(raw_output)
        if parse_errors:
            # Can&#39;t fix unparseable YAML beyond basic syntax fixes already attempted
            validation_result = ValidationResult(valid=False, data=None, errors=parse_errors)
            return CorrectionResult(
                corrected_yaml=raw_output,
                corrections=corrections,
                validation_result=validation_result,
                success=False,
            )

        # Type guard: data is guaranteed to be dict here
        assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

        # Add missing required fields
        if &#34;title&#34; not in data:
            data[&#34;title&#34;] = &#34;Untitled Plot&#34;
            corrections.append(&#34;Added missing &#39;title&#39; field with default value&#34;)
            logger.info(&#34;Added missing &#39;title&#39; field&#34;)

        if &#34;setting&#34; not in data:
            data[&#34;setting&#34;] = self._extend_short_description(
                &#34;A dark and atmospheric setting for the narrative.&#34;, 50
            )
            corrections.append(&#34;Added missing &#39;setting&#39; field with default value&#34;)
            logger.info(&#34;Added missing &#39;setting&#39; field&#34;)
        elif len(data[&#34;setting&#34;]) &lt; 50:
            original_setting = data[&#34;setting&#34;]
            data[&#34;setting&#34;] = self._extend_short_description(data[&#34;setting&#34;], 50)
            corrections.append(
                f&#34;Extended short &#39;setting&#39; field (was {len(original_setting)} chars)&#34;
            )
            logger.info(&#34;Extended &#39;setting&#39; field&#34;)

        if &#34;themes&#34; not in data or not data[&#34;themes&#34;]:
            data[&#34;themes&#34;] = [&#34;survival&#34;, &#34;conflict&#34;]
            corrections.append(&#34;Added missing &#39;themes&#39; field with default values&#34;)
            logger.info(&#34;Added missing &#39;themes&#39; field&#34;)

        if &#34;tone&#34; not in data:
            data[&#34;tone&#34;] = &#34;Dark and atmospheric&#34;
            corrections.append(&#34;Added missing &#39;tone&#39; field with default value&#34;)
            logger.info(&#34;Added missing &#39;tone&#39; field&#34;)
        elif len(data[&#34;tone&#34;]) &lt; 10:
            original_tone = data[&#34;tone&#34;]
            data[&#34;tone&#34;] = self._extend_short_description(data[&#34;tone&#34;], 10)
            corrections.append(f&#34;Extended short &#39;tone&#39; field (was {len(original_tone)} chars)&#34;)
            logger.info(&#34;Extended &#39;tone&#39; field&#34;)

        if &#34;plot_points&#34; not in data or not data[&#34;plot_points&#34;]:
            data[&#34;plot_points&#34;] = [
                {
                    &#34;id&#34;: &#34;pp_01_opening&#34;,
                    &#34;name&#34;: &#34;Opening&#34;,
                    &#34;description&#34;: self._extend_short_description(
                        &#34;The story begins with the initial situation.&#34;, 50
                    ),
                },
                {
                    &#34;id&#34;: &#34;pp_02_development&#34;,
                    &#34;name&#34;: &#34;Development&#34;,
                    &#34;description&#34;: self._extend_short_description(
                        &#34;The plot develops as events unfold.&#34;, 50
                    ),
                },
                {
                    &#34;id&#34;: &#34;pp_03_conclusion&#34;,
                    &#34;name&#34;: &#34;Conclusion&#34;,
                    &#34;description&#34;: self._extend_short_description(
                        &#34;The story reaches its conclusion and resolution.&#34;, 50
                    ),
                },
            ]
            corrections.append(&#34;Added missing &#39;plot_points&#39; field with minimal defaults&#34;)
            logger.info(&#34;Added missing &#39;plot_points&#39; field&#34;)

        if &#34;characters&#34; not in data or not data[&#34;characters&#34;]:
            data[&#34;characters&#34;] = [
                {
                    &#34;name&#34;: &#34;Protagonist&#34;,
                    &#34;role&#34;: &#34;Main character&#34;,
                    &#34;backstory&#34;: self._extend_short_description(
                        &#34;The protagonist&#39;s background and history.&#34;, 50
                    ),
                }
            ]
            corrections.append(&#34;Added missing &#39;characters&#39; field with minimal default&#34;)
            logger.info(&#34;Added missing &#39;characters&#39; field&#34;)

        if &#34;conflicts&#34; not in data or not data[&#34;conflicts&#34;]:
            data[&#34;conflicts&#34;] = [
                {
                    &#34;type&#34;: &#34;Main Conflict&#34;,
                    &#34;description&#34;: self._extend_short_description(
                        &#34;The primary conflict driving the narrative.&#34;, 50
                    ),
                }
            ]
            corrections.append(&#34;Added missing &#39;conflicts&#39; field with minimal default&#34;)
            logger.info(&#34;Added missing &#39;conflicts&#39; field&#34;)

        # Fix plot point IDs and descriptions
        if &#34;plot_points&#34; in data and isinstance(data[&#34;plot_points&#34;], list):
            for _i, pp in enumerate(data[&#34;plot_points&#34;]):
                if isinstance(pp, dict):
                    # Fix ID format
                    if &#34;id&#34; in pp:
                        original_id = pp[&#34;id&#34;]
                        fixed_id = self._fix_id_format(original_id)
                        if original_id != fixed_id:
                            pp[&#34;id&#34;] = fixed_id
                            corrections.append(
                                f&#34;Fixed plot point ID format: &#39;{original_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;
                            )
                            logger.info(f&#34;Fixed plot point ID: {original_id} -&gt; {fixed_id}&#34;)

                    # Extend short descriptions
                    if &#34;description&#34; in pp and len(pp[&#34;description&#34;]) &lt; 50:
                        original_desc = pp[&#34;description&#34;]
                        pp[&#34;description&#34;] = self._extend_short_description(pp[&#34;description&#34;], 50)
                        corrections.append(
                            f&#34;Extended short plot point description &#34;
                            f&#34;(was {len(original_desc)} chars)&#34;
                        )
                        logger.info(
                            f&#34;Extended plot point description from {len(original_desc)} &#34;
                            f&#34;to {len(pp[&#39;description&#39;])} chars&#34;
                        )

        # Fix character backstories
        if &#34;characters&#34; in data and isinstance(data[&#34;characters&#34;], list):
            for char in data[&#34;characters&#34;]:
                if isinstance(char, dict) and &#34;backstory&#34; in char and len(char[&#34;backstory&#34;]) &lt; 50:
                    original_backstory = char[&#34;backstory&#34;]
                    char[&#34;backstory&#34;] = self._extend_short_description(char[&#34;backstory&#34;], 50)
                    corrections.append(
                        f&#34;Extended short character backstory (was {len(original_backstory)} chars)&#34;
                    )
                    logger.info(
                        f&#34;Extended character backstory from {len(original_backstory)} &#34;
                        f&#34;to {len(char[&#39;backstory&#39;])} chars&#34;
                    )

        # Fix conflict descriptions
        if &#34;conflicts&#34; in data and isinstance(data[&#34;conflicts&#34;], list):
            for conflict in data[&#34;conflicts&#34;]:
                if (
                    isinstance(conflict, dict)
                    and &#34;description&#34; in conflict
                    and len(conflict[&#34;description&#34;]) &lt; 50
                ):
                    original_desc = conflict[&#34;description&#34;]
                    conflict[&#34;description&#34;] = self._extend_short_description(
                        conflict[&#34;description&#34;], 50
                    )
                    corrections.append(
                        f&#34;Extended short conflict description (was {len(original_desc)} chars)&#34;
                    )
                    logger.info(
                        f&#34;Extended conflict description from {len(original_desc)} &#34;
                        f&#34;to {len(conflict[&#39;description&#39;])} chars&#34;
                    )

        # Convert back to YAML
        try:
            corrected_yaml = yaml.dump(
                data, default_flow_style=False, sort_keys=False, allow_unicode=True
            )
        except Exception as e:
            logger.error(f&#34;Error converting corrected data to YAML: {e}&#34;)
            validation_result = ValidationResult(
                valid=False, data=None, errors=[f&#34;Error converting to YAML: {e!s}&#34;]
            )
            return CorrectionResult(
                corrected_yaml=raw_output,
                corrections=corrections,
                validation_result=validation_result,
                success=False,
            )

        # Validate corrected output
        validation_result = self.validator.validate_plot(corrected_yaml)

        logger.info(
            f&#34;Plot correction complete: {len(corrections)} corrections, &#34;
            f&#34;valid={validation_result.valid}&#34;
        )

        return CorrectionResult(
            corrected_yaml=corrected_yaml,
            corrections=corrections,
            validation_result=validation_result,
            success=validation_result.valid,
        )

    def correct_narrative_map(self, raw_output: str) -&gt; CorrectionResult:
        &#34;&#34;&#34;Attempt to correct common errors in narrative map YAML.

        Fixes:
            - Missing required fields (start_scene, scenes)
            - Invalid ID formats
            - Descriptions too short
            - YAML syntax errors

        Args:
            raw_output: Raw YAML string containing narrative map data.

        Returns:
            CorrectionResult with corrected YAML, list of corrections,
            validation result, and success status.

        Example:
            &gt;&gt;&gt; corrector = OutputCorrector()
            &gt;&gt;&gt; result = corrector.correct_narrative_map(invalid_map_yaml)
            &gt;&gt;&gt; if result.success:
            ...     print(f&#34;Map corrected with {len(result.corrections)} changes&#34;)
        &#34;&#34;&#34;
        logger.info(&#34;Attempting to correct narrative map YAML&#34;)
        corrections: list[str] = []

        # Parse YAML
        data, parse_errors = self._parse_yaml_safe(raw_output)
        if parse_errors:
            validation_result = ValidationResult(valid=False, data=None, errors=parse_errors)
            return CorrectionResult(
                corrected_yaml=raw_output,
                corrections=corrections,
                validation_result=validation_result,
                success=False,
            )

        assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

        # Add missing required fields
        if &#34;scenes&#34; not in data or not data[&#34;scenes&#34;]:
            data[&#34;scenes&#34;] = {
                &#34;scene_default&#34;: {
                    &#34;name&#34;: &#34;Default Scene&#34;,
                    &#34;description&#34;: self._extend_short_description(
                        &#34;A default scene in the narrative.&#34;, 50
                    ),
                    &#34;connections&#34;: [],
                }
            }
            corrections.append(&#34;Added missing &#39;scenes&#39; field with minimal default&#34;)
            logger.info(&#34;Added missing &#39;scenes&#39; field&#34;)

        if &#34;start_scene&#34; not in data:
            # Use the first scene as the start scene
            if isinstance(data.get(&#34;scenes&#34;), dict) and data[&#34;scenes&#34;]:
                first_scene_id = next(iter(data[&#34;scenes&#34;].keys()))
                data[&#34;start_scene&#34;] = first_scene_id
                corrections.append(f&#34;Added missing &#39;start_scene&#39; field (set to &#39;{first_scene_id}&#39;)&#34;)
                logger.info(f&#34;Added missing &#39;start_scene&#39; field: {first_scene_id}&#34;)
            else:
                data[&#34;start_scene&#34;] = &#34;scene_default&#34;
                corrections.append(&#34;Added missing &#39;start_scene&#39; field with default value&#34;)
                logger.info(&#34;Added missing &#39;start_scene&#39; field&#34;)

        # Fix scene IDs and descriptions
        if &#34;scenes&#34; in data and isinstance(data[&#34;scenes&#34;], dict):
            fixed_scenes = {}
            for scene_id, scene in data[&#34;scenes&#34;].items():
                # Fix scene ID format
                fixed_id = self._fix_id_format(scene_id)
                if scene_id != fixed_id:
                    corrections.append(f&#34;Fixed scene ID format: &#39;{scene_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;)
                    logger.info(f&#34;Fixed scene ID: {scene_id} -&gt; {fixed_id}&#34;)
                    # Update start_scene if it matches the old ID
                    if data.get(&#34;start_scene&#34;) == scene_id:
                        data[&#34;start_scene&#34;] = fixed_id
                        corrections.append(f&#34;Updated &#39;start_scene&#39; to match fixed ID: &#39;{fixed_id}&#39;&#34;)

                if isinstance(scene, dict):
                    # Extend short descriptions
                    if &#34;description&#34; in scene and len(scene[&#34;description&#34;]) &lt; 50:
                        original_desc = scene[&#34;description&#34;]
                        scene[&#34;description&#34;] = self._extend_short_description(
                            scene[&#34;description&#34;], 50
                        )
                        corrections.append(
                            f&#34;Extended short scene description (was {len(original_desc)} chars)&#34;
                        )
                        logger.info(
                            f&#34;Extended scene description from {len(original_desc)} &#34;
                            f&#34;to {len(scene[&#39;description&#39;])} chars&#34;
                        )

                    # Ensure connections is a list
                    if &#34;connections&#34; not in scene:
                        scene[&#34;connections&#34;] = []
                        corrections.append(
                            f&#34;Added missing &#39;connections&#39; field to scene &#39;{fixed_id}&#39;&#34;
                        )

                    # Fix connection target IDs
                    if &#34;connections&#34; in scene and isinstance(scene[&#34;connections&#34;], list):
                        for conn in scene[&#34;connections&#34;]:
                            if isinstance(conn, dict) and &#34;target&#34; in conn:
                                original_target = conn[&#34;target&#34;]
                                fixed_target = self._fix_id_format(original_target)
                                if original_target != fixed_target:
                                    conn[&#34;target&#34;] = fixed_target
                                    corrections.append(
                                        f&#34;Fixed connection target ID: &#34;
                                        f&#34;&#39;{original_target}&#39; -&gt; &#39;{fixed_target}&#39;&#34;
                                    )

                fixed_scenes[fixed_id] = scene

            data[&#34;scenes&#34;] = fixed_scenes

        # Convert back to YAML
        try:
            corrected_yaml = yaml.dump(
                data, default_flow_style=False, sort_keys=False, allow_unicode=True
            )
        except Exception as e:
            logger.error(f&#34;Error converting corrected data to YAML: {e}&#34;)
            validation_result = ValidationResult(
                valid=False, data=None, errors=[f&#34;Error converting to YAML: {e!s}&#34;]
            )
            return CorrectionResult(
                corrected_yaml=raw_output,
                corrections=corrections,
                validation_result=validation_result,
                success=False,
            )

        # Validate corrected output
        validation_result = self.validator.validate_narrative_map(corrected_yaml)

        logger.info(
            f&#34;Narrative map correction complete: {len(corrections)} corrections, &#34;
            f&#34;valid={validation_result.valid}&#34;
        )

        return CorrectionResult(
            corrected_yaml=corrected_yaml,
            corrections=corrections,
            validation_result=validation_result,
            success=validation_result.valid,
        )

    def correct_puzzle_design(self, raw_output: str) -&gt; CorrectionResult:
        &#34;&#34;&#34;Attempt to correct common errors in puzzle design YAML.

        Fixes:
            - Missing required fields (puzzles, artifacts, monsters, npcs)
            - Invalid ID formats
            - Descriptions too short
            - YAML syntax errors

        Args:
            raw_output: Raw YAML string containing puzzle design data.

        Returns:
            CorrectionResult with corrected YAML, list of corrections,
            validation result, and success status.

        Example:
            &gt;&gt;&gt; corrector = OutputCorrector()
            &gt;&gt;&gt; result = corrector.correct_puzzle_design(invalid_puzzle_yaml)
            &gt;&gt;&gt; if result.success:
            ...     print(f&#34;Puzzle design corrected with {len(result.corrections)} changes&#34;)
        &#34;&#34;&#34;
        logger.info(&#34;Attempting to correct puzzle design YAML&#34;)
        corrections: list[str] = []

        # Parse YAML
        data, parse_errors = self._parse_yaml_safe(raw_output)
        if parse_errors:
            validation_result = ValidationResult(valid=False, data=None, errors=parse_errors)
            return CorrectionResult(
                corrected_yaml=raw_output,
                corrections=corrections,
                validation_result=validation_result,
                success=False,
            )

        assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

        # Add missing required fields
        if &#34;puzzles&#34; not in data or not data[&#34;puzzles&#34;]:
            data[&#34;puzzles&#34;] = [
                {
                    &#34;id&#34;: &#34;puzzle_default&#34;,
                    &#34;name&#34;: &#34;Default Puzzle&#34;,
                    &#34;description&#34;: self._extend_short_description(
                        &#34;A puzzle in the game that requires solving.&#34;, 50
                    ),
                    &#34;location&#34;: &#34;scene_default&#34;,
                    &#34;narrative_purpose&#34;: &#34;Provides a challenge for the player to overcome.&#34;,
                    &#34;solution&#34;: {
                        &#34;type&#34;: &#34;multi-step&#34;,
                        &#34;steps&#34;: [{&#34;step&#34;: &#34;Complete the required actions to solve this puzzle.&#34;}],
                    },
                    &#34;difficulty&#34;: &#34;medium&#34;,
                }
            ]
            corrections.append(&#34;Added missing &#39;puzzles&#39; field with minimal default&#34;)
            logger.info(&#34;Added missing &#39;puzzles&#39; field&#34;)

        if &#34;artifacts&#34; not in data or not data[&#34;artifacts&#34;]:
            data[&#34;artifacts&#34;] = [
                {
                    &#34;id&#34;: &#34;artifact_default&#34;,
                    &#34;name&#34;: &#34;Default Artifact&#34;,
                    &#34;description&#34;: &#34;An artifact found in the game world.&#34;,
                    &#34;location&#34;: &#34;scene_default&#34;,
                    &#34;narrative_significance&#34;: &#34;Holds narrative importance to the story.&#34;,
                    &#34;properties&#34;: [{&#34;property&#34;: &#34;Has special properties or effects&#34;}],
                }
            ]
            corrections.append(&#34;Added missing &#39;artifacts&#39; field with minimal default&#34;)
            logger.info(&#34;Added missing &#39;artifacts&#39; field&#34;)

        if &#34;monsters&#34; not in data or not data[&#34;monsters&#34;]:
            data[&#34;monsters&#34;] = [
                {
                    &#34;id&#34;: &#34;monster_default&#34;,
                    &#34;name&#34;: &#34;Default Monster&#34;,
                    &#34;description&#34;: &#34;A hostile entity encountered in the game.&#34;,
                    &#34;locations&#34;: [&#34;scene_default&#34;],
                    &#34;narrative_role&#34;: &#34;Provides combat challenge and threat.&#34;,
                    &#34;abilities&#34;: [&#34;Attack&#34;],
                }
            ]
            corrections.append(&#34;Added missing &#39;monsters&#39; field with minimal default&#34;)
            logger.info(&#34;Added missing &#39;monsters&#39; field&#34;)

        if &#34;npcs&#34; not in data or not data[&#34;npcs&#34;]:
            data[&#34;npcs&#34;] = [
                {
                    &#34;id&#34;: &#34;npc_default&#34;,
                    &#34;name&#34;: &#34;Default NPC&#34;,
                    &#34;role&#34;: &#34;Supporting character&#34;,
                    &#34;description&#34;: &#34;A non-player character in the game.&#34;,
                    &#34;locations&#34;: [&#34;scene_default&#34;],
                    &#34;dialogue_themes&#34;: [&#34;General conversation&#34;],
                }
            ]
            corrections.append(&#34;Added missing &#39;npcs&#39; field with minimal default&#34;)
            logger.info(&#34;Added missing &#39;npcs&#39; field&#34;)

        # Fix puzzle IDs and descriptions
        if &#34;puzzles&#34; in data and isinstance(data[&#34;puzzles&#34;], list):
            for puzzle in data[&#34;puzzles&#34;]:
                if isinstance(puzzle, dict):
                    # Fix ID format
                    if &#34;id&#34; in puzzle:
                        original_id = puzzle[&#34;id&#34;]
                        fixed_id = self._fix_id_format(original_id)
                        if original_id != fixed_id:
                            puzzle[&#34;id&#34;] = fixed_id
                            corrections.append(
                                f&#34;Fixed puzzle ID format: &#39;{original_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;
                            )
                            logger.info(f&#34;Fixed puzzle ID: {original_id} -&gt; {fixed_id}&#34;)

                    # Extend short descriptions
                    if &#34;description&#34; in puzzle and len(puzzle[&#34;description&#34;]) &lt; 50:
                        original_desc = puzzle[&#34;description&#34;]
                        puzzle[&#34;description&#34;] = self._extend_short_description(
                            puzzle[&#34;description&#34;], 50
                        )
                        corrections.append(
                            f&#34;Extended short puzzle description (was {len(original_desc)} chars)&#34;
                        )

        # Fix artifact IDs
        if &#34;artifacts&#34; in data and isinstance(data[&#34;artifacts&#34;], list):
            for artifact in data[&#34;artifacts&#34;]:
                if isinstance(artifact, dict) and &#34;id&#34; in artifact:
                    original_id = artifact[&#34;id&#34;]
                    fixed_id = self._fix_id_format(original_id)
                    if original_id != fixed_id:
                        artifact[&#34;id&#34;] = fixed_id
                        corrections.append(
                            f&#34;Fixed artifact ID format: &#39;{original_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;
                        )
                        logger.info(f&#34;Fixed artifact ID: {original_id} -&gt; {fixed_id}&#34;)

        # Fix monster IDs
        if &#34;monsters&#34; in data and isinstance(data[&#34;monsters&#34;], list):
            for monster in data[&#34;monsters&#34;]:
                if isinstance(monster, dict) and &#34;id&#34; in monster:
                    original_id = monster[&#34;id&#34;]
                    fixed_id = self._fix_id_format(original_id)
                    if original_id != fixed_id:
                        monster[&#34;id&#34;] = fixed_id
                        corrections.append(
                            f&#34;Fixed monster ID format: &#39;{original_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;
                        )
                        logger.info(f&#34;Fixed monster ID: {original_id} -&gt; {fixed_id}&#34;)

        # Fix NPC IDs
        if &#34;npcs&#34; in data and isinstance(data[&#34;npcs&#34;], list):
            for npc in data[&#34;npcs&#34;]:
                if isinstance(npc, dict) and &#34;id&#34; in npc:
                    original_id = npc[&#34;id&#34;]
                    fixed_id = self._fix_id_format(original_id)
                    if original_id != fixed_id:
                        npc[&#34;id&#34;] = fixed_id
                        corrections.append(f&#34;Fixed NPC ID format: &#39;{original_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;)
                        logger.info(f&#34;Fixed NPC ID: {original_id} -&gt; {fixed_id}&#34;)

        # Convert back to YAML
        try:
            corrected_yaml = yaml.dump(
                data, default_flow_style=False, sort_keys=False, allow_unicode=True
            )
        except Exception as e:
            logger.error(f&#34;Error converting corrected data to YAML: {e}&#34;)
            validation_result = ValidationResult(
                valid=False, data=None, errors=[f&#34;Error converting to YAML: {e!s}&#34;]
            )
            return CorrectionResult(
                corrected_yaml=raw_output,
                corrections=corrections,
                validation_result=validation_result,
                success=False,
            )

        # Validate corrected output
        validation_result = self.validator.validate_puzzle_design(corrected_yaml)

        logger.info(
            f&#34;Puzzle design correction complete: {len(corrections)} corrections, &#34;
            f&#34;valid={validation_result.valid}&#34;
        )

        return CorrectionResult(
            corrected_yaml=corrected_yaml,
            corrections=corrections,
            validation_result=validation_result,
            success=validation_result.valid,
        )

    def correct_scene_texts(self, raw_output: str) -&gt; CorrectionResult:
        &#34;&#34;&#34;Attempt to correct common errors in scene texts YAML.

        Fixes:
            - Missing required fields (scenes)
            - Invalid ID formats
            - Descriptions too short
            - YAML syntax errors

        Args:
            raw_output: Raw YAML string containing scene texts data.

        Returns:
            CorrectionResult with corrected YAML, list of corrections,
            validation result, and success status.

        Example:
            &gt;&gt;&gt; corrector = OutputCorrector()
            &gt;&gt;&gt; result = corrector.correct_scene_texts(invalid_scene_yaml)
            &gt;&gt;&gt; if result.success:
            ...     print(f&#34;Scene texts corrected with {len(result.corrections)} changes&#34;)
        &#34;&#34;&#34;
        logger.info(&#34;Attempting to correct scene texts YAML&#34;)
        corrections: list[str] = []

        # Parse YAML
        data, parse_errors = self._parse_yaml_safe(raw_output)
        if parse_errors:
            validation_result = ValidationResult(valid=False, data=None, errors=parse_errors)
            return CorrectionResult(
                corrected_yaml=raw_output,
                corrections=corrections,
                validation_result=validation_result,
                success=False,
            )

        assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

        # Add missing required fields
        if &#34;scenes&#34; not in data or not data[&#34;scenes&#34;]:
            data[&#34;scenes&#34;] = {
                &#34;scene_default&#34;: {
                    &#34;name&#34;: &#34;Default Scene&#34;,
                    &#34;description&#34;: self._extend_short_description(
                        &#34;A detailed description of this scene in the narrative, &#34;
                        &#34;providing context and atmosphere for the player.&#34;,
                        100,
                    ),
                    &#34;atmosphere&#34;: &#34;Atmospheric and immersive&#34;,
                    &#34;initial_text&#34;: &#34;You find yourself in this scene.&#34;,
                    &#34;examination_texts&#34;: {},
                    &#34;dialogue&#34;: [],
                }
            }
            corrections.append(&#34;Added missing &#39;scenes&#39; field with minimal default&#34;)
            logger.info(&#34;Added missing &#39;scenes&#39; field&#34;)

        # Fix scene IDs and descriptions
        if &#34;scenes&#34; in data and isinstance(data[&#34;scenes&#34;], dict):
            fixed_scenes = {}
            for scene_id, scene in data[&#34;scenes&#34;].items():
                # Fix scene ID format
                fixed_id = self._fix_id_format(scene_id)
                if scene_id != fixed_id:
                    corrections.append(f&#34;Fixed scene ID format: &#39;{scene_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;)
                    logger.info(f&#34;Fixed scene ID: {scene_id} -&gt; {fixed_id}&#34;)

                if isinstance(scene, dict):
                    # Extend short descriptions (scene texts require 100 chars minimum)
                    if &#34;description&#34; in scene and len(scene[&#34;description&#34;]) &lt; 100:
                        original_desc = scene[&#34;description&#34;]
                        scene[&#34;description&#34;] = self._extend_short_description(
                            scene[&#34;description&#34;], 100
                        )
                        corrections.append(
                            f&#34;Extended short scene description (was {len(original_desc)} chars)&#34;
                        )
                        logger.info(
                            f&#34;Extended scene description from {len(original_desc)} &#34;
                            f&#34;to {len(scene[&#39;description&#39;])} chars&#34;
                        )

                    # Ensure required fields exist
                    if &#34;atmosphere&#34; not in scene:
                        scene[&#34;atmosphere&#34;] = &#34;Atmospheric and immersive&#34;
                        corrections.append(
                            f&#34;Added missing &#39;atmosphere&#39; field to scene &#39;{fixed_id}&#39;&#34;
                        )
                    elif len(scene[&#34;atmosphere&#34;]) &lt; 10:
                        original_atmo = scene[&#34;atmosphere&#34;]
                        scene[&#34;atmosphere&#34;] = self._extend_short_description(
                            scene[&#34;atmosphere&#34;], 10
                        )
                        corrections.append(
                            f&#34;Extended short &#39;atmosphere&#39; field in scene &#39;{fixed_id}&#39; &#34;
                            f&#34;(was {len(original_atmo)} chars)&#34;
                        )

                    if &#34;initial_text&#34; not in scene:
                        scene[&#34;initial_text&#34;] = &#34;You find yourself in this scene.&#34;
                        corrections.append(
                            f&#34;Added missing &#39;initial_text&#39; field to scene &#39;{fixed_id}&#39;&#34;
                        )
                    elif len(scene[&#34;initial_text&#34;]) &lt; 20:
                        original_text = scene[&#34;initial_text&#34;]
                        scene[&#34;initial_text&#34;] = self._extend_short_description(
                            scene[&#34;initial_text&#34;], 20
                        )
                        corrections.append(
                            f&#34;Extended short &#39;initial_text&#39; field in scene &#39;{fixed_id}&#39; &#34;
                            f&#34;(was {len(original_text)} chars)&#34;
                        )

                    if &#34;examination_texts&#34; not in scene:
                        scene[&#34;examination_texts&#34;] = {}
                        corrections.append(
                            f&#34;Added missing &#39;examination_texts&#39; field to scene &#39;{fixed_id}&#39;&#34;
                        )

                    if &#34;dialogue&#34; not in scene:
                        scene[&#34;dialogue&#34;] = []
                        corrections.append(f&#34;Added missing &#39;dialogue&#39; field to scene &#39;{fixed_id}&#39;&#34;)

                fixed_scenes[fixed_id] = scene

            data[&#34;scenes&#34;] = fixed_scenes

        # Convert back to YAML
        try:
            corrected_yaml = yaml.dump(
                data, default_flow_style=False, sort_keys=False, allow_unicode=True
            )
        except Exception as e:
            logger.error(f&#34;Error converting corrected data to YAML: {e}&#34;)
            validation_result = ValidationResult(
                valid=False, data=None, errors=[f&#34;Error converting to YAML: {e!s}&#34;]
            )
            return CorrectionResult(
                corrected_yaml=raw_output,
                corrections=corrections,
                validation_result=validation_result,
                success=False,
            )

        # Validate corrected output
        validation_result = self.validator.validate_scene_texts(corrected_yaml)

        logger.info(
            f&#34;Scene texts correction complete: {len(corrections)} corrections, &#34;
            f&#34;valid={validation_result.valid}&#34;
        )

        return CorrectionResult(
            corrected_yaml=corrected_yaml,
            corrections=corrections,
            validation_result=validation_result,
            success=validation_result.valid,
        )

    def correct_game_mechanics(self, raw_output: str) -&gt; CorrectionResult:
        &#34;&#34;&#34;Attempt to correct common errors in game mechanics YAML.

        Fixes:
            - Missing required fields (game_systems, game_state, technical_requirements)
            - Descriptions too short
            - YAML syntax errors

        Args:
            raw_output: Raw YAML string containing game mechanics data.

        Returns:
            CorrectionResult with corrected YAML, list of corrections,
            validation result, and success status.

        Example:
            &gt;&gt;&gt; corrector = OutputCorrector()
            &gt;&gt;&gt; result = corrector.correct_game_mechanics(invalid_mechanics_yaml)
            &gt;&gt;&gt; if result.success:
            ...     print(f&#34;Game mechanics corrected with {len(result.corrections)} changes&#34;)
        &#34;&#34;&#34;
        logger.info(&#34;Attempting to correct game mechanics YAML&#34;)
        corrections: list[str] = []

        # Parse YAML
        data, parse_errors = self._parse_yaml_safe(raw_output)
        if parse_errors:
            validation_result = ValidationResult(valid=False, data=None, errors=parse_errors)
            return CorrectionResult(
                corrected_yaml=raw_output,
                corrections=corrections,
                validation_result=validation_result,
                success=False,
            )

        assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

        # Add missing required fields
        if &#34;game_title&#34; not in data:
            data[&#34;game_title&#34;] = &#34;Untitled Game&#34;
            corrections.append(&#34;Added missing &#39;game_title&#39; field with default value&#34;)
            logger.info(&#34;Added missing &#39;game_title&#39; field&#34;)

        if &#34;game_systems&#34; not in data:
            data[&#34;game_systems&#34;] = {}
            corrections.append(&#34;Added missing &#39;game_systems&#39; field&#34;)
            logger.info(&#34;Added missing &#39;game_systems&#39; field&#34;)

        # Ensure game_systems has all required subsystems
        game_systems = data[&#34;game_systems&#34;]
        if not isinstance(game_systems, dict):
            game_systems = {}
            data[&#34;game_systems&#34;] = game_systems
            corrections.append(&#34;Converted &#39;game_systems&#39; to dictionary&#34;)

        if &#34;movement&#34; not in game_systems:
            game_systems[&#34;movement&#34;] = {
                &#34;description&#34;: self._extend_short_description(
                    &#34;Movement system for navigating the game world.&#34;, 50
                ),
                &#34;commands&#34;: [&#34;move&#34;],
                &#34;narrative_purpose&#34;: self._extend_short_description(
                    &#34;Allows players to explore and navigate the environment.&#34;, 50
                ),
            }
            corrections.append(&#34;Added missing &#39;movement&#39; system&#34;)
            logger.info(&#34;Added missing &#39;movement&#39; system&#34;)

        if &#34;inventory&#34; not in game_systems:
            game_systems[&#34;inventory&#34;] = {
                &#34;description&#34;: self._extend_short_description(
                    &#34;Inventory system for managing items and equipment.&#34;, 50
                ),
                &#34;capacity&#34;: 10,
                &#34;commands&#34;: [&#34;take&#34;, &#34;drop&#34;, &#34;use&#34;],
                &#34;narrative_purpose&#34;: self._extend_short_description(
                    &#34;Allows players to collect and manage resources.&#34;, 50
                ),
            }
            corrections.append(&#34;Added missing &#39;inventory&#39; system&#34;)
            logger.info(&#34;Added missing &#39;inventory&#39; system&#34;)

        if &#34;combat&#34; not in game_systems:
            game_systems[&#34;combat&#34;] = {
                &#34;description&#34;: self._extend_short_description(
                    &#34;Combat system for engaging with enemies and threats.&#34;, 50
                ),
                &#34;mechanics&#34;: [
                    {
                        &#34;name&#34;: &#34;Attack&#34;,
                        &#34;rules&#34;: &#34;Basic attack mechanic for engaging enemies in combat.&#34;,
                    }
                ],
                &#34;narrative_purpose&#34;: self._extend_short_description(
                    &#34;Provides challenge and conflict resolution.&#34;, 50
                ),
            }
            corrections.append(&#34;Added missing &#39;combat&#39; system&#34;)
            logger.info(&#34;Added missing &#39;combat&#39; system&#34;)

        if &#34;interaction&#34; not in game_systems:
            game_systems[&#34;interaction&#34;] = {
                &#34;description&#34;: self._extend_short_description(
                    &#34;Interaction system for engaging with the environment and NPCs.&#34;, 50
                ),
                &#34;commands&#34;: [&#34;examine&#34;, &#34;talk&#34;],
                &#34;narrative_purpose&#34;: self._extend_short_description(
                    &#34;Allows players to discover information and progress the story.&#34;, 50
                ),
            }
            corrections.append(&#34;Added missing &#39;interaction&#39; system&#34;)
            logger.info(&#34;Added missing &#39;interaction&#39; system&#34;)

        if &#34;game_state&#34; not in data:
            data[&#34;game_state&#34;] = {
                &#34;tracked_variables&#34;: [
                    {
                        &#34;variable&#34;: &#34;progress&#34;,
                        &#34;purpose&#34;: &#34;Tracks player progress through the game.&#34;,
                    }
                ],
                &#34;win_conditions&#34;: [{&#34;condition&#34;: &#34;Successfully complete the primary objective.&#34;}],
                &#34;lose_conditions&#34;: [
                    {&#34;condition&#34;: &#34;Player character is defeated or incapacitated.&#34;}
                ],
            }
            corrections.append(&#34;Added missing &#39;game_state&#39; field with minimal defaults&#34;)
            logger.info(&#34;Added missing &#39;game_state&#39; field&#34;)

        if &#34;technical_requirements&#34; not in data or not data[&#34;technical_requirements&#34;]:
            data[&#34;technical_requirements&#34;] = [
                {
                    &#34;requirement&#34;: (
                        &#34;Basic game engine functionality for managing game state and logic.&#34;
                    ),
                    &#34;justification&#34;: &#34;Required for the game to function properly.&#34;,
                }
            ]
            corrections.append(&#34;Added missing &#39;technical_requirements&#39; field with minimal default&#34;)
            logger.info(&#34;Added missing &#39;technical_requirements&#39; field&#34;)

        # Convert back to YAML
        try:
            corrected_yaml = yaml.dump(
                data, default_flow_style=False, sort_keys=False, allow_unicode=True
            )
        except Exception as e:
            logger.error(f&#34;Error converting corrected data to YAML: {e}&#34;)
            validation_result = ValidationResult(
                valid=False, data=None, errors=[f&#34;Error converting to YAML: {e!s}&#34;]
            )
            return CorrectionResult(
                corrected_yaml=raw_output,
                corrections=corrections,
                validation_result=validation_result,
                success=False,
            )

        # Validate corrected output
        validation_result = self.validator.validate_game_mechanics(corrected_yaml)

        logger.info(
            f&#34;Game mechanics correction complete: {len(corrections)} corrections, &#34;
            f&#34;valid={validation_result.valid}&#34;
        )

        return CorrectionResult(
            corrected_yaml=corrected_yaml,
            corrections=corrections,
            validation_result=validation_result,
            success=validation_result.valid,
        )</code></pre>
              </details>
              <div class="desc">
                <p>Auto-corrector for YAML validation outputs.</p>
                <p>
                  This class provides methods to automatically fix common
                  validation errors in YAML outputs from AI agents. It attempts
                  to add missing required fields, fix syntax errors, normalize
                  field names, and correct ID format violations.
                </p>
                <h2 id="features">Features</h2>
                <ul>
                  <li>Fixes missing required fields with sensible defaults</li>
                  <li>Repairs common YAML syntax errors</li>
                  <li>
                    Normalizes field names (e.g., camelCase to snake_case)
                  </li>
                  <li>
                    Corrects ID format violations (lowercase, underscores,
                    alphanumeric)
                  </li>
                  <li>Logs all corrections transparently</li>
                  <li>Validates corrected output</li>
                </ul>
                <h2 id="example">Example</h2>
                <pre><code class="language-python-repl">&gt;&gt;&gt; corrector = OutputCorrector()
&gt;&gt;&gt; result = corrector.correct_plot(invalid_yaml_string)
&gt;&gt;&gt; if result.success:
...     print(f&quot;Corrections applied: {result.corrections}&quot;)
...     with open('output.yaml', 'w') as f:
...         f.write(result.corrected_yaml)
... else:
...     print(f&quot;Correction failed: {result.validation_result.errors}&quot;)
</code></pre>
                <p>
                  Initialize the output corrector with a validator instance.
                </p>
              </div>
              <h3>Methods</h3>
              <dl>
                <dt
                  id="space_hulk_game.validation.corrector.OutputCorrector.correct_game_mechanics"
                >
                  <code class="name flex">
                    <span
                      >def
                      <span class="ident">correct_game_mechanics</span></span
                    >(<span
                      >self, raw_output: str) ‑> <a
                        title="space_hulk_game.validation.corrector.CorrectionResult"
                        href="#space_hulk_game.validation.corrector.CorrectionResult"
                        >CorrectionResult</a
                      ></span
                    >
                  </code>
                </dt>
                <dd>
                  <details class="source">
                    <summary>
                      <span>Expand source code</span>
                    </summary>
                    <pre><code class="python">def correct_game_mechanics(self, raw_output: str) -&gt; CorrectionResult:
    &#34;&#34;&#34;Attempt to correct common errors in game mechanics YAML.

    Fixes:
        - Missing required fields (game_systems, game_state, technical_requirements)
        - Descriptions too short
        - YAML syntax errors

    Args:
        raw_output: Raw YAML string containing game mechanics data.

    Returns:
        CorrectionResult with corrected YAML, list of corrections,
        validation result, and success status.

    Example:
        &gt;&gt;&gt; corrector = OutputCorrector()
        &gt;&gt;&gt; result = corrector.correct_game_mechanics(invalid_mechanics_yaml)
        &gt;&gt;&gt; if result.success:
        ...     print(f&#34;Game mechanics corrected with {len(result.corrections)} changes&#34;)
    &#34;&#34;&#34;
    logger.info(&#34;Attempting to correct game mechanics YAML&#34;)
    corrections: list[str] = []

    # Parse YAML
    data, parse_errors = self._parse_yaml_safe(raw_output)
    if parse_errors:
        validation_result = ValidationResult(valid=False, data=None, errors=parse_errors)
        return CorrectionResult(
            corrected_yaml=raw_output,
            corrections=corrections,
            validation_result=validation_result,
            success=False,
        )

    assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

    # Add missing required fields
    if &#34;game_title&#34; not in data:
        data[&#34;game_title&#34;] = &#34;Untitled Game&#34;
        corrections.append(&#34;Added missing &#39;game_title&#39; field with default value&#34;)
        logger.info(&#34;Added missing &#39;game_title&#39; field&#34;)

    if &#34;game_systems&#34; not in data:
        data[&#34;game_systems&#34;] = {}
        corrections.append(&#34;Added missing &#39;game_systems&#39; field&#34;)
        logger.info(&#34;Added missing &#39;game_systems&#39; field&#34;)

    # Ensure game_systems has all required subsystems
    game_systems = data[&#34;game_systems&#34;]
    if not isinstance(game_systems, dict):
        game_systems = {}
        data[&#34;game_systems&#34;] = game_systems
        corrections.append(&#34;Converted &#39;game_systems&#39; to dictionary&#34;)

    if &#34;movement&#34; not in game_systems:
        game_systems[&#34;movement&#34;] = {
            &#34;description&#34;: self._extend_short_description(
                &#34;Movement system for navigating the game world.&#34;, 50
            ),
            &#34;commands&#34;: [&#34;move&#34;],
            &#34;narrative_purpose&#34;: self._extend_short_description(
                &#34;Allows players to explore and navigate the environment.&#34;, 50
            ),
        }
        corrections.append(&#34;Added missing &#39;movement&#39; system&#34;)
        logger.info(&#34;Added missing &#39;movement&#39; system&#34;)

    if &#34;inventory&#34; not in game_systems:
        game_systems[&#34;inventory&#34;] = {
            &#34;description&#34;: self._extend_short_description(
                &#34;Inventory system for managing items and equipment.&#34;, 50
            ),
            &#34;capacity&#34;: 10,
            &#34;commands&#34;: [&#34;take&#34;, &#34;drop&#34;, &#34;use&#34;],
            &#34;narrative_purpose&#34;: self._extend_short_description(
                &#34;Allows players to collect and manage resources.&#34;, 50
            ),
        }
        corrections.append(&#34;Added missing &#39;inventory&#39; system&#34;)
        logger.info(&#34;Added missing &#39;inventory&#39; system&#34;)

    if &#34;combat&#34; not in game_systems:
        game_systems[&#34;combat&#34;] = {
            &#34;description&#34;: self._extend_short_description(
                &#34;Combat system for engaging with enemies and threats.&#34;, 50
            ),
            &#34;mechanics&#34;: [
                {
                    &#34;name&#34;: &#34;Attack&#34;,
                    &#34;rules&#34;: &#34;Basic attack mechanic for engaging enemies in combat.&#34;,
                }
            ],
            &#34;narrative_purpose&#34;: self._extend_short_description(
                &#34;Provides challenge and conflict resolution.&#34;, 50
            ),
        }
        corrections.append(&#34;Added missing &#39;combat&#39; system&#34;)
        logger.info(&#34;Added missing &#39;combat&#39; system&#34;)

    if &#34;interaction&#34; not in game_systems:
        game_systems[&#34;interaction&#34;] = {
            &#34;description&#34;: self._extend_short_description(
                &#34;Interaction system for engaging with the environment and NPCs.&#34;, 50
            ),
            &#34;commands&#34;: [&#34;examine&#34;, &#34;talk&#34;],
            &#34;narrative_purpose&#34;: self._extend_short_description(
                &#34;Allows players to discover information and progress the story.&#34;, 50
            ),
        }
        corrections.append(&#34;Added missing &#39;interaction&#39; system&#34;)
        logger.info(&#34;Added missing &#39;interaction&#39; system&#34;)

    if &#34;game_state&#34; not in data:
        data[&#34;game_state&#34;] = {
            &#34;tracked_variables&#34;: [
                {
                    &#34;variable&#34;: &#34;progress&#34;,
                    &#34;purpose&#34;: &#34;Tracks player progress through the game.&#34;,
                }
            ],
            &#34;win_conditions&#34;: [{&#34;condition&#34;: &#34;Successfully complete the primary objective.&#34;}],
            &#34;lose_conditions&#34;: [
                {&#34;condition&#34;: &#34;Player character is defeated or incapacitated.&#34;}
            ],
        }
        corrections.append(&#34;Added missing &#39;game_state&#39; field with minimal defaults&#34;)
        logger.info(&#34;Added missing &#39;game_state&#39; field&#34;)

    if &#34;technical_requirements&#34; not in data or not data[&#34;technical_requirements&#34;]:
        data[&#34;technical_requirements&#34;] = [
            {
                &#34;requirement&#34;: (
                    &#34;Basic game engine functionality for managing game state and logic.&#34;
                ),
                &#34;justification&#34;: &#34;Required for the game to function properly.&#34;,
            }
        ]
        corrections.append(&#34;Added missing &#39;technical_requirements&#39; field with minimal default&#34;)
        logger.info(&#34;Added missing &#39;technical_requirements&#39; field&#34;)

    # Convert back to YAML
    try:
        corrected_yaml = yaml.dump(
            data, default_flow_style=False, sort_keys=False, allow_unicode=True
        )
    except Exception as e:
        logger.error(f&#34;Error converting corrected data to YAML: {e}&#34;)
        validation_result = ValidationResult(
            valid=False, data=None, errors=[f&#34;Error converting to YAML: {e!s}&#34;]
        )
        return CorrectionResult(
            corrected_yaml=raw_output,
            corrections=corrections,
            validation_result=validation_result,
            success=False,
        )

    # Validate corrected output
    validation_result = self.validator.validate_game_mechanics(corrected_yaml)

    logger.info(
        f&#34;Game mechanics correction complete: {len(corrections)} corrections, &#34;
        f&#34;valid={validation_result.valid}&#34;
    )

    return CorrectionResult(
        corrected_yaml=corrected_yaml,
        corrections=corrections,
        validation_result=validation_result,
        success=validation_result.valid,
    )</code></pre>
                  </details>
                  <div class="desc">
                    <p>
                      Attempt to correct common errors in game mechanics YAML.
                    </p>
                    <h2 id="fixes">Fixes</h2>
                    <ul>
                      <li>
                        Missing required fields (game_systems, game_state,
                        technical_requirements)
                      </li>
                      <li>Descriptions too short</li>
                      <li>YAML syntax errors</li>
                    </ul>
                    <h2 id="args">Args</h2>
                    <dl>
                      <dt>
                        <strong><code>raw_output</code></strong>
                      </dt>
                      <dd>Raw YAML string containing game mechanics data.</dd>
                    </dl>
                    <h2 id="returns">Returns</h2>
                    <p>
                      CorrectionResult with corrected YAML, list of corrections,
                      validation result, and success status.
                    </p>
                    <h2 id="example">Example</h2>
                    <pre><code class="language-python-repl">&gt;&gt;&gt; corrector = OutputCorrector()
&gt;&gt;&gt; result = corrector.correct_game_mechanics(invalid_mechanics_yaml)
&gt;&gt;&gt; if result.success:
...     print(f&quot;Game mechanics corrected with {len(result.corrections)} changes&quot;)
</code></pre>
                  </div>
                </dd>
                <dt
                  id="space_hulk_game.validation.corrector.OutputCorrector.correct_narrative_map"
                >
                  <code class="name flex">
                    <span
                      >def
                      <span class="ident">correct_narrative_map</span></span
                    >(<span
                      >self, raw_output: str) ‑> <a
                        title="space_hulk_game.validation.corrector.CorrectionResult"
                        href="#space_hulk_game.validation.corrector.CorrectionResult"
                        >CorrectionResult</a
                      ></span
                    >
                  </code>
                </dt>
                <dd>
                  <details class="source">
                    <summary>
                      <span>Expand source code</span>
                    </summary>
                    <pre><code class="python">def correct_narrative_map(self, raw_output: str) -&gt; CorrectionResult:
    &#34;&#34;&#34;Attempt to correct common errors in narrative map YAML.

    Fixes:
        - Missing required fields (start_scene, scenes)
        - Invalid ID formats
        - Descriptions too short
        - YAML syntax errors

    Args:
        raw_output: Raw YAML string containing narrative map data.

    Returns:
        CorrectionResult with corrected YAML, list of corrections,
        validation result, and success status.

    Example:
        &gt;&gt;&gt; corrector = OutputCorrector()
        &gt;&gt;&gt; result = corrector.correct_narrative_map(invalid_map_yaml)
        &gt;&gt;&gt; if result.success:
        ...     print(f&#34;Map corrected with {len(result.corrections)} changes&#34;)
    &#34;&#34;&#34;
    logger.info(&#34;Attempting to correct narrative map YAML&#34;)
    corrections: list[str] = []

    # Parse YAML
    data, parse_errors = self._parse_yaml_safe(raw_output)
    if parse_errors:
        validation_result = ValidationResult(valid=False, data=None, errors=parse_errors)
        return CorrectionResult(
            corrected_yaml=raw_output,
            corrections=corrections,
            validation_result=validation_result,
            success=False,
        )

    assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

    # Add missing required fields
    if &#34;scenes&#34; not in data or not data[&#34;scenes&#34;]:
        data[&#34;scenes&#34;] = {
            &#34;scene_default&#34;: {
                &#34;name&#34;: &#34;Default Scene&#34;,
                &#34;description&#34;: self._extend_short_description(
                    &#34;A default scene in the narrative.&#34;, 50
                ),
                &#34;connections&#34;: [],
            }
        }
        corrections.append(&#34;Added missing &#39;scenes&#39; field with minimal default&#34;)
        logger.info(&#34;Added missing &#39;scenes&#39; field&#34;)

    if &#34;start_scene&#34; not in data:
        # Use the first scene as the start scene
        if isinstance(data.get(&#34;scenes&#34;), dict) and data[&#34;scenes&#34;]:
            first_scene_id = next(iter(data[&#34;scenes&#34;].keys()))
            data[&#34;start_scene&#34;] = first_scene_id
            corrections.append(f&#34;Added missing &#39;start_scene&#39; field (set to &#39;{first_scene_id}&#39;)&#34;)
            logger.info(f&#34;Added missing &#39;start_scene&#39; field: {first_scene_id}&#34;)
        else:
            data[&#34;start_scene&#34;] = &#34;scene_default&#34;
            corrections.append(&#34;Added missing &#39;start_scene&#39; field with default value&#34;)
            logger.info(&#34;Added missing &#39;start_scene&#39; field&#34;)

    # Fix scene IDs and descriptions
    if &#34;scenes&#34; in data and isinstance(data[&#34;scenes&#34;], dict):
        fixed_scenes = {}
        for scene_id, scene in data[&#34;scenes&#34;].items():
            # Fix scene ID format
            fixed_id = self._fix_id_format(scene_id)
            if scene_id != fixed_id:
                corrections.append(f&#34;Fixed scene ID format: &#39;{scene_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;)
                logger.info(f&#34;Fixed scene ID: {scene_id} -&gt; {fixed_id}&#34;)
                # Update start_scene if it matches the old ID
                if data.get(&#34;start_scene&#34;) == scene_id:
                    data[&#34;start_scene&#34;] = fixed_id
                    corrections.append(f&#34;Updated &#39;start_scene&#39; to match fixed ID: &#39;{fixed_id}&#39;&#34;)

            if isinstance(scene, dict):
                # Extend short descriptions
                if &#34;description&#34; in scene and len(scene[&#34;description&#34;]) &lt; 50:
                    original_desc = scene[&#34;description&#34;]
                    scene[&#34;description&#34;] = self._extend_short_description(
                        scene[&#34;description&#34;], 50
                    )
                    corrections.append(
                        f&#34;Extended short scene description (was {len(original_desc)} chars)&#34;
                    )
                    logger.info(
                        f&#34;Extended scene description from {len(original_desc)} &#34;
                        f&#34;to {len(scene[&#39;description&#39;])} chars&#34;
                    )

                # Ensure connections is a list
                if &#34;connections&#34; not in scene:
                    scene[&#34;connections&#34;] = []
                    corrections.append(
                        f&#34;Added missing &#39;connections&#39; field to scene &#39;{fixed_id}&#39;&#34;
                    )

                # Fix connection target IDs
                if &#34;connections&#34; in scene and isinstance(scene[&#34;connections&#34;], list):
                    for conn in scene[&#34;connections&#34;]:
                        if isinstance(conn, dict) and &#34;target&#34; in conn:
                            original_target = conn[&#34;target&#34;]
                            fixed_target = self._fix_id_format(original_target)
                            if original_target != fixed_target:
                                conn[&#34;target&#34;] = fixed_target
                                corrections.append(
                                    f&#34;Fixed connection target ID: &#34;
                                    f&#34;&#39;{original_target}&#39; -&gt; &#39;{fixed_target}&#39;&#34;
                                )

            fixed_scenes[fixed_id] = scene

        data[&#34;scenes&#34;] = fixed_scenes

    # Convert back to YAML
    try:
        corrected_yaml = yaml.dump(
            data, default_flow_style=False, sort_keys=False, allow_unicode=True
        )
    except Exception as e:
        logger.error(f&#34;Error converting corrected data to YAML: {e}&#34;)
        validation_result = ValidationResult(
            valid=False, data=None, errors=[f&#34;Error converting to YAML: {e!s}&#34;]
        )
        return CorrectionResult(
            corrected_yaml=raw_output,
            corrections=corrections,
            validation_result=validation_result,
            success=False,
        )

    # Validate corrected output
    validation_result = self.validator.validate_narrative_map(corrected_yaml)

    logger.info(
        f&#34;Narrative map correction complete: {len(corrections)} corrections, &#34;
        f&#34;valid={validation_result.valid}&#34;
    )

    return CorrectionResult(
        corrected_yaml=corrected_yaml,
        corrections=corrections,
        validation_result=validation_result,
        success=validation_result.valid,
    )</code></pre>
                  </details>
                  <div class="desc">
                    <p>
                      Attempt to correct common errors in narrative map YAML.
                    </p>
                    <h2 id="fixes">Fixes</h2>
                    <ul>
                      <li>Missing required fields (start_scene, scenes)</li>
                      <li>Invalid ID formats</li>
                      <li>Descriptions too short</li>
                      <li>YAML syntax errors</li>
                    </ul>
                    <h2 id="args">Args</h2>
                    <dl>
                      <dt>
                        <strong><code>raw_output</code></strong>
                      </dt>
                      <dd>Raw YAML string containing narrative map data.</dd>
                    </dl>
                    <h2 id="returns">Returns</h2>
                    <p>
                      CorrectionResult with corrected YAML, list of corrections,
                      validation result, and success status.
                    </p>
                    <h2 id="example">Example</h2>
                    <pre><code class="language-python-repl">&gt;&gt;&gt; corrector = OutputCorrector()
&gt;&gt;&gt; result = corrector.correct_narrative_map(invalid_map_yaml)
&gt;&gt;&gt; if result.success:
...     print(f&quot;Map corrected with {len(result.corrections)} changes&quot;)
</code></pre>
                  </div>
                </dd>
                <dt
                  id="space_hulk_game.validation.corrector.OutputCorrector.correct_plot"
                >
                  <code class="name flex">
                    <span>def <span class="ident">correct_plot</span></span
                    >(<span
                      >self, raw_output: str) ‑> <a
                        title="space_hulk_game.validation.corrector.CorrectionResult"
                        href="#space_hulk_game.validation.corrector.CorrectionResult"
                        >CorrectionResult</a
                      ></span
                    >
                  </code>
                </dt>
                <dd>
                  <details class="source">
                    <summary>
                      <span>Expand source code</span>
                    </summary>
                    <pre><code class="python">def correct_plot(self, raw_output: str) -&gt; CorrectionResult:
    &#34;&#34;&#34;Attempt to correct common errors in plot outline YAML.

    Fixes:
        - Missing required fields (plot_points, characters, conflicts)
        - Invalid ID formats
        - Descriptions too short
        - YAML syntax errors

    Args:
        raw_output: Raw YAML string containing plot outline data.

    Returns:
        CorrectionResult with corrected YAML, list of corrections,
        validation result, and success status.

    Example:
        &gt;&gt;&gt; corrector = OutputCorrector()
        &gt;&gt;&gt; result = corrector.correct_plot(invalid_plot_yaml)
        &gt;&gt;&gt; if result.success:
        ...     print(f&#34;Plot corrected with {len(result.corrections)} changes&#34;)
    &#34;&#34;&#34;
    logger.info(&#34;Attempting to correct plot outline YAML&#34;)
    corrections: list[str] = []

    # Parse YAML
    data, parse_errors = self._parse_yaml_safe(raw_output)
    if parse_errors:
        # Can&#39;t fix unparseable YAML beyond basic syntax fixes already attempted
        validation_result = ValidationResult(valid=False, data=None, errors=parse_errors)
        return CorrectionResult(
            corrected_yaml=raw_output,
            corrections=corrections,
            validation_result=validation_result,
            success=False,
        )

    # Type guard: data is guaranteed to be dict here
    assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

    # Add missing required fields
    if &#34;title&#34; not in data:
        data[&#34;title&#34;] = &#34;Untitled Plot&#34;
        corrections.append(&#34;Added missing &#39;title&#39; field with default value&#34;)
        logger.info(&#34;Added missing &#39;title&#39; field&#34;)

    if &#34;setting&#34; not in data:
        data[&#34;setting&#34;] = self._extend_short_description(
            &#34;A dark and atmospheric setting for the narrative.&#34;, 50
        )
        corrections.append(&#34;Added missing &#39;setting&#39; field with default value&#34;)
        logger.info(&#34;Added missing &#39;setting&#39; field&#34;)
    elif len(data[&#34;setting&#34;]) &lt; 50:
        original_setting = data[&#34;setting&#34;]
        data[&#34;setting&#34;] = self._extend_short_description(data[&#34;setting&#34;], 50)
        corrections.append(
            f&#34;Extended short &#39;setting&#39; field (was {len(original_setting)} chars)&#34;
        )
        logger.info(&#34;Extended &#39;setting&#39; field&#34;)

    if &#34;themes&#34; not in data or not data[&#34;themes&#34;]:
        data[&#34;themes&#34;] = [&#34;survival&#34;, &#34;conflict&#34;]
        corrections.append(&#34;Added missing &#39;themes&#39; field with default values&#34;)
        logger.info(&#34;Added missing &#39;themes&#39; field&#34;)

    if &#34;tone&#34; not in data:
        data[&#34;tone&#34;] = &#34;Dark and atmospheric&#34;
        corrections.append(&#34;Added missing &#39;tone&#39; field with default value&#34;)
        logger.info(&#34;Added missing &#39;tone&#39; field&#34;)
    elif len(data[&#34;tone&#34;]) &lt; 10:
        original_tone = data[&#34;tone&#34;]
        data[&#34;tone&#34;] = self._extend_short_description(data[&#34;tone&#34;], 10)
        corrections.append(f&#34;Extended short &#39;tone&#39; field (was {len(original_tone)} chars)&#34;)
        logger.info(&#34;Extended &#39;tone&#39; field&#34;)

    if &#34;plot_points&#34; not in data or not data[&#34;plot_points&#34;]:
        data[&#34;plot_points&#34;] = [
            {
                &#34;id&#34;: &#34;pp_01_opening&#34;,
                &#34;name&#34;: &#34;Opening&#34;,
                &#34;description&#34;: self._extend_short_description(
                    &#34;The story begins with the initial situation.&#34;, 50
                ),
            },
            {
                &#34;id&#34;: &#34;pp_02_development&#34;,
                &#34;name&#34;: &#34;Development&#34;,
                &#34;description&#34;: self._extend_short_description(
                    &#34;The plot develops as events unfold.&#34;, 50
                ),
            },
            {
                &#34;id&#34;: &#34;pp_03_conclusion&#34;,
                &#34;name&#34;: &#34;Conclusion&#34;,
                &#34;description&#34;: self._extend_short_description(
                    &#34;The story reaches its conclusion and resolution.&#34;, 50
                ),
            },
        ]
        corrections.append(&#34;Added missing &#39;plot_points&#39; field with minimal defaults&#34;)
        logger.info(&#34;Added missing &#39;plot_points&#39; field&#34;)

    if &#34;characters&#34; not in data or not data[&#34;characters&#34;]:
        data[&#34;characters&#34;] = [
            {
                &#34;name&#34;: &#34;Protagonist&#34;,
                &#34;role&#34;: &#34;Main character&#34;,
                &#34;backstory&#34;: self._extend_short_description(
                    &#34;The protagonist&#39;s background and history.&#34;, 50
                ),
            }
        ]
        corrections.append(&#34;Added missing &#39;characters&#39; field with minimal default&#34;)
        logger.info(&#34;Added missing &#39;characters&#39; field&#34;)

    if &#34;conflicts&#34; not in data or not data[&#34;conflicts&#34;]:
        data[&#34;conflicts&#34;] = [
            {
                &#34;type&#34;: &#34;Main Conflict&#34;,
                &#34;description&#34;: self._extend_short_description(
                    &#34;The primary conflict driving the narrative.&#34;, 50
                ),
            }
        ]
        corrections.append(&#34;Added missing &#39;conflicts&#39; field with minimal default&#34;)
        logger.info(&#34;Added missing &#39;conflicts&#39; field&#34;)

    # Fix plot point IDs and descriptions
    if &#34;plot_points&#34; in data and isinstance(data[&#34;plot_points&#34;], list):
        for _i, pp in enumerate(data[&#34;plot_points&#34;]):
            if isinstance(pp, dict):
                # Fix ID format
                if &#34;id&#34; in pp:
                    original_id = pp[&#34;id&#34;]
                    fixed_id = self._fix_id_format(original_id)
                    if original_id != fixed_id:
                        pp[&#34;id&#34;] = fixed_id
                        corrections.append(
                            f&#34;Fixed plot point ID format: &#39;{original_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;
                        )
                        logger.info(f&#34;Fixed plot point ID: {original_id} -&gt; {fixed_id}&#34;)

                # Extend short descriptions
                if &#34;description&#34; in pp and len(pp[&#34;description&#34;]) &lt; 50:
                    original_desc = pp[&#34;description&#34;]
                    pp[&#34;description&#34;] = self._extend_short_description(pp[&#34;description&#34;], 50)
                    corrections.append(
                        f&#34;Extended short plot point description &#34;
                        f&#34;(was {len(original_desc)} chars)&#34;
                    )
                    logger.info(
                        f&#34;Extended plot point description from {len(original_desc)} &#34;
                        f&#34;to {len(pp[&#39;description&#39;])} chars&#34;
                    )

    # Fix character backstories
    if &#34;characters&#34; in data and isinstance(data[&#34;characters&#34;], list):
        for char in data[&#34;characters&#34;]:
            if isinstance(char, dict) and &#34;backstory&#34; in char and len(char[&#34;backstory&#34;]) &lt; 50:
                original_backstory = char[&#34;backstory&#34;]
                char[&#34;backstory&#34;] = self._extend_short_description(char[&#34;backstory&#34;], 50)
                corrections.append(
                    f&#34;Extended short character backstory (was {len(original_backstory)} chars)&#34;
                )
                logger.info(
                    f&#34;Extended character backstory from {len(original_backstory)} &#34;
                    f&#34;to {len(char[&#39;backstory&#39;])} chars&#34;
                )

    # Fix conflict descriptions
    if &#34;conflicts&#34; in data and isinstance(data[&#34;conflicts&#34;], list):
        for conflict in data[&#34;conflicts&#34;]:
            if (
                isinstance(conflict, dict)
                and &#34;description&#34; in conflict
                and len(conflict[&#34;description&#34;]) &lt; 50
            ):
                original_desc = conflict[&#34;description&#34;]
                conflict[&#34;description&#34;] = self._extend_short_description(
                    conflict[&#34;description&#34;], 50
                )
                corrections.append(
                    f&#34;Extended short conflict description (was {len(original_desc)} chars)&#34;
                )
                logger.info(
                    f&#34;Extended conflict description from {len(original_desc)} &#34;
                    f&#34;to {len(conflict[&#39;description&#39;])} chars&#34;
                )

    # Convert back to YAML
    try:
        corrected_yaml = yaml.dump(
            data, default_flow_style=False, sort_keys=False, allow_unicode=True
        )
    except Exception as e:
        logger.error(f&#34;Error converting corrected data to YAML: {e}&#34;)
        validation_result = ValidationResult(
            valid=False, data=None, errors=[f&#34;Error converting to YAML: {e!s}&#34;]
        )
        return CorrectionResult(
            corrected_yaml=raw_output,
            corrections=corrections,
            validation_result=validation_result,
            success=False,
        )

    # Validate corrected output
    validation_result = self.validator.validate_plot(corrected_yaml)

    logger.info(
        f&#34;Plot correction complete: {len(corrections)} corrections, &#34;
        f&#34;valid={validation_result.valid}&#34;
    )

    return CorrectionResult(
        corrected_yaml=corrected_yaml,
        corrections=corrections,
        validation_result=validation_result,
        success=validation_result.valid,
    )</code></pre>
                  </details>
                  <div class="desc">
                    <p>
                      Attempt to correct common errors in plot outline YAML.
                    </p>
                    <h2 id="fixes">Fixes</h2>
                    <ul>
                      <li>
                        Missing required fields (plot_points, characters,
                        conflicts)
                      </li>
                      <li>Invalid ID formats</li>
                      <li>Descriptions too short</li>
                      <li>YAML syntax errors</li>
                    </ul>
                    <h2 id="args">Args</h2>
                    <dl>
                      <dt>
                        <strong><code>raw_output</code></strong>
                      </dt>
                      <dd>Raw YAML string containing plot outline data.</dd>
                    </dl>
                    <h2 id="returns">Returns</h2>
                    <p>
                      CorrectionResult with corrected YAML, list of corrections,
                      validation result, and success status.
                    </p>
                    <h2 id="example">Example</h2>
                    <pre><code class="language-python-repl">&gt;&gt;&gt; corrector = OutputCorrector()
&gt;&gt;&gt; result = corrector.correct_plot(invalid_plot_yaml)
&gt;&gt;&gt; if result.success:
...     print(f&quot;Plot corrected with {len(result.corrections)} changes&quot;)
</code></pre>
                  </div>
                </dd>
                <dt
                  id="space_hulk_game.validation.corrector.OutputCorrector.correct_puzzle_design"
                >
                  <code class="name flex">
                    <span
                      >def
                      <span class="ident">correct_puzzle_design</span></span
                    >(<span
                      >self, raw_output: str) ‑> <a
                        title="space_hulk_game.validation.corrector.CorrectionResult"
                        href="#space_hulk_game.validation.corrector.CorrectionResult"
                        >CorrectionResult</a
                      ></span
                    >
                  </code>
                </dt>
                <dd>
                  <details class="source">
                    <summary>
                      <span>Expand source code</span>
                    </summary>
                    <pre><code class="python">def correct_puzzle_design(self, raw_output: str) -&gt; CorrectionResult:
    &#34;&#34;&#34;Attempt to correct common errors in puzzle design YAML.

    Fixes:
        - Missing required fields (puzzles, artifacts, monsters, npcs)
        - Invalid ID formats
        - Descriptions too short
        - YAML syntax errors

    Args:
        raw_output: Raw YAML string containing puzzle design data.

    Returns:
        CorrectionResult with corrected YAML, list of corrections,
        validation result, and success status.

    Example:
        &gt;&gt;&gt; corrector = OutputCorrector()
        &gt;&gt;&gt; result = corrector.correct_puzzle_design(invalid_puzzle_yaml)
        &gt;&gt;&gt; if result.success:
        ...     print(f&#34;Puzzle design corrected with {len(result.corrections)} changes&#34;)
    &#34;&#34;&#34;
    logger.info(&#34;Attempting to correct puzzle design YAML&#34;)
    corrections: list[str] = []

    # Parse YAML
    data, parse_errors = self._parse_yaml_safe(raw_output)
    if parse_errors:
        validation_result = ValidationResult(valid=False, data=None, errors=parse_errors)
        return CorrectionResult(
            corrected_yaml=raw_output,
            corrections=corrections,
            validation_result=validation_result,
            success=False,
        )

    assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

    # Add missing required fields
    if &#34;puzzles&#34; not in data or not data[&#34;puzzles&#34;]:
        data[&#34;puzzles&#34;] = [
            {
                &#34;id&#34;: &#34;puzzle_default&#34;,
                &#34;name&#34;: &#34;Default Puzzle&#34;,
                &#34;description&#34;: self._extend_short_description(
                    &#34;A puzzle in the game that requires solving.&#34;, 50
                ),
                &#34;location&#34;: &#34;scene_default&#34;,
                &#34;narrative_purpose&#34;: &#34;Provides a challenge for the player to overcome.&#34;,
                &#34;solution&#34;: {
                    &#34;type&#34;: &#34;multi-step&#34;,
                    &#34;steps&#34;: [{&#34;step&#34;: &#34;Complete the required actions to solve this puzzle.&#34;}],
                },
                &#34;difficulty&#34;: &#34;medium&#34;,
            }
        ]
        corrections.append(&#34;Added missing &#39;puzzles&#39; field with minimal default&#34;)
        logger.info(&#34;Added missing &#39;puzzles&#39; field&#34;)

    if &#34;artifacts&#34; not in data or not data[&#34;artifacts&#34;]:
        data[&#34;artifacts&#34;] = [
            {
                &#34;id&#34;: &#34;artifact_default&#34;,
                &#34;name&#34;: &#34;Default Artifact&#34;,
                &#34;description&#34;: &#34;An artifact found in the game world.&#34;,
                &#34;location&#34;: &#34;scene_default&#34;,
                &#34;narrative_significance&#34;: &#34;Holds narrative importance to the story.&#34;,
                &#34;properties&#34;: [{&#34;property&#34;: &#34;Has special properties or effects&#34;}],
            }
        ]
        corrections.append(&#34;Added missing &#39;artifacts&#39; field with minimal default&#34;)
        logger.info(&#34;Added missing &#39;artifacts&#39; field&#34;)

    if &#34;monsters&#34; not in data or not data[&#34;monsters&#34;]:
        data[&#34;monsters&#34;] = [
            {
                &#34;id&#34;: &#34;monster_default&#34;,
                &#34;name&#34;: &#34;Default Monster&#34;,
                &#34;description&#34;: &#34;A hostile entity encountered in the game.&#34;,
                &#34;locations&#34;: [&#34;scene_default&#34;],
                &#34;narrative_role&#34;: &#34;Provides combat challenge and threat.&#34;,
                &#34;abilities&#34;: [&#34;Attack&#34;],
            }
        ]
        corrections.append(&#34;Added missing &#39;monsters&#39; field with minimal default&#34;)
        logger.info(&#34;Added missing &#39;monsters&#39; field&#34;)

    if &#34;npcs&#34; not in data or not data[&#34;npcs&#34;]:
        data[&#34;npcs&#34;] = [
            {
                &#34;id&#34;: &#34;npc_default&#34;,
                &#34;name&#34;: &#34;Default NPC&#34;,
                &#34;role&#34;: &#34;Supporting character&#34;,
                &#34;description&#34;: &#34;A non-player character in the game.&#34;,
                &#34;locations&#34;: [&#34;scene_default&#34;],
                &#34;dialogue_themes&#34;: [&#34;General conversation&#34;],
            }
        ]
        corrections.append(&#34;Added missing &#39;npcs&#39; field with minimal default&#34;)
        logger.info(&#34;Added missing &#39;npcs&#39; field&#34;)

    # Fix puzzle IDs and descriptions
    if &#34;puzzles&#34; in data and isinstance(data[&#34;puzzles&#34;], list):
        for puzzle in data[&#34;puzzles&#34;]:
            if isinstance(puzzle, dict):
                # Fix ID format
                if &#34;id&#34; in puzzle:
                    original_id = puzzle[&#34;id&#34;]
                    fixed_id = self._fix_id_format(original_id)
                    if original_id != fixed_id:
                        puzzle[&#34;id&#34;] = fixed_id
                        corrections.append(
                            f&#34;Fixed puzzle ID format: &#39;{original_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;
                        )
                        logger.info(f&#34;Fixed puzzle ID: {original_id} -&gt; {fixed_id}&#34;)

                # Extend short descriptions
                if &#34;description&#34; in puzzle and len(puzzle[&#34;description&#34;]) &lt; 50:
                    original_desc = puzzle[&#34;description&#34;]
                    puzzle[&#34;description&#34;] = self._extend_short_description(
                        puzzle[&#34;description&#34;], 50
                    )
                    corrections.append(
                        f&#34;Extended short puzzle description (was {len(original_desc)} chars)&#34;
                    )

    # Fix artifact IDs
    if &#34;artifacts&#34; in data and isinstance(data[&#34;artifacts&#34;], list):
        for artifact in data[&#34;artifacts&#34;]:
            if isinstance(artifact, dict) and &#34;id&#34; in artifact:
                original_id = artifact[&#34;id&#34;]
                fixed_id = self._fix_id_format(original_id)
                if original_id != fixed_id:
                    artifact[&#34;id&#34;] = fixed_id
                    corrections.append(
                        f&#34;Fixed artifact ID format: &#39;{original_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;
                    )
                    logger.info(f&#34;Fixed artifact ID: {original_id} -&gt; {fixed_id}&#34;)

    # Fix monster IDs
    if &#34;monsters&#34; in data and isinstance(data[&#34;monsters&#34;], list):
        for monster in data[&#34;monsters&#34;]:
            if isinstance(monster, dict) and &#34;id&#34; in monster:
                original_id = monster[&#34;id&#34;]
                fixed_id = self._fix_id_format(original_id)
                if original_id != fixed_id:
                    monster[&#34;id&#34;] = fixed_id
                    corrections.append(
                        f&#34;Fixed monster ID format: &#39;{original_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;
                    )
                    logger.info(f&#34;Fixed monster ID: {original_id} -&gt; {fixed_id}&#34;)

    # Fix NPC IDs
    if &#34;npcs&#34; in data and isinstance(data[&#34;npcs&#34;], list):
        for npc in data[&#34;npcs&#34;]:
            if isinstance(npc, dict) and &#34;id&#34; in npc:
                original_id = npc[&#34;id&#34;]
                fixed_id = self._fix_id_format(original_id)
                if original_id != fixed_id:
                    npc[&#34;id&#34;] = fixed_id
                    corrections.append(f&#34;Fixed NPC ID format: &#39;{original_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;)
                    logger.info(f&#34;Fixed NPC ID: {original_id} -&gt; {fixed_id}&#34;)

    # Convert back to YAML
    try:
        corrected_yaml = yaml.dump(
            data, default_flow_style=False, sort_keys=False, allow_unicode=True
        )
    except Exception as e:
        logger.error(f&#34;Error converting corrected data to YAML: {e}&#34;)
        validation_result = ValidationResult(
            valid=False, data=None, errors=[f&#34;Error converting to YAML: {e!s}&#34;]
        )
        return CorrectionResult(
            corrected_yaml=raw_output,
            corrections=corrections,
            validation_result=validation_result,
            success=False,
        )

    # Validate corrected output
    validation_result = self.validator.validate_puzzle_design(corrected_yaml)

    logger.info(
        f&#34;Puzzle design correction complete: {len(corrections)} corrections, &#34;
        f&#34;valid={validation_result.valid}&#34;
    )

    return CorrectionResult(
        corrected_yaml=corrected_yaml,
        corrections=corrections,
        validation_result=validation_result,
        success=validation_result.valid,
    )</code></pre>
                  </details>
                  <div class="desc">
                    <p>
                      Attempt to correct common errors in puzzle design YAML.
                    </p>
                    <h2 id="fixes">Fixes</h2>
                    <ul>
                      <li>
                        Missing required fields (puzzles, artifacts, monsters,
                        npcs)
                      </li>
                      <li>Invalid ID formats</li>
                      <li>Descriptions too short</li>
                      <li>YAML syntax errors</li>
                    </ul>
                    <h2 id="args">Args</h2>
                    <dl>
                      <dt>
                        <strong><code>raw_output</code></strong>
                      </dt>
                      <dd>Raw YAML string containing puzzle design data.</dd>
                    </dl>
                    <h2 id="returns">Returns</h2>
                    <p>
                      CorrectionResult with corrected YAML, list of corrections,
                      validation result, and success status.
                    </p>
                    <h2 id="example">Example</h2>
                    <pre><code class="language-python-repl">&gt;&gt;&gt; corrector = OutputCorrector()
&gt;&gt;&gt; result = corrector.correct_puzzle_design(invalid_puzzle_yaml)
&gt;&gt;&gt; if result.success:
...     print(f&quot;Puzzle design corrected with {len(result.corrections)} changes&quot;)
</code></pre>
                  </div>
                </dd>
                <dt
                  id="space_hulk_game.validation.corrector.OutputCorrector.correct_scene_texts"
                >
                  <code class="name flex">
                    <span
                      >def <span class="ident">correct_scene_texts</span></span
                    >(<span
                      >self, raw_output: str) ‑> <a
                        title="space_hulk_game.validation.corrector.CorrectionResult"
                        href="#space_hulk_game.validation.corrector.CorrectionResult"
                        >CorrectionResult</a
                      ></span
                    >
                  </code>
                </dt>
                <dd>
                  <details class="source">
                    <summary>
                      <span>Expand source code</span>
                    </summary>
                    <pre><code class="python">def correct_scene_texts(self, raw_output: str) -&gt; CorrectionResult:
    &#34;&#34;&#34;Attempt to correct common errors in scene texts YAML.

    Fixes:
        - Missing required fields (scenes)
        - Invalid ID formats
        - Descriptions too short
        - YAML syntax errors

    Args:
        raw_output: Raw YAML string containing scene texts data.

    Returns:
        CorrectionResult with corrected YAML, list of corrections,
        validation result, and success status.

    Example:
        &gt;&gt;&gt; corrector = OutputCorrector()
        &gt;&gt;&gt; result = corrector.correct_scene_texts(invalid_scene_yaml)
        &gt;&gt;&gt; if result.success:
        ...     print(f&#34;Scene texts corrected with {len(result.corrections)} changes&#34;)
    &#34;&#34;&#34;
    logger.info(&#34;Attempting to correct scene texts YAML&#34;)
    corrections: list[str] = []

    # Parse YAML
    data, parse_errors = self._parse_yaml_safe(raw_output)
    if parse_errors:
        validation_result = ValidationResult(valid=False, data=None, errors=parse_errors)
        return CorrectionResult(
            corrected_yaml=raw_output,
            corrections=corrections,
            validation_result=validation_result,
            success=False,
        )

    assert data is not None, &#34;data should not be None when parse_errors is empty&#34;

    # Add missing required fields
    if &#34;scenes&#34; not in data or not data[&#34;scenes&#34;]:
        data[&#34;scenes&#34;] = {
            &#34;scene_default&#34;: {
                &#34;name&#34;: &#34;Default Scene&#34;,
                &#34;description&#34;: self._extend_short_description(
                    &#34;A detailed description of this scene in the narrative, &#34;
                    &#34;providing context and atmosphere for the player.&#34;,
                    100,
                ),
                &#34;atmosphere&#34;: &#34;Atmospheric and immersive&#34;,
                &#34;initial_text&#34;: &#34;You find yourself in this scene.&#34;,
                &#34;examination_texts&#34;: {},
                &#34;dialogue&#34;: [],
            }
        }
        corrections.append(&#34;Added missing &#39;scenes&#39; field with minimal default&#34;)
        logger.info(&#34;Added missing &#39;scenes&#39; field&#34;)

    # Fix scene IDs and descriptions
    if &#34;scenes&#34; in data and isinstance(data[&#34;scenes&#34;], dict):
        fixed_scenes = {}
        for scene_id, scene in data[&#34;scenes&#34;].items():
            # Fix scene ID format
            fixed_id = self._fix_id_format(scene_id)
            if scene_id != fixed_id:
                corrections.append(f&#34;Fixed scene ID format: &#39;{scene_id}&#39; -&gt; &#39;{fixed_id}&#39;&#34;)
                logger.info(f&#34;Fixed scene ID: {scene_id} -&gt; {fixed_id}&#34;)

            if isinstance(scene, dict):
                # Extend short descriptions (scene texts require 100 chars minimum)
                if &#34;description&#34; in scene and len(scene[&#34;description&#34;]) &lt; 100:
                    original_desc = scene[&#34;description&#34;]
                    scene[&#34;description&#34;] = self._extend_short_description(
                        scene[&#34;description&#34;], 100
                    )
                    corrections.append(
                        f&#34;Extended short scene description (was {len(original_desc)} chars)&#34;
                    )
                    logger.info(
                        f&#34;Extended scene description from {len(original_desc)} &#34;
                        f&#34;to {len(scene[&#39;description&#39;])} chars&#34;
                    )

                # Ensure required fields exist
                if &#34;atmosphere&#34; not in scene:
                    scene[&#34;atmosphere&#34;] = &#34;Atmospheric and immersive&#34;
                    corrections.append(
                        f&#34;Added missing &#39;atmosphere&#39; field to scene &#39;{fixed_id}&#39;&#34;
                    )
                elif len(scene[&#34;atmosphere&#34;]) &lt; 10:
                    original_atmo = scene[&#34;atmosphere&#34;]
                    scene[&#34;atmosphere&#34;] = self._extend_short_description(
                        scene[&#34;atmosphere&#34;], 10
                    )
                    corrections.append(
                        f&#34;Extended short &#39;atmosphere&#39; field in scene &#39;{fixed_id}&#39; &#34;
                        f&#34;(was {len(original_atmo)} chars)&#34;
                    )

                if &#34;initial_text&#34; not in scene:
                    scene[&#34;initial_text&#34;] = &#34;You find yourself in this scene.&#34;
                    corrections.append(
                        f&#34;Added missing &#39;initial_text&#39; field to scene &#39;{fixed_id}&#39;&#34;
                    )
                elif len(scene[&#34;initial_text&#34;]) &lt; 20:
                    original_text = scene[&#34;initial_text&#34;]
                    scene[&#34;initial_text&#34;] = self._extend_short_description(
                        scene[&#34;initial_text&#34;], 20
                    )
                    corrections.append(
                        f&#34;Extended short &#39;initial_text&#39; field in scene &#39;{fixed_id}&#39; &#34;
                        f&#34;(was {len(original_text)} chars)&#34;
                    )

                if &#34;examination_texts&#34; not in scene:
                    scene[&#34;examination_texts&#34;] = {}
                    corrections.append(
                        f&#34;Added missing &#39;examination_texts&#39; field to scene &#39;{fixed_id}&#39;&#34;
                    )

                if &#34;dialogue&#34; not in scene:
                    scene[&#34;dialogue&#34;] = []
                    corrections.append(f&#34;Added missing &#39;dialogue&#39; field to scene &#39;{fixed_id}&#39;&#34;)

            fixed_scenes[fixed_id] = scene

        data[&#34;scenes&#34;] = fixed_scenes

    # Convert back to YAML
    try:
        corrected_yaml = yaml.dump(
            data, default_flow_style=False, sort_keys=False, allow_unicode=True
        )
    except Exception as e:
        logger.error(f&#34;Error converting corrected data to YAML: {e}&#34;)
        validation_result = ValidationResult(
            valid=False, data=None, errors=[f&#34;Error converting to YAML: {e!s}&#34;]
        )
        return CorrectionResult(
            corrected_yaml=raw_output,
            corrections=corrections,
            validation_result=validation_result,
            success=False,
        )

    # Validate corrected output
    validation_result = self.validator.validate_scene_texts(corrected_yaml)

    logger.info(
        f&#34;Scene texts correction complete: {len(corrections)} corrections, &#34;
        f&#34;valid={validation_result.valid}&#34;
    )

    return CorrectionResult(
        corrected_yaml=corrected_yaml,
        corrections=corrections,
        validation_result=validation_result,
        success=validation_result.valid,
    )</code></pre>
                  </details>
                  <div class="desc">
                    <p>Attempt to correct common errors in scene texts YAML.</p>
                    <h2 id="fixes">Fixes</h2>
                    <ul>
                      <li>Missing required fields (scenes)</li>
                      <li>Invalid ID formats</li>
                      <li>Descriptions too short</li>
                      <li>YAML syntax errors</li>
                    </ul>
                    <h2 id="args">Args</h2>
                    <dl>
                      <dt>
                        <strong><code>raw_output</code></strong>
                      </dt>
                      <dd>Raw YAML string containing scene texts data.</dd>
                    </dl>
                    <h2 id="returns">Returns</h2>
                    <p>
                      CorrectionResult with corrected YAML, list of corrections,
                      validation result, and success status.
                    </p>
                    <h2 id="example">Example</h2>
                    <pre><code class="language-python-repl">&gt;&gt;&gt; corrector = OutputCorrector()
&gt;&gt;&gt; result = corrector.correct_scene_texts(invalid_scene_yaml)
&gt;&gt;&gt; if result.success:
...     print(f&quot;Scene texts corrected with {len(result.corrections)} changes&quot;)
</code></pre>
                  </div>
                </dd>
              </dl>
            </dd>
          </dl>
        </section>
      </article>
      <nav id="sidebar">
        <div class="toc">
          <ul></ul>
        </div>
        <ul id="index">
          <li>
            <h3>Super-module</h3>
            <ul>
              <li>
                <code
                  ><a title="space_hulk_game.validation" href="index.html"
                    >space_hulk_game.validation</a
                  ></code
                >
              </li>
            </ul>
          </li>
          <li>
            <h3><a href="#header-classes">Classes</a></h3>
            <ul>
              <li>
                <h4>
                  <code
                    ><a
                      title="space_hulk_game.validation.corrector.CorrectionResult"
                      href="#space_hulk_game.validation.corrector.CorrectionResult"
                      >CorrectionResult</a
                    ></code
                  >
                </h4>
                <ul class="">
                  <li>
                    <code
                      ><a
                        title="space_hulk_game.validation.corrector.CorrectionResult.corrected_yaml"
                        href="#space_hulk_game.validation.corrector.CorrectionResult.corrected_yaml"
                        >corrected_yaml</a
                      ></code
                    >
                  </li>
                  <li>
                    <code
                      ><a
                        title="space_hulk_game.validation.corrector.CorrectionResult.corrections"
                        href="#space_hulk_game.validation.corrector.CorrectionResult.corrections"
                        >corrections</a
                      ></code
                    >
                  </li>
                  <li>
                    <code
                      ><a
                        title="space_hulk_game.validation.corrector.CorrectionResult.success"
                        href="#space_hulk_game.validation.corrector.CorrectionResult.success"
                        >success</a
                      ></code
                    >
                  </li>
                  <li>
                    <code
                      ><a
                        title="space_hulk_game.validation.corrector.CorrectionResult.to_processing_result"
                        href="#space_hulk_game.validation.corrector.CorrectionResult.to_processing_result"
                        >to_processing_result</a
                      ></code
                    >
                  </li>
                  <li>
                    <code
                      ><a
                        title="space_hulk_game.validation.corrector.CorrectionResult.validation_result"
                        href="#space_hulk_game.validation.corrector.CorrectionResult.validation_result"
                        >validation_result</a
                      ></code
                    >
                  </li>
                </ul>
              </li>
              <li>
                <h4>
                  <code
                    ><a
                      title="space_hulk_game.validation.corrector.OutputCorrector"
                      href="#space_hulk_game.validation.corrector.OutputCorrector"
                      >OutputCorrector</a
                    ></code
                  >
                </h4>
                <ul class="">
                  <li>
                    <code
                      ><a
                        title="space_hulk_game.validation.corrector.OutputCorrector.correct_game_mechanics"
                        href="#space_hulk_game.validation.corrector.OutputCorrector.correct_game_mechanics"
                        >correct_game_mechanics</a
                      ></code
                    >
                  </li>
                  <li>
                    <code
                      ><a
                        title="space_hulk_game.validation.corrector.OutputCorrector.correct_narrative_map"
                        href="#space_hulk_game.validation.corrector.OutputCorrector.correct_narrative_map"
                        >correct_narrative_map</a
                      ></code
                    >
                  </li>
                  <li>
                    <code
                      ><a
                        title="space_hulk_game.validation.corrector.OutputCorrector.correct_plot"
                        href="#space_hulk_game.validation.corrector.OutputCorrector.correct_plot"
                        >correct_plot</a
                      ></code
                    >
                  </li>
                  <li>
                    <code
                      ><a
                        title="space_hulk_game.validation.corrector.OutputCorrector.correct_puzzle_design"
                        href="#space_hulk_game.validation.corrector.OutputCorrector.correct_puzzle_design"
                        >correct_puzzle_design</a
                      ></code
                    >
                  </li>
                  <li>
                    <code
                      ><a
                        title="space_hulk_game.validation.corrector.OutputCorrector.correct_scene_texts"
                        href="#space_hulk_game.validation.corrector.OutputCorrector.correct_scene_texts"
                        >correct_scene_texts</a
                      ></code
                    >
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
    </main>
    <footer id="footer">
      <p>
        Generated by
        <a
          href="https://pdoc3.github.io/pdoc"
          title="pdoc: Python API documentation generator"
          ><cite>pdoc</cite> 0.11.6</a
        >.
      </p>
    </footer>
  </body>
</html>
