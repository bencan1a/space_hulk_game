<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, minimum-scale=1"
    />
    <meta name="generator" content="pdoc3 0.11.6" />
    <title>space_hulk_game.engine.loader API documentation</title>
    <meta name="description" content="Content Loader Module …" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css"
      integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA=="
      crossorigin
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css"
      integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA=="
      crossorigin
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css"
      crossorigin
    />
    <style>
      :root {
        --highlight-color: #fe9;
      }
      .flex {
        display: flex !important;
      }
      body {
        line-height: 1.5em;
      }
      #content {
        padding: 20px;
      }
      #sidebar {
        padding: 1.5em;
        overflow: hidden;
      }
      #sidebar > *:last-child {
        margin-bottom: 2cm;
      }
      .http-server-breadcrumbs {
        font-size: 130%;
        margin: 0 0 15px 0;
      }
      #footer {
        font-size: 0.75em;
        padding: 5px 30px;
        border-top: 1px solid #ddd;
        text-align: right;
      }
      #footer p {
        margin: 0 0 0 1em;
        display: inline-block;
      }
      #footer p:last-child {
        margin-right: 30px;
      }
      h1,
      h2,
      h3,
      h4,
      h5 {
        font-weight: 300;
      }
      h1 {
        font-size: 2.5em;
        line-height: 1.1em;
      }
      h2 {
        font-size: 1.75em;
        margin: 2em 0 0.5em 0;
      }
      h3 {
        font-size: 1.4em;
        margin: 1.6em 0 0.7em 0;
      }
      h4 {
        margin: 0;
        font-size: 105%;
      }
      h1:target,
      h2:target,
      h3:target,
      h4:target,
      h5:target,
      h6:target {
        background: var(--highlight-color);
        padding: 0.2em 0;
      }
      a {
        color: #058;
        text-decoration: none;
        transition: color 0.2s ease-in-out;
      }
      a:visited {
        color: #503;
      }
      a:hover {
        color: #b62;
      }
      .title code {
        font-weight: bold;
      }
      h2[id^="header-"] {
        margin-top: 2em;
      }
      .ident {
        color: #900;
        font-weight: bold;
      }
      pre code {
        font-size: 0.8em;
        line-height: 1.4em;
        padding: 1em;
        display: block;
      }
      code {
        background: #f3f3f3;
        font-family: "DejaVu Sans Mono", monospace;
        padding: 1px 4px;
        overflow-wrap: break-word;
      }
      h1 code {
        background: transparent;
      }
      pre {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        margin: 1em 0;
      }
      #http-server-module-list {
        display: flex;
        flex-flow: column;
      }
      #http-server-module-list div {
        display: flex;
      }
      #http-server-module-list dt {
        min-width: 10%;
      }
      #http-server-module-list p {
        margin-top: 0;
      }
      .toc ul,
      #index {
        list-style-type: none;
        margin: 0;
        padding: 0;
      }
      #index code {
        background: transparent;
      }
      #index h3 {
        border-bottom: 1px solid #ddd;
      }
      #index ul {
        padding: 0;
      }
      #index h4 {
        margin-top: 0.6em;
        font-weight: bold;
      }
      @media (min-width: 200ex) {
        #index .two-column {
          column-count: 2;
        }
      }
      @media (min-width: 300ex) {
        #index .two-column {
          column-count: 3;
        }
      }
      dl {
        margin-bottom: 2em;
      }
      dl dl:last-child {
        margin-bottom: 4em;
      }
      dd {
        margin: 0 0 1em 3em;
      }
      #header-classes + dl > dd {
        margin-bottom: 3em;
      }
      dd dd {
        margin-left: 2em;
      }
      dd p {
        margin: 10px 0;
      }
      .name {
        background: #eee;
        font-size: 0.85em;
        padding: 5px 10px;
        display: inline-block;
        min-width: 40%;
      }
      .name:hover {
        background: #e0e0e0;
      }
      dt:target .name {
        background: var(--highlight-color);
      }
      .name > span:first-child {
        white-space: nowrap;
      }
      .name.class > span:nth-child(2) {
        margin-left: 0.4em;
      }
      .inherited {
        color: #999;
        border-left: 5px solid #eee;
        padding-left: 1em;
      }
      .inheritance em {
        font-style: normal;
        font-weight: bold;
      }
      .desc h2 {
        font-weight: 400;
        font-size: 1.25em;
      }
      .desc h3 {
        font-size: 1em;
      }
      .desc dt code {
        background: inherit;
      }
      .source > summary,
      .git-link-div {
        color: #666;
        text-align: right;
        font-weight: 400;
        font-size: 0.8em;
        text-transform: uppercase;
      }
      .source summary > * {
        white-space: nowrap;
        cursor: pointer;
      }
      .git-link {
        color: inherit;
        margin-left: 1em;
      }
      .source pre {
        max-height: 500px;
        overflow: auto;
        margin: 0;
      }
      .source pre code {
        font-size: 12px;
        overflow: visible;
        min-width: max-content;
      }
      .hlist {
        list-style: none;
      }
      .hlist li {
        display: inline;
      }
      .hlist li:after {
        content: ",\2002";
      }
      .hlist li:last-child:after {
        content: none;
      }
      .hlist .hlist {
        display: inline;
        padding-left: 1em;
      }
      img {
        max-width: 100%;
      }
      td {
        padding: 0 0.5em;
      }
      .admonition {
        padding: 0.1em 1em;
        margin: 1em 0;
      }
      .admonition-title {
        font-weight: bold;
      }
      .admonition.note,
      .admonition.info,
      .admonition.important {
        background: #aef;
      }
      .admonition.todo,
      .admonition.versionadded,
      .admonition.tip,
      .admonition.hint {
        background: #dfd;
      }
      .admonition.warning,
      .admonition.versionchanged,
      .admonition.deprecated {
        background: #fd4;
      }
      .admonition.error,
      .admonition.danger,
      .admonition.caution {
        background: lightpink;
      }
    </style>
    <style media="screen and (min-width: 700px)">
      @media screen and (min-width: 700px) {
        #sidebar {
          width: 30%;
          height: 100vh;
          overflow: auto;
          position: sticky;
          top: 0;
        }
        #content {
          width: 70%;
          max-width: 100ch;
          padding: 3em 4em;
          border-left: 1px solid #ddd;
        }
        pre code {
          font-size: 1em;
        }
        .name {
          font-size: 1em;
        }
        main {
          display: flex;
          flex-direction: row-reverse;
          justify-content: flex-end;
        }
        .toc ul ul,
        #index ul ul {
          padding-left: 1em;
        }
        .toc > ul > li {
          margin-top: 0.5em;
        }
      }
    </style>
    <style media="print">
      @media print {
        #sidebar h1 {
          page-break-before: always;
        }
        .source {
          display: none;
        }
      }
      @media print {
        * {
          background: transparent !important;
          color: #000 !important;
          box-shadow: none !important;
          text-shadow: none !important;
        }
        a[href]:after {
          content: " (" attr(href) ")";
          font-size: 90%;
        }
        a[href][title]:after {
          content: none;
        }
        abbr[title]:after {
          content: " (" attr(title) ")";
        }
        .ir a:after,
        a[href^="javascript:"]:after,
        a[href^="#"]:after {
          content: "";
        }
        pre,
        blockquote {
          border: 1px solid #999;
          page-break-inside: avoid;
        }
        thead {
          display: table-header-group;
        }
        tr,
        img {
          page-break-inside: avoid;
        }
        img {
          max-width: 100% !important;
        }
        @page {
          margin: 0.5cm;
        }
        p,
        h2,
        h3 {
          orphans: 3;
          widows: 3;
        }
        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
          page-break-after: avoid;
        }
      }
    </style>
    <script
      defer
      src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"
      integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ=="
      crossorigin
    ></script>
    <script>
      window.addEventListener("DOMContentLoaded", () => {
        hljs.configure({
          languages: [
            "bash",
            "css",
            "diff",
            "graphql",
            "ini",
            "javascript",
            "json",
            "plaintext",
            "python",
            "python-repl",
            "rust",
            "shell",
            "sql",
            "typescript",
            "xml",
            "yaml",
          ],
        });
        hljs.highlightAll();
        /* Collapse source docstrings */
        setTimeout(() => {
          [...document.querySelectorAll(".hljs.language-python > .hljs-string")]
            .filter(
              (el) =>
                el.innerHTML.length > 200 &&
                ['"""', "'''"].includes(el.innerHTML.substring(0, 3)),
            )
            .forEach((el) => {
              let d = document.createElement("details");
              d.classList.add("hljs-string");
              d.innerHTML =
                '<summary>"""</summary>' + el.innerHTML.substring(3);
              el.replaceWith(d);
            });
        }, 100);
      });
    </script>
  </head>
  <body>
    <main>
      <article id="content">
        <header>
          <h1 class="title">
            Module <code>space_hulk_game.engine.loader</code>
          </h1>
        </header>
        <section id="section-intro">
          <p>Content Loader Module</p>
          <p>
            Loads and converts AI-generated JSON files into playable game
            format. This is the bridge between CrewAI agent outputs and the game
            engine.
          </p>
          <p>
            The ContentLoader handles: - Loading 5 JSON files (plot, narrative,
            puzzles, scenes, mechanics) - Parsing JSON with error handling for
            common AI output issues - Converting JSON structures to
            engine-compatible objects (Scene, Item, NPC, etc.) - Merging content
            from multiple files into a cohesive GameData structure - Graceful
            handling of missing or malformed data
          </p>
          <h2 id="example">Example</h2>
          <pre><code class="language-python-repl">&gt;&gt;&gt; from space_hulk_game.engine import ContentLoader
&gt;&gt;&gt; loader = ContentLoader()
&gt;&gt;&gt; game_data = loader.load_game(&quot;game-config/&quot;)
&gt;&gt;&gt; print(game_data.title)
</code></pre>
        </section>
        <section></section>
        <section></section>
        <section></section>
        <section>
          <h2 class="section-title" id="header-classes">Classes</h2>
          <dl>
            <dt id="space_hulk_game.engine.loader.ContentLoader">
              <code class="flex name class">
                <span>class <span class="ident">ContentLoader</span></span>
                <span>(</span><span>strict_mode: bool = False)</span>
              </code>
            </dt>
            <dd>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">class ContentLoader:
    &#34;&#34;&#34;
    Loads AI-generated JSON files and converts them into GameData.

    The ContentLoader implements a Facade pattern to simplify the complex process
    of loading and merging multiple JSON files. It uses Strategy pattern internally
    for handling different file formats and Builder pattern for constructing GameData.

    Attributes:
        strict_mode: If True, raises exceptions on validation errors.
                    If False, logs warnings and uses defaults.

    Examples:
        Load a complete game:
        &gt;&gt;&gt; loader = ContentLoader()
        &gt;&gt;&gt; game_data = loader.load_game(&#34;game-config/&#34;)
        &gt;&gt;&gt; print(f&#34;Loaded: {game_data.title}&#34;)

        Load with lenient error handling:
        &gt;&gt;&gt; loader = ContentLoader(strict_mode=False)
        &gt;&gt;&gt; game_data = loader.load_game(&#34;game-config/&#34;)

        Load individual files:
        &gt;&gt;&gt; plot_data = loader.load_json(&#34;game-config/plot_outline.json&#34;)
    &#34;&#34;&#34;

    def __init__(self, strict_mode: bool = False):
        &#34;&#34;&#34;
        Initialize the ContentLoader.

        Args:
            strict_mode: If True, raise exceptions on validation errors.
                        If False, log warnings and use defaults.
        &#34;&#34;&#34;
        self.strict_mode = strict_mode
        logger.info(f&#34;ContentLoader initialized (strict_mode={strict_mode})&#34;)

    def load_game(self, output_dir: str) -&gt; GameData:
        &#34;&#34;&#34;
        Load all generated JSON files into a playable game.

        This is the main entry point for loading a complete game. It first checks
        for playable_game.json (generated by GameEngineerAgent). If not found, it
        loads the 5 separate JSON files, validates them, converts them to engine
        objects, and merges them into a single GameData structure.

        Args:
            output_dir: Directory containing the generated JSON files.

        Returns:
            GameData object containing all loaded content.

        Raises:
            LoaderError: If critical files are missing or invalid.

        Examples:
            &gt;&gt;&gt; loader = ContentLoader()
            &gt;&gt;&gt; game_data = loader.load_game(&#34;game-config/&#34;)
            &gt;&gt;&gt; len(game_data.scenes) &gt; 0
            True
        &#34;&#34;&#34;
        logger.info(f&#34;Loading game from directory: {output_dir}&#34;)

        base_path = Path(output_dir)
        playable_game_path = base_path / &#34;playable_game.json&#34;

        # Check if playable_game.json exists (preferred, generated by GameEngineerAgent)
        if playable_game_path.exists():
            logger.info(&#34;Found playable_game.json - loading directly from game engine format&#34;)
            playable_data = self.load_json(str(playable_game_path))

            # playable_game.json wraps the game in a &#34;game&#34; key
            game_dict = playable_data.get(&#34;game&#34;, playable_data)

            # Convert to GameData using from_dict
            game_data = GameData.from_dict(game_dict)
            logger.info(f&#34;Game loaded: &#39;{game_data.title}&#39; with {len(game_data.scenes)} scenes&#34;)
            return game_data

        # Fall back to loading separate files (legacy method)
        logger.info(&#34;playable_game.json not found - loading from separate narrative files&#34;)

        # Load all JSON files
        plot = self.load_json(str(base_path / &#34;plot_outline.json&#34;))
        narrative = self.load_json(str(base_path / &#34;narrative_map.json&#34;))
        puzzles = self.load_json(str(base_path / &#34;puzzle_design.json&#34;))
        scenes = self.load_json(str(base_path / &#34;scene_texts.json&#34;))
        mechanics = self.load_json(str(base_path / &#34;prd_document.json&#34;))

        logger.info(&#34;All JSON files loaded successfully&#34;)

        # Merge into GameData
        game_data = self.merge_into_game_data(plot, narrative, puzzles, scenes, mechanics)

        logger.info(f&#34;Game loaded: &#39;{game_data.title}&#39; with {len(game_data.scenes)} scenes&#34;)
        return game_data

    def load_yaml(self, filepath: str) -&gt; dict[str, Any]:
        &#34;&#34;&#34;
        Load and parse a YAML file with error handling.

        Handles common issues with AI-generated YAML:
        - Markdown code fence wrapping (```yaml ... ```)
        - Extra whitespace
        - Missing files
        - Invalid YAML syntax

        Args:
            filepath: Path to the YAML file to load.

        Returns:
            Parsed YAML content as a dictionary.

        Raises:
            LoaderError: If file is missing or cannot be parsed.

        Examples:
            &gt;&gt;&gt; loader = ContentLoader()
            &gt;&gt;&gt; data = loader.load_yaml(&#34;game-config/plot_outline.yaml&#34;)
            &gt;&gt;&gt; isinstance(data, dict)
            True
        &#34;&#34;&#34;
        logger.debug(f&#34;Loading YAML file: {filepath}&#34;)

        # Check if file exists
        if not Path(filepath).exists():
            error_msg = f&#34;File not found: {filepath}&#34;
            logger.error(error_msg)
            if self.strict_mode:
                raise LoaderError(error_msg)
            else:
                logger.warning(f&#34;File missing, returning empty dict: {filepath}&#34;)
                return {}

        try:
            # Read file content
            with Path(filepath).open(encoding=&#34;utf-8&#34;) as f:
                content = f.read()

            # Clean up markdown wrapping (common AI output issue)
            content = self._clean_yaml_content(content)

            # Parse YAML
            data = yaml.safe_load(content)

            if data is None:
                logger.warning(f&#34;Empty YAML file: {filepath}&#34;)
                return {}

            if not isinstance(data, dict):
                error_msg = f&#34;Invalid YAML structure in {filepath}: expected dict, got {type(data)}&#34;
                logger.error(error_msg)
                if self.strict_mode:
                    raise YAMLParseError(error_msg)
                return {}

            logger.debug(f&#34;Successfully loaded {filepath}: {len(data)} top-level keys&#34;)
            return data

        except yaml.YAMLError as e:
            error_msg = f&#34;YAML parsing error in {filepath}: {e}&#34;
            logger.error(error_msg)
            if self.strict_mode:
                raise YAMLParseError(error_msg) from e
            else:
                logger.warning(f&#34;YAML error, returning empty dict: {filepath}&#34;)
                return {}
        except Exception as e:
            error_msg = f&#34;Unexpected error loading {filepath}: {e}&#34;
            logger.error(error_msg)
            if self.strict_mode:
                raise LoaderError(error_msg) from e
            else:
                logger.warning(f&#34;Error loading file, returning empty dict: {filepath}&#34;)
                return {}

    def load_json(self, filepath: str) -&gt; dict[str, Any]:
        &#34;&#34;&#34;
        Load and parse a JSON file with error handling.

        Handles common issues with AI-generated JSON:
        - Markdown code fence wrapping (```json ... ```)
        - Extra whitespace
        - Missing files
        - Invalid JSON syntax

        Args:
            filepath: Path to the JSON file to load.

        Returns:
            Parsed JSON content as a dictionary.

        Raises:
            LoaderError: If file is missing or cannot be parsed.

        Examples:
            &gt;&gt;&gt; loader = ContentLoader()
            &gt;&gt;&gt; data = loader.load_json(&#34;game-config/plot_outline.json&#34;)
            &gt;&gt;&gt; isinstance(data, dict)
            True
        &#34;&#34;&#34;
        logger.debug(f&#34;Loading JSON file: {filepath}&#34;)

        # Check if file exists
        if not Path(filepath).exists():
            error_msg = f&#34;File not found: {filepath}&#34;
            logger.error(error_msg)
            if self.strict_mode:
                raise LoaderError(error_msg)
            else:
                logger.warning(f&#34;File missing, returning empty dict: {filepath}&#34;)
                return {}

        try:
            # Read file content
            with Path(filepath).open(encoding=&#34;utf-8&#34;) as f:
                content = f.read()

            # Clean up markdown wrapping (common AI output issue)
            content = self._clean_json_content(content)

            # Parse JSON
            data = json.loads(content)

            if data is None:
                logger.warning(f&#34;Empty JSON file: {filepath}&#34;)
                return {}

            if not isinstance(data, dict):
                error_msg = f&#34;Invalid JSON structure in {filepath}: expected dict, got {type(data)}&#34;
                logger.error(error_msg)
                if self.strict_mode:
                    raise JSONParseError(error_msg)
                return {}

            logger.debug(f&#34;Successfully loaded {filepath}: {len(data)} top-level keys&#34;)
            return data

        except json.JSONDecodeError as e:
            error_msg = f&#34;JSON parsing error in {filepath}: {e}&#34;
            logger.error(error_msg)
            if self.strict_mode:
                raise JSONParseError(error_msg) from e
            else:
                logger.warning(f&#34;JSON error, returning empty dict: {filepath}&#34;)
                return {}
        except Exception as e:
            error_msg = f&#34;Unexpected error loading {filepath}: {e}&#34;
            logger.error(error_msg)
            if self.strict_mode:
                raise LoaderError(error_msg) from e
            else:
                logger.warning(f&#34;Error loading file, returning empty dict: {filepath}&#34;)
                return {}

    def _clean_yaml_content(self, content: str) -&gt; str:
        &#34;&#34;&#34;
        Clean up common issues in AI-generated YAML content.

        Specifically, this method:
            - Removes markdown code fences (e.g., ```yaml ... ```) that may wrap YAML content.
            - Strips leading and trailing whitespace from the content.

        Args:
            content: Raw YAML content string.

        Returns:
            Cleaned YAML content with code fences and extraneous whitespace removed.
        &#34;&#34;&#34;
        # Remove markdown code fences
        content = re.sub(r&#34;^```ya?ml\s*\n&#34;, &#34;&#34;, content, flags=re.MULTILINE)
        content = re.sub(r&#34;\n```\s*$&#34;, &#34;&#34;, content, flags=re.MULTILINE)

        # Strip leading/trailing whitespace
        content = content.strip()

        return content

    def _clean_json_content(self, content: str) -&gt; str:
        &#34;&#34;&#34;
        Clean up common issues in AI-generated JSON content.

        Specifically, this method:
            - Removes markdown code fences (e.g., ```json ... ```) that may wrap JSON content.
            - Strips leading and trailing whitespace from the content.

        Args:
            content: Raw JSON content string.

        Returns:
            Cleaned JSON content with code fences and extraneous whitespace removed.
        &#34;&#34;&#34;
        # Remove markdown code fences
        content = re.sub(r&#34;^\s*```json\s*\n?&#34;, &#34;&#34;, content, flags=re.IGNORECASE | re.MULTILINE)
        content = re.sub(r&#34;\n?\s*```\s*$&#34;, &#34;&#34;, content, flags=re.MULTILINE)

        # Strip leading/trailing whitespace
        content = content.strip()

        return content

    def merge_into_game_data(
        self,
        plot: dict[str, Any],
        narrative: dict[str, Any],
        puzzles: dict[str, Any],
        scenes_text: dict[str, Any],
        mechanics: dict[str, Any],
    ) -&gt; GameData:
        &#34;&#34;&#34;
        Merge all loaded JSON data into a GameData object.

        This method implements the core conversion logic, transforming
        the JSON structures into Scene, Item, NPC, and Event objects.

        Args:
            plot: Data from plot_outline.json
            narrative: Data from narrative_map.json
            puzzles: Data from puzzle_design.json
            scenes_text: Data from scene_texts.json
            mechanics: Data from prd_document.json

        Returns:
            Complete GameData object.

        Raises:
            ValidationError: If required data is missing.
        &#34;&#34;&#34;
        logger.info(&#34;Merging JSON data into GameData&#34;)

        # Extract title and description
        title = self._extract_title(plot, narrative, mechanics)
        description = self._extract_description(plot, mechanics)

        # Build scenes from narrative map
        scenes = self._build_scenes(narrative, scenes_text, puzzles)

        # Find starting scene
        starting_scene = self._find_starting_scene(narrative, scenes)

        # Extract global items and NPCs
        global_items = self._extract_global_items(puzzles)
        global_npcs = self._extract_global_npcs(puzzles)

        # Extract additional data
        themes = self._extract_themes(plot)
        plot_points = self._extract_plot_points(plot)
        endings = self._extract_endings(plot)
        game_rules = self._extract_game_rules(mechanics)

        # Build GameData
        game_data = GameData(
            title=title,
            description=description,
            scenes=scenes,
            starting_scene=starting_scene,
            global_items=global_items,
            global_npcs=global_npcs,
            themes=themes,
            plot_points=plot_points,
            endings=endings,
            game_rules=game_rules,
            metadata={
                &#34;loaded_from_ai&#34;: True,
                &#34;source_files&#34;: [
                    &#34;plot_outline&#34;,
                    &#34;narrative_map&#34;,
                    &#34;puzzle_design&#34;,
                    &#34;scene_texts&#34;,
                    &#34;prd_document&#34;,
                ],
            },
        )

        logger.info(&#34;GameData merge complete&#34;)
        return game_data

    def _extract_title(self, plot: dict, narrative: dict, mechanics: dict) -&gt; str:
        &#34;&#34;&#34;Extract game title from available sources.&#34;&#34;&#34;
        # Try multiple sources
        title = (
            plot.get(&#34;narrative_foundation&#34;, {}).get(&#34;title&#34;)
            or narrative.get(&#34;title&#34;)
            or mechanics.get(&#34;title&#34;)
            or mechanics.get(&#34;game_title&#34;)
            or &#34;Untitled Space Hulk Adventure&#34;
        )
        logger.debug(f&#34;Extracted title: {title}&#34;)
        return title

    def _extract_description(self, plot: dict, mechanics: dict) -&gt; str:
        &#34;&#34;&#34;Extract game description from available sources.&#34;&#34;&#34;
        description = (
            plot.get(&#34;narrative_foundation&#34;, {}).get(&#34;setting&#34;)
            or mechanics.get(&#34;description&#34;)
            or mechanics.get(&#34;game_overview&#34;)
            or &#34;A text adventure set in the grim darkness of the far future.&#34;
        )
        logger.debug(f&#34;Extracted description: {description[:50]}...&#34;)
        return description

    def _extract_themes(self, plot: dict) -&gt; list[str]:
        &#34;&#34;&#34;Extract narrative themes from plot data.&#34;&#34;&#34;
        foundation = plot.get(&#34;narrative_foundation&#34;, {})
        themes = foundation.get(&#34;themes&#34;, [])

        if isinstance(themes, str):
            # Handle single theme as string
            themes = [themes]

        logger.debug(f&#34;Extracted {len(themes)} themes&#34;)
        return list(themes) if themes else []

    def _extract_plot_points(self, plot: dict) -&gt; list[dict[str, Any]]:
        &#34;&#34;&#34;Extract major plot points from plot data.&#34;&#34;&#34;
        foundation = plot.get(&#34;narrative_foundation&#34;, {})
        plot_points = foundation.get(&#34;plot_points&#34;, [])

        if not isinstance(plot_points, list):
            logger.warning(f&#34;Invalid plot_points format: {type(plot_points)}&#34;)
            return []

        logger.debug(f&#34;Extracted {len(plot_points)} plot points&#34;)
        return plot_points

    def _extract_endings(self, plot: dict) -&gt; list[dict[str, Any]]:
        &#34;&#34;&#34;Extract possible endings from plot data.&#34;&#34;&#34;
        foundation = plot.get(&#34;narrative_foundation&#34;, {})
        endings = foundation.get(&#34;endings&#34;, [])

        if not isinstance(endings, list):
            logger.warning(f&#34;Invalid endings format: {type(endings)}&#34;)
            return []

        logger.debug(f&#34;Extracted {len(endings)} endings&#34;)
        return endings

    def _extract_game_rules(self, mechanics: dict) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Extract game mechanics and rules.&#34;&#34;&#34;
        rules = {}

        # Common keys in PRD documents
        for key in [&#34;mechanics&#34;, &#34;game_mechanics&#34;, &#34;rules&#34;, &#34;systems&#34;]:
            if key in mechanics:
                rules[key] = mechanics[key]

        logger.debug(f&#34;Extracted {len(rules)} game rule categories&#34;)
        return rules

    def _build_scenes(self, narrative: dict, scenes_text: dict, puzzles: dict) -&gt; dict[str, Scene]:
        &#34;&#34;&#34;
        Build Scene objects from narrative map and scene texts.

        Args:
            narrative: Narrative map data.
            scenes_text: Scene description data.
            puzzles: Puzzle and artifact data.

        Returns:
            Dictionary mapping scene IDs to Scene objects.
        &#34;&#34;&#34;
        logger.info(&#34;Building scenes from narrative data&#34;)

        scenes = {}

        # Get scene data from narrative map
        narrative_scenes = (
            narrative.get(&#34;narrative_map&#34;, {}).get(&#34;scenes&#34;, {})
            or narrative.get(&#34;scenes&#34;, {})
            or {}
        )

        if not narrative_scenes:
            logger.warning(&#34;No scenes found in narrative map&#34;)
            # Create a default starting scene
            default_scene = Scene(
                id=&#34;start&#34;,
                name=&#34;Starting Location&#34;,
                description=&#34;The adventure begins here.&#34;,
                exits={},
            )
            return {&#34;start&#34;: default_scene}

        # Build each scene
        for scene_id, scene_data in narrative_scenes.items():
            try:
                scene = self._build_single_scene(scene_id, scene_data, scenes_text, puzzles)
                scenes[scene_id] = scene
                logger.debug(f&#34;Built scene: {scene_id}&#34;)
            except Exception as e:
                logger.error(f&#34;Error building scene &#39;{scene_id}&#39;: {e}&#34;)
                if self.strict_mode:
                    raise ValidationError(f&#34;Failed to build scene &#39;{scene_id}&#39;: {e}&#34;) from e

        if not scenes:
            logger.error(&#34;No scenes were successfully built&#34;)
            if self.strict_mode:
                raise ValidationError(&#34;No valid scenes found&#34;)
            # Create fallback scene
            scenes[&#34;start&#34;] = Scene(
                id=&#34;start&#34;, name=&#34;Starting Location&#34;, description=&#34;The adventure begins.&#34;, exits={}
            )

        logger.info(f&#34;Built {len(scenes)} scenes&#34;)
        return scenes

    def _build_single_scene(
        self, scene_id: str, scene_data: dict, scenes_text: dict, puzzles: dict
    ) -&gt; Scene:
        &#34;&#34;&#34;
        Build a single Scene object from its data.

        Args:
            scene_id: The scene&#39;s unique identifier.
            scene_data: Scene data from narrative map.
            scenes_text: All scene text data.
            puzzles: Puzzle and artifact data.

        Returns:
            Constructed Scene object.
        &#34;&#34;&#34;
        # Extract name and description
        name = scene_data.get(&#34;name&#34;, scene_id.replace(&#34;_&#34;, &#34; &#34;).title())

        # Look for description in scene_data or scenes_text
        description = (
            scene_data.get(&#34;description&#34;)
            or scenes_text.get(scene_id, {}).get(&#34;description&#34;)
            or &#34;A location in the Space Hulk.&#34;
        )

        # Extract exits/connections
        exits = self._extract_exits(scene_data)

        # Extract items
        items = self._extract_scene_items(scene_data, puzzles)

        # Extract NPCs
        npcs = self._extract_scene_npcs(scene_data, puzzles)

        # Extract events
        events = self._extract_scene_events(scene_data)

        # Extract additional properties
        dark = scene_data.get(&#34;dark&#34;, False)
        locked_exits = scene_data.get(&#34;locked_exits&#34;, {})

        scene = Scene(
            id=scene_id,
            name=name,
            description=description,
            exits=exits,
            items=items,
            npcs=npcs,
            events=events,
            dark=dark,
            locked_exits=locked_exits,
        )

        return scene

    def _extract_exits(self, scene_data: dict) -&gt; dict[str, str]:
        &#34;&#34;&#34;Extract exits from scene data.&#34;&#34;&#34;
        exits = scene_data.get(&#34;exits&#34;, {}) or scene_data.get(&#34;connections&#34;, {}) or {}

        # Normalize exits to dict
        if isinstance(exits, list):
            # Convert list of exit names to dict
            exits_dict = {}
            for exit_item in exits:
                if isinstance(exit_item, str):
                    exits_dict[exit_item] = exit_item
                elif isinstance(exit_item, dict):
                    direction = exit_item.get(&#34;direction&#34;) or exit_item.get(&#34;name&#34;)
                    target = exit_item.get(&#34;target&#34;) or exit_item.get(&#34;scene_id&#34;)
                    if direction and target:
                        exits_dict[direction] = target
            exits = exits_dict

        return exits if isinstance(exits, dict) else {}

    def _extract_scene_items(self, scene_data: dict, puzzles: dict) -&gt; list[Item]:
        &#34;&#34;&#34;Extract items present in this scene.&#34;&#34;&#34;
        items = []
        item_ids = scene_data.get(&#34;items&#34;, []) or []

        if not isinstance(item_ids, list):
            item_ids = [item_ids]

        # Get item definitions from puzzles
        item_definitions = puzzles.get(&#34;artifacts&#34;, {}) or puzzles.get(&#34;items&#34;, {}) or {}

        for item_id in item_ids:
            if isinstance(item_id, str):
                item_def = item_definitions.get(item_id, {})
                if item_def:
                    try:
                        item = self._build_item(item_id, item_def)
                        items.append(item)
                    except Exception as e:
                        logger.warning(f&#34;Failed to build item &#39;{item_id}&#39;: {e}&#34;)

        return items

    def _extract_scene_npcs(self, scene_data: dict, puzzles: dict) -&gt; list[NPC]:
        &#34;&#34;&#34;Extract NPCs present in this scene.&#34;&#34;&#34;
        npcs = []
        npc_ids = scene_data.get(&#34;npcs&#34;, []) or []

        if not isinstance(npc_ids, list):
            npc_ids = [npc_ids]

        # Get NPC definitions from puzzles
        npc_definitions = puzzles.get(&#34;npcs&#34;, {}) or puzzles.get(&#34;characters&#34;, {}) or {}

        for npc_id in npc_ids:
            if isinstance(npc_id, str):
                npc_def = npc_definitions.get(npc_id, {})
                if npc_def:
                    try:
                        npc = self._build_npc(npc_id, npc_def)
                        npcs.append(npc)
                    except Exception as e:
                        logger.warning(f&#34;Failed to build NPC &#39;{npc_id}&#39;: {e}&#34;)

        return npcs

    def _extract_scene_events(self, scene_data: dict) -&gt; list[Event]:
        &#34;&#34;&#34;Extract events that can trigger in this scene.&#34;&#34;&#34;
        events = []
        event_list = scene_data.get(&#34;events&#34;, []) or []

        if not isinstance(event_list, list):
            event_list = [event_list]

        for event_data in event_list:
            if isinstance(event_data, dict):
                try:
                    event = self._build_event(event_data)
                    events.append(event)
                except Exception as e:
                    logger.warning(f&#34;Failed to build event: {e}&#34;)

        return events

    def _build_item(self, item_id: str, item_def: dict) -&gt; Item:
        &#34;&#34;&#34;Build an Item object from its definition.&#34;&#34;&#34;
        return Item(
            id=item_id,
            name=item_def.get(&#34;name&#34;, item_id.replace(&#34;_&#34;, &#34; &#34;).title()),
            description=item_def.get(&#34;description&#34;, &#34;An item.&#34;),
            takeable=item_def.get(&#34;takeable&#34;, True),
            useable=item_def.get(&#34;useable&#34;, False),
            use_text=item_def.get(&#34;use_text&#34;),
            required_flag=item_def.get(&#34;required_flag&#34;),
            effects=item_def.get(&#34;effects&#34;, {}),
        )

    def _build_npc(self, npc_id: str, npc_def: dict) -&gt; NPC:
        &#34;&#34;&#34;Build an NPC object from its definition.&#34;&#34;&#34;
        return NPC(
            id=npc_id,
            name=npc_def.get(&#34;name&#34;, npc_id.replace(&#34;_&#34;, &#34; &#34;).title()),
            description=npc_def.get(&#34;description&#34;, &#34;A character.&#34;),
            dialogue=npc_def.get(&#34;dialogue&#34;, {}),
            hostile=npc_def.get(&#34;hostile&#34;, False),
            health=npc_def.get(&#34;health&#34;, 100),
            gives_item=npc_def.get(&#34;gives_item&#34;),
            required_flag=npc_def.get(&#34;required_flag&#34;),
        )

    def _build_event(self, event_data: dict) -&gt; Event:
        &#34;&#34;&#34;Build an Event object from its data.&#34;&#34;&#34;
        return Event(
            id=event_data.get(&#34;id&#34;, &#34;event&#34;),
            description=event_data.get(&#34;description&#34;, &#34;Something happens.&#34;),
            trigger_on_entry=event_data.get(&#34;trigger_on_entry&#34;, False),
            required_flag=event_data.get(&#34;required_flag&#34;),
            one_time=event_data.get(&#34;one_time&#34;, True),
            effects=event_data.get(&#34;effects&#34;, {}),
        )

    def _extract_global_items(self, puzzles: dict) -&gt; dict[str, Item]:
        &#34;&#34;&#34;Extract global item definitions (not placed in scenes).&#34;&#34;&#34;
        global_items = {}

        item_defs = puzzles.get(&#34;artifacts&#34;, {}) or puzzles.get(&#34;items&#34;, {}) or {}

        for item_id, item_def in item_defs.items():
            if isinstance(item_def, dict):
                try:
                    item = self._build_item(item_id, item_def)
                    global_items[item_id] = item
                except Exception as e:
                    logger.warning(f&#34;Failed to build global item &#39;{item_id}&#39;: {e}&#34;)

        logger.debug(f&#34;Extracted {len(global_items)} global items&#34;)
        return global_items

    def _extract_global_npcs(self, puzzles: dict) -&gt; dict[str, NPC]:
        &#34;&#34;&#34;Extract global NPC definitions (not placed in scenes).&#34;&#34;&#34;
        global_npcs = {}

        npc_defs = puzzles.get(&#34;npcs&#34;, {}) or puzzles.get(&#34;characters&#34;, {}) or {}

        for npc_id, npc_def in npc_defs.items():
            if isinstance(npc_def, dict):
                try:
                    npc = self._build_npc(npc_id, npc_def)
                    global_npcs[npc_id] = npc
                except Exception as e:
                    logger.warning(f&#34;Failed to build global NPC &#39;{npc_id}&#39;: {e}&#34;)

        logger.debug(f&#34;Extracted {len(global_npcs)} global NPCs&#34;)
        return global_npcs

    def _find_starting_scene(self, narrative: dict, scenes: dict[str, Scene]) -&gt; str:
        &#34;&#34;&#34;Find the starting scene ID.&#34;&#34;&#34;
        # Try to find explicitly defined starting scene
        starting_scene = (
            narrative.get(&#34;starting_scene&#34;)
            or narrative.get(&#34;narrative_map&#34;, {}).get(&#34;starting_scene&#34;)
            or narrative.get(&#34;start_scene&#34;)
        )

        if starting_scene and starting_scene in scenes:
            logger.debug(f&#34;Found starting scene: {starting_scene}&#34;)
            return str(starting_scene)

        # Fall back to first scene or &#39;start&#39;
        if &#34;start&#34; in scenes:
            logger.debug(&#34;Using &#39;start&#39; as starting scene&#34;)
            return &#34;start&#34;

        if scenes:
            first_scene = next(iter(scenes.keys()))
            logger.debug(f&#34;Using first scene as starting scene: {first_scene}&#34;)
            return first_scene

        # This should not happen if scenes validation passed
        logger.error(&#34;No starting scene found&#34;)
        if self.strict_mode:
            raise ValidationError(&#34;No starting scene found&#34;)
        return &#34;start&#34;</code></pre>
              </details>
              <div class="desc">
                <p>
                  Loads AI-generated JSON files and converts them into GameData.
                </p>
                <p>
                  The ContentLoader implements a Facade pattern to simplify the
                  complex process of loading and merging multiple JSON files. It
                  uses Strategy pattern internally for handling different file
                  formats and Builder pattern for constructing GameData.
                </p>
                <h2 id="attributes">Attributes</h2>
                <dl>
                  <dt>
                    <strong><code>strict_mode</code></strong>
                  </dt>
                  <dd>
                    If True, raises exceptions on validation errors. If False,
                    logs warnings and uses defaults.
                  </dd>
                </dl>
                <h2 id="examples">Examples</h2>
                <p>Load a complete game:</p>
                <pre><code class="language-python-repl">&gt;&gt;&gt; loader = ContentLoader()
&gt;&gt;&gt; game_data = loader.load_game(&quot;game-config/&quot;)
&gt;&gt;&gt; print(f&quot;Loaded: {game_data.title}&quot;)
</code></pre>
                <p>Load with lenient error handling:</p>
                <pre><code class="language-python-repl">&gt;&gt;&gt; loader = ContentLoader(strict_mode=False)
&gt;&gt;&gt; game_data = loader.load_game(&quot;game-config/&quot;)
</code></pre>
                <p>Load individual files:</p>
                <pre><code class="language-python-repl">&gt;&gt;&gt; plot_data = loader.load_json(&quot;game-config/plot_outline.json&quot;)
</code></pre>
                <p>Initialize the ContentLoader.</p>
                <h2 id="args">Args</h2>
                <dl>
                  <dt>
                    <strong><code>strict_mode</code></strong>
                  </dt>
                  <dd>
                    If True, raise exceptions on validation errors. If False,
                    log warnings and use defaults.
                  </dd>
                </dl>
              </div>
              <h3>Methods</h3>
              <dl>
                <dt id="space_hulk_game.engine.loader.ContentLoader.load_game">
                  <code class="name flex">
                    <span>def <span class="ident">load_game</span></span
                    >(<span
                      >self, output_dir: str) ‑> <a
                        title="space_hulk_game.engine.game_data.GameData"
                        href="game_data.html#space_hulk_game.engine.game_data.GameData"
                        >GameData</a
                      ></span
                    >
                  </code>
                </dt>
                <dd>
                  <details class="source">
                    <summary>
                      <span>Expand source code</span>
                    </summary>
                    <pre><code class="python">def load_game(self, output_dir: str) -&gt; GameData:
    &#34;&#34;&#34;
    Load all generated JSON files into a playable game.

    This is the main entry point for loading a complete game. It first checks
    for playable_game.json (generated by GameEngineerAgent). If not found, it
    loads the 5 separate JSON files, validates them, converts them to engine
    objects, and merges them into a single GameData structure.

    Args:
        output_dir: Directory containing the generated JSON files.

    Returns:
        GameData object containing all loaded content.

    Raises:
        LoaderError: If critical files are missing or invalid.

    Examples:
        &gt;&gt;&gt; loader = ContentLoader()
        &gt;&gt;&gt; game_data = loader.load_game(&#34;game-config/&#34;)
        &gt;&gt;&gt; len(game_data.scenes) &gt; 0
        True
    &#34;&#34;&#34;
    logger.info(f&#34;Loading game from directory: {output_dir}&#34;)

    base_path = Path(output_dir)
    playable_game_path = base_path / &#34;playable_game.json&#34;

    # Check if playable_game.json exists (preferred, generated by GameEngineerAgent)
    if playable_game_path.exists():
        logger.info(&#34;Found playable_game.json - loading directly from game engine format&#34;)
        playable_data = self.load_json(str(playable_game_path))

        # playable_game.json wraps the game in a &#34;game&#34; key
        game_dict = playable_data.get(&#34;game&#34;, playable_data)

        # Convert to GameData using from_dict
        game_data = GameData.from_dict(game_dict)
        logger.info(f&#34;Game loaded: &#39;{game_data.title}&#39; with {len(game_data.scenes)} scenes&#34;)
        return game_data

    # Fall back to loading separate files (legacy method)
    logger.info(&#34;playable_game.json not found - loading from separate narrative files&#34;)

    # Load all JSON files
    plot = self.load_json(str(base_path / &#34;plot_outline.json&#34;))
    narrative = self.load_json(str(base_path / &#34;narrative_map.json&#34;))
    puzzles = self.load_json(str(base_path / &#34;puzzle_design.json&#34;))
    scenes = self.load_json(str(base_path / &#34;scene_texts.json&#34;))
    mechanics = self.load_json(str(base_path / &#34;prd_document.json&#34;))

    logger.info(&#34;All JSON files loaded successfully&#34;)

    # Merge into GameData
    game_data = self.merge_into_game_data(plot, narrative, puzzles, scenes, mechanics)

    logger.info(f&#34;Game loaded: &#39;{game_data.title}&#39; with {len(game_data.scenes)} scenes&#34;)
    return game_data</code></pre>
                  </details>
                  <div class="desc">
                    <p>Load all generated JSON files into a playable game.</p>
                    <p>
                      This is the main entry point for loading a complete game.
                      It first checks for playable_game.json (generated by
                      GameEngineerAgent). If not found, it loads the 5 separate
                      JSON files, validates them, converts them to engine
                      objects, and merges them into a single GameData structure.
                    </p>
                    <h2 id="args">Args</h2>
                    <dl>
                      <dt>
                        <strong><code>output_dir</code></strong>
                      </dt>
                      <dd>Directory containing the generated JSON files.</dd>
                    </dl>
                    <h2 id="returns">Returns</h2>
                    <p>GameData object containing all loaded content.</p>
                    <h2 id="raises">Raises</h2>
                    <dl>
                      <dt>
                        <code
                          ><a
                            title="space_hulk_game.engine.loader.LoaderError"
                            href="#space_hulk_game.engine.loader.LoaderError"
                            >LoaderError</a
                          ></code
                        >
                      </dt>
                      <dd>If critical files are missing or invalid.</dd>
                    </dl>
                    <h2 id="examples">Examples</h2>
                    <pre><code class="language-python-repl">&gt;&gt;&gt; loader = ContentLoader()
&gt;&gt;&gt; game_data = loader.load_game(&quot;game-config/&quot;)
&gt;&gt;&gt; len(game_data.scenes) &gt; 0
True
</code></pre>
                  </div>
                </dd>
                <dt id="space_hulk_game.engine.loader.ContentLoader.load_json">
                  <code class="name flex">
                    <span>def <span class="ident">load_json</span></span
                    >(<span>self, filepath: str) ‑> dict[str, typing.Any]</span>
                  </code>
                </dt>
                <dd>
                  <details class="source">
                    <summary>
                      <span>Expand source code</span>
                    </summary>
                    <pre><code class="python">def load_json(self, filepath: str) -&gt; dict[str, Any]:
    &#34;&#34;&#34;
    Load and parse a JSON file with error handling.

    Handles common issues with AI-generated JSON:
    - Markdown code fence wrapping (```json ... ```)
    - Extra whitespace
    - Missing files
    - Invalid JSON syntax

    Args:
        filepath: Path to the JSON file to load.

    Returns:
        Parsed JSON content as a dictionary.

    Raises:
        LoaderError: If file is missing or cannot be parsed.

    Examples:
        &gt;&gt;&gt; loader = ContentLoader()
        &gt;&gt;&gt; data = loader.load_json(&#34;game-config/plot_outline.json&#34;)
        &gt;&gt;&gt; isinstance(data, dict)
        True
    &#34;&#34;&#34;
    logger.debug(f&#34;Loading JSON file: {filepath}&#34;)

    # Check if file exists
    if not Path(filepath).exists():
        error_msg = f&#34;File not found: {filepath}&#34;
        logger.error(error_msg)
        if self.strict_mode:
            raise LoaderError(error_msg)
        else:
            logger.warning(f&#34;File missing, returning empty dict: {filepath}&#34;)
            return {}

    try:
        # Read file content
        with Path(filepath).open(encoding=&#34;utf-8&#34;) as f:
            content = f.read()

        # Clean up markdown wrapping (common AI output issue)
        content = self._clean_json_content(content)

        # Parse JSON
        data = json.loads(content)

        if data is None:
            logger.warning(f&#34;Empty JSON file: {filepath}&#34;)
            return {}

        if not isinstance(data, dict):
            error_msg = f&#34;Invalid JSON structure in {filepath}: expected dict, got {type(data)}&#34;
            logger.error(error_msg)
            if self.strict_mode:
                raise JSONParseError(error_msg)
            return {}

        logger.debug(f&#34;Successfully loaded {filepath}: {len(data)} top-level keys&#34;)
        return data

    except json.JSONDecodeError as e:
        error_msg = f&#34;JSON parsing error in {filepath}: {e}&#34;
        logger.error(error_msg)
        if self.strict_mode:
            raise JSONParseError(error_msg) from e
        else:
            logger.warning(f&#34;JSON error, returning empty dict: {filepath}&#34;)
            return {}
    except Exception as e:
        error_msg = f&#34;Unexpected error loading {filepath}: {e}&#34;
        logger.error(error_msg)
        if self.strict_mode:
            raise LoaderError(error_msg) from e
        else:
            logger.warning(f&#34;Error loading file, returning empty dict: {filepath}&#34;)
            return {}</code></pre>
                  </details>
                  <div class="desc">
                    <p>Load and parse a JSON file with error handling.</p>
                    <p>
                      Handles common issues with AI-generated JSON: - Markdown
                      code fence wrapping (<code>json ...</code>) - Extra
                      whitespace - Missing files - Invalid JSON syntax
                    </p>
                    <h2 id="args">Args</h2>
                    <dl>
                      <dt>
                        <strong><code>filepath</code></strong>
                      </dt>
                      <dd>Path to the JSON file to load.</dd>
                    </dl>
                    <h2 id="returns">Returns</h2>
                    <p>Parsed JSON content as a dictionary.</p>
                    <h2 id="raises">Raises</h2>
                    <dl>
                      <dt>
                        <code
                          ><a
                            title="space_hulk_game.engine.loader.LoaderError"
                            href="#space_hulk_game.engine.loader.LoaderError"
                            >LoaderError</a
                          ></code
                        >
                      </dt>
                      <dd>If file is missing or cannot be parsed.</dd>
                    </dl>
                    <h2 id="examples">Examples</h2>
                    <pre><code class="language-python-repl">&gt;&gt;&gt; loader = ContentLoader()
&gt;&gt;&gt; data = loader.load_json(&quot;game-config/plot_outline.json&quot;)
&gt;&gt;&gt; isinstance(data, dict)
True
</code></pre>
                  </div>
                </dd>
                <dt id="space_hulk_game.engine.loader.ContentLoader.load_yaml">
                  <code class="name flex">
                    <span>def <span class="ident">load_yaml</span></span
                    >(<span>self, filepath: str) ‑> dict[str, typing.Any]</span>
                  </code>
                </dt>
                <dd>
                  <details class="source">
                    <summary>
                      <span>Expand source code</span>
                    </summary>
                    <pre><code class="python">def load_yaml(self, filepath: str) -&gt; dict[str, Any]:
    &#34;&#34;&#34;
    Load and parse a YAML file with error handling.

    Handles common issues with AI-generated YAML:
    - Markdown code fence wrapping (```yaml ... ```)
    - Extra whitespace
    - Missing files
    - Invalid YAML syntax

    Args:
        filepath: Path to the YAML file to load.

    Returns:
        Parsed YAML content as a dictionary.

    Raises:
        LoaderError: If file is missing or cannot be parsed.

    Examples:
        &gt;&gt;&gt; loader = ContentLoader()
        &gt;&gt;&gt; data = loader.load_yaml(&#34;game-config/plot_outline.yaml&#34;)
        &gt;&gt;&gt; isinstance(data, dict)
        True
    &#34;&#34;&#34;
    logger.debug(f&#34;Loading YAML file: {filepath}&#34;)

    # Check if file exists
    if not Path(filepath).exists():
        error_msg = f&#34;File not found: {filepath}&#34;
        logger.error(error_msg)
        if self.strict_mode:
            raise LoaderError(error_msg)
        else:
            logger.warning(f&#34;File missing, returning empty dict: {filepath}&#34;)
            return {}

    try:
        # Read file content
        with Path(filepath).open(encoding=&#34;utf-8&#34;) as f:
            content = f.read()

        # Clean up markdown wrapping (common AI output issue)
        content = self._clean_yaml_content(content)

        # Parse YAML
        data = yaml.safe_load(content)

        if data is None:
            logger.warning(f&#34;Empty YAML file: {filepath}&#34;)
            return {}

        if not isinstance(data, dict):
            error_msg = f&#34;Invalid YAML structure in {filepath}: expected dict, got {type(data)}&#34;
            logger.error(error_msg)
            if self.strict_mode:
                raise YAMLParseError(error_msg)
            return {}

        logger.debug(f&#34;Successfully loaded {filepath}: {len(data)} top-level keys&#34;)
        return data

    except yaml.YAMLError as e:
        error_msg = f&#34;YAML parsing error in {filepath}: {e}&#34;
        logger.error(error_msg)
        if self.strict_mode:
            raise YAMLParseError(error_msg) from e
        else:
            logger.warning(f&#34;YAML error, returning empty dict: {filepath}&#34;)
            return {}
    except Exception as e:
        error_msg = f&#34;Unexpected error loading {filepath}: {e}&#34;
        logger.error(error_msg)
        if self.strict_mode:
            raise LoaderError(error_msg) from e
        else:
            logger.warning(f&#34;Error loading file, returning empty dict: {filepath}&#34;)
            return {}</code></pre>
                  </details>
                  <div class="desc">
                    <p>Load and parse a YAML file with error handling.</p>
                    <p>
                      Handles common issues with AI-generated YAML: - Markdown
                      code fence wrapping (<code>yaml ...</code>) - Extra
                      whitespace - Missing files - Invalid YAML syntax
                    </p>
                    <h2 id="args">Args</h2>
                    <dl>
                      <dt>
                        <strong><code>filepath</code></strong>
                      </dt>
                      <dd>Path to the YAML file to load.</dd>
                    </dl>
                    <h2 id="returns">Returns</h2>
                    <p>Parsed YAML content as a dictionary.</p>
                    <h2 id="raises">Raises</h2>
                    <dl>
                      <dt>
                        <code
                          ><a
                            title="space_hulk_game.engine.loader.LoaderError"
                            href="#space_hulk_game.engine.loader.LoaderError"
                            >LoaderError</a
                          ></code
                        >
                      </dt>
                      <dd>If file is missing or cannot be parsed.</dd>
                    </dl>
                    <h2 id="examples">Examples</h2>
                    <pre><code class="language-python-repl">&gt;&gt;&gt; loader = ContentLoader()
&gt;&gt;&gt; data = loader.load_yaml(&quot;game-config/plot_outline.yaml&quot;)
&gt;&gt;&gt; isinstance(data, dict)
True
</code></pre>
                  </div>
                </dd>
                <dt
                  id="space_hulk_game.engine.loader.ContentLoader.merge_into_game_data"
                >
                  <code class="name flex">
                    <span
                      >def <span class="ident">merge_into_game_data</span></span
                    >(<span
                      >self,<br />plot: dict[str, typing.Any],<br />narrative: dict[str, typing.Any],<br />puzzles: dict[str, typing.Any],<br />scenes_text: dict[str, typing.Any],<br />mechanics: dict[str, typing.Any])
                      ‑> <a
                        title="space_hulk_game.engine.game_data.GameData"
                        href="game_data.html#space_hulk_game.engine.game_data.GameData"
                        >GameData</a
                      ></span
                    >
                  </code>
                </dt>
                <dd>
                  <details class="source">
                    <summary>
                      <span>Expand source code</span>
                    </summary>
                    <pre><code class="python">def merge_into_game_data(
    self,
    plot: dict[str, Any],
    narrative: dict[str, Any],
    puzzles: dict[str, Any],
    scenes_text: dict[str, Any],
    mechanics: dict[str, Any],
) -&gt; GameData:
    &#34;&#34;&#34;
    Merge all loaded JSON data into a GameData object.

    This method implements the core conversion logic, transforming
    the JSON structures into Scene, Item, NPC, and Event objects.

    Args:
        plot: Data from plot_outline.json
        narrative: Data from narrative_map.json
        puzzles: Data from puzzle_design.json
        scenes_text: Data from scene_texts.json
        mechanics: Data from prd_document.json

    Returns:
        Complete GameData object.

    Raises:
        ValidationError: If required data is missing.
    &#34;&#34;&#34;
    logger.info(&#34;Merging JSON data into GameData&#34;)

    # Extract title and description
    title = self._extract_title(plot, narrative, mechanics)
    description = self._extract_description(plot, mechanics)

    # Build scenes from narrative map
    scenes = self._build_scenes(narrative, scenes_text, puzzles)

    # Find starting scene
    starting_scene = self._find_starting_scene(narrative, scenes)

    # Extract global items and NPCs
    global_items = self._extract_global_items(puzzles)
    global_npcs = self._extract_global_npcs(puzzles)

    # Extract additional data
    themes = self._extract_themes(plot)
    plot_points = self._extract_plot_points(plot)
    endings = self._extract_endings(plot)
    game_rules = self._extract_game_rules(mechanics)

    # Build GameData
    game_data = GameData(
        title=title,
        description=description,
        scenes=scenes,
        starting_scene=starting_scene,
        global_items=global_items,
        global_npcs=global_npcs,
        themes=themes,
        plot_points=plot_points,
        endings=endings,
        game_rules=game_rules,
        metadata={
            &#34;loaded_from_ai&#34;: True,
            &#34;source_files&#34;: [
                &#34;plot_outline&#34;,
                &#34;narrative_map&#34;,
                &#34;puzzle_design&#34;,
                &#34;scene_texts&#34;,
                &#34;prd_document&#34;,
            ],
        },
    )

    logger.info(&#34;GameData merge complete&#34;)
    return game_data</code></pre>
                  </details>
                  <div class="desc">
                    <p>Merge all loaded JSON data into a GameData object.</p>
                    <p>
                      This method implements the core conversion logic,
                      transforming the JSON structures into Scene, Item, NPC,
                      and Event objects.
                    </p>
                    <h2 id="args">Args</h2>
                    <dl>
                      <dt>
                        <strong><code>plot</code></strong>
                      </dt>
                      <dd>Data from plot_outline.json</dd>
                      <dt>
                        <strong><code>narrative</code></strong>
                      </dt>
                      <dd>Data from narrative_map.json</dd>
                      <dt>
                        <strong><code>puzzles</code></strong>
                      </dt>
                      <dd>Data from puzzle_design.json</dd>
                      <dt>
                        <strong><code>scenes_text</code></strong>
                      </dt>
                      <dd>Data from scene_texts.json</dd>
                      <dt>
                        <strong><code>mechanics</code></strong>
                      </dt>
                      <dd>Data from prd_document.json</dd>
                    </dl>
                    <h2 id="returns">Returns</h2>
                    <p>Complete GameData object.</p>
                    <h2 id="raises">Raises</h2>
                    <dl>
                      <dt>
                        <code
                          ><a
                            title="space_hulk_game.engine.loader.ValidationError"
                            href="#space_hulk_game.engine.loader.ValidationError"
                            >ValidationError</a
                          ></code
                        >
                      </dt>
                      <dd>If required data is missing.</dd>
                    </dl>
                  </div>
                </dd>
              </dl>
            </dd>
            <dt id="space_hulk_game.engine.loader.JSONParseError">
              <code class="flex name class">
                <span>class <span class="ident">JSONParseError</span></span>
                <span>(</span><span>*args, **kwargs)</span>
              </code>
            </dt>
            <dd>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">class JSONParseError(LoaderError):
    &#34;&#34;&#34;Raised when JSON parsing fails.&#34;&#34;&#34;

    pass</code></pre>
              </details>
              <div class="desc"><p>Raised when JSON parsing fails.</p></div>
              <h3>Ancestors</h3>
              <ul class="hlist">
                <li>
                  <a
                    title="space_hulk_game.engine.loader.LoaderError"
                    href="#space_hulk_game.engine.loader.LoaderError"
                    >LoaderError</a
                  >
                </li>
                <li>builtins.Exception</li>
                <li>builtins.BaseException</li>
              </ul>
            </dd>
            <dt id="space_hulk_game.engine.loader.LoaderError">
              <code class="flex name class">
                <span>class <span class="ident">LoaderError</span></span>
                <span>(</span><span>*args, **kwargs)</span>
              </code>
            </dt>
            <dd>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">class LoaderError(Exception):
    &#34;&#34;&#34;Base exception for content loading errors.&#34;&#34;&#34;

    pass</code></pre>
              </details>
              <div class="desc">
                <p>Base exception for content loading errors.</p>
              </div>
              <h3>Ancestors</h3>
              <ul class="hlist">
                <li>builtins.Exception</li>
                <li>builtins.BaseException</li>
              </ul>
              <h3>Subclasses</h3>
              <ul class="hlist">
                <li>
                  <a
                    title="space_hulk_game.engine.loader.JSONParseError"
                    href="#space_hulk_game.engine.loader.JSONParseError"
                    >JSONParseError</a
                  >
                </li>
                <li>
                  <a
                    title="space_hulk_game.engine.loader.ValidationError"
                    href="#space_hulk_game.engine.loader.ValidationError"
                    >ValidationError</a
                  >
                </li>
                <li>
                  <a
                    title="space_hulk_game.engine.loader.YAMLParseError"
                    href="#space_hulk_game.engine.loader.YAMLParseError"
                    >YAMLParseError</a
                  >
                </li>
              </ul>
            </dd>
            <dt id="space_hulk_game.engine.loader.ValidationError">
              <code class="flex name class">
                <span>class <span class="ident">ValidationError</span></span>
                <span>(</span><span>*args, **kwargs)</span>
              </code>
            </dt>
            <dd>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">class ValidationError(LoaderError):
    &#34;&#34;&#34;Raised when loaded content fails validation.&#34;&#34;&#34;

    pass</code></pre>
              </details>
              <div class="desc">
                <p>Raised when loaded content fails validation.</p>
              </div>
              <h3>Ancestors</h3>
              <ul class="hlist">
                <li>
                  <a
                    title="space_hulk_game.engine.loader.LoaderError"
                    href="#space_hulk_game.engine.loader.LoaderError"
                    >LoaderError</a
                  >
                </li>
                <li>builtins.Exception</li>
                <li>builtins.BaseException</li>
              </ul>
            </dd>
            <dt id="space_hulk_game.engine.loader.YAMLParseError">
              <code class="flex name class">
                <span>class <span class="ident">YAMLParseError</span></span>
                <span>(</span><span>*args, **kwargs)</span>
              </code>
            </dt>
            <dd>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">class YAMLParseError(LoaderError):
    &#34;&#34;&#34;Raised when YAML parsing fails.&#34;&#34;&#34;

    pass</code></pre>
              </details>
              <div class="desc"><p>Raised when YAML parsing fails.</p></div>
              <h3>Ancestors</h3>
              <ul class="hlist">
                <li>
                  <a
                    title="space_hulk_game.engine.loader.LoaderError"
                    href="#space_hulk_game.engine.loader.LoaderError"
                    >LoaderError</a
                  >
                </li>
                <li>builtins.Exception</li>
                <li>builtins.BaseException</li>
              </ul>
            </dd>
          </dl>
        </section>
      </article>
      <nav id="sidebar">
        <div class="toc">
          <ul></ul>
        </div>
        <ul id="index">
          <li>
            <h3>Super-module</h3>
            <ul>
              <li>
                <code
                  ><a title="space_hulk_game.engine" href="index.html"
                    >space_hulk_game.engine</a
                  ></code
                >
              </li>
            </ul>
          </li>
          <li>
            <h3><a href="#header-classes">Classes</a></h3>
            <ul>
              <li>
                <h4>
                  <code
                    ><a
                      title="space_hulk_game.engine.loader.ContentLoader"
                      href="#space_hulk_game.engine.loader.ContentLoader"
                      >ContentLoader</a
                    ></code
                  >
                </h4>
                <ul class="">
                  <li>
                    <code
                      ><a
                        title="space_hulk_game.engine.loader.ContentLoader.load_game"
                        href="#space_hulk_game.engine.loader.ContentLoader.load_game"
                        >load_game</a
                      ></code
                    >
                  </li>
                  <li>
                    <code
                      ><a
                        title="space_hulk_game.engine.loader.ContentLoader.load_json"
                        href="#space_hulk_game.engine.loader.ContentLoader.load_json"
                        >load_json</a
                      ></code
                    >
                  </li>
                  <li>
                    <code
                      ><a
                        title="space_hulk_game.engine.loader.ContentLoader.load_yaml"
                        href="#space_hulk_game.engine.loader.ContentLoader.load_yaml"
                        >load_yaml</a
                      ></code
                    >
                  </li>
                  <li>
                    <code
                      ><a
                        title="space_hulk_game.engine.loader.ContentLoader.merge_into_game_data"
                        href="#space_hulk_game.engine.loader.ContentLoader.merge_into_game_data"
                        >merge_into_game_data</a
                      ></code
                    >
                  </li>
                </ul>
              </li>
              <li>
                <h4>
                  <code
                    ><a
                      title="space_hulk_game.engine.loader.JSONParseError"
                      href="#space_hulk_game.engine.loader.JSONParseError"
                      >JSONParseError</a
                    ></code
                  >
                </h4>
              </li>
              <li>
                <h4>
                  <code
                    ><a
                      title="space_hulk_game.engine.loader.LoaderError"
                      href="#space_hulk_game.engine.loader.LoaderError"
                      >LoaderError</a
                    ></code
                  >
                </h4>
              </li>
              <li>
                <h4>
                  <code
                    ><a
                      title="space_hulk_game.engine.loader.ValidationError"
                      href="#space_hulk_game.engine.loader.ValidationError"
                      >ValidationError</a
                    ></code
                  >
                </h4>
              </li>
              <li>
                <h4>
                  <code
                    ><a
                      title="space_hulk_game.engine.loader.YAMLParseError"
                      href="#space_hulk_game.engine.loader.YAMLParseError"
                      >YAMLParseError</a
                    ></code
                  >
                </h4>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
    </main>
    <footer id="footer">
      <p>
        Generated by
        <a
          href="https://pdoc3.github.io/pdoc"
          title="pdoc: Python API documentation generator"
          ><cite>pdoc</cite> 0.11.6</a
        >.
      </p>
    </footer>
  </body>
</html>
