<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>space_hulk_game.engine API documentation</title>
<meta name="description" content="Game Engine Module …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>space_hulk_game.engine</code></h1>
</header>
<section id="section-intro">
<p>Game Engine Module</p>
<p>This module provides the core game engine components for the Space Hulk text adventure game.
It includes data models for game state, scenes, entities, command parsing, actions, and the
main game engine with persistence.</p>
<p>The engine is designed to load and execute games generated by the CrewAI agents, providing
a playable text adventure interface.</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="space_hulk_game.engine.actions" href="actions.html">space_hulk_game.engine.actions</a></code></dt>
<dd>
<div class="desc"><p>Action Classes Module …</p></div>
</dd>
<dt><code class="name"><a title="space_hulk_game.engine.engine" href="engine.html">space_hulk_game.engine.engine</a></code></dt>
<dd>
<div class="desc"><p>Text Adventure Engine Module …</p></div>
</dd>
<dt><code class="name"><a title="space_hulk_game.engine.entities" href="entities.html">space_hulk_game.engine.entities</a></code></dt>
<dd>
<div class="desc"><p>Entity Classes Module …</p></div>
</dd>
<dt><code class="name"><a title="space_hulk_game.engine.game_data" href="game_data.html">space_hulk_game.engine.game_data</a></code></dt>
<dd>
<div class="desc"><p>Game Data Module …</p></div>
</dd>
<dt><code class="name"><a title="space_hulk_game.engine.game_state" href="game_state.html">space_hulk_game.engine.game_state</a></code></dt>
<dd>
<div class="desc"><p>Game State Module …</p></div>
</dd>
<dt><code class="name"><a title="space_hulk_game.engine.loader" href="loader.html">space_hulk_game.engine.loader</a></code></dt>
<dd>
<div class="desc"><p>Content Loader Module …</p></div>
</dd>
<dt><code class="name"><a title="space_hulk_game.engine.parser" href="parser.html">space_hulk_game.engine.parser</a></code></dt>
<dd>
<div class="desc"><p>Command Parser Module …</p></div>
</dd>
<dt><code class="name"><a title="space_hulk_game.engine.persistence" href="persistence.html">space_hulk_game.engine.persistence</a></code></dt>
<dd>
<div class="desc"><p>Persistence Module …</p></div>
</dd>
<dt><code class="name"><a title="space_hulk_game.engine.scene" href="scene.html">space_hulk_game.engine.scene</a></code></dt>
<dd>
<div class="desc"><p>Scene Module …</p></div>
</dd>
<dt><code class="name"><a title="space_hulk_game.engine.validator" href="validator.html">space_hulk_game.engine.validator</a></code></dt>
<dd>
<div class="desc"><p>Game Validator Module …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="space_hulk_game.engine.delete_save"><code class="name flex">
<span>def <span class="ident">delete_save</span></span>(<span>filepath: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_save(filepath: str) -&gt; None:
    &#34;&#34;&#34;
    Delete a save file.

    Args:
        filepath: Path to the save file to delete.

    Raises:
        PersistenceError: If deletion fails.

    Examples:
        &gt;&gt;&gt; delete_save(&#34;mysave.json&#34;)
    &#34;&#34;&#34;
    try:
        filepath_obj = Path(filepath)
        if filepath_obj.exists():
            filepath_obj.unlink()
            logger.info(f&#34;Deleted save file: {filepath}&#34;)
        else:
            raise PersistenceError(f&#34;Save file not found: {filepath}&#34;)

    except Exception as e:
        error_msg = f&#34;Failed to delete save file: {e}&#34;
        logger.error(error_msg)
        raise PersistenceError(error_msg) from e</code></pre>
</details>
<div class="desc"><p>Delete a save file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filepath</code></strong></dt>
<dd>Path to the save file to delete.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="space_hulk_game.engine.PersistenceError" href="#space_hulk_game.engine.PersistenceError">PersistenceError</a></code></dt>
<dd>If deletion fails.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; delete_save(&quot;mysave.json&quot;)
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.get_save_metadata"><code class="name flex">
<span>def <span class="ident">get_save_metadata</span></span>(<span>filepath: str) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_save_metadata(filepath: str) -&gt; dict[str, Any]:
    &#34;&#34;&#34;
    Get metadata from a save file without loading the full game.

    This is useful for displaying save file information in a load menu.

    Args:
        filepath: Path to the save file.

    Returns:
        Dictionary containing save metadata (timestamp, version, etc.).

    Raises:
        PersistenceError: If reading metadata fails.

    Examples:
        &gt;&gt;&gt; metadata = get_save_metadata(&#34;mysave.json&#34;)
        &gt;&gt;&gt; print(metadata[&#39;timestamp&#39;])
        &#39;2024-01-15T14:30:00&#39;
    &#34;&#34;&#34;
    try:
        filepath_obj = Path(filepath)
        if not filepath_obj.exists():
            raise PersistenceError(f&#34;Save file not found: {filepath}&#34;)

        with open(filepath, encoding=&#34;utf-8&#34;) as f:
            save_data = json.load(f)

        metadata = {
            &#34;version&#34;: save_data.get(&#34;version&#34;, &#34;unknown&#34;),
            &#34;timestamp&#34;: save_data.get(&#34;timestamp&#34;, &#34;unknown&#34;),
            &#34;current_scene&#34;: save_data.get(&#34;game_state&#34;, {}).get(&#34;current_scene&#34;, &#34;unknown&#34;),
            &#34;health&#34;: save_data.get(&#34;game_state&#34;, {}).get(&#34;health&#34;, 0),
            &#34;inventory_size&#34;: len(save_data.get(&#34;game_state&#34;, {}).get(&#34;inventory&#34;, [])),
        }

        # Include custom metadata if present
        if &#34;metadata&#34; in save_data:
            metadata.update(save_data[&#34;metadata&#34;])

        return metadata

    except Exception as e:
        error_msg = f&#34;Failed to read save metadata: {e}&#34;
        logger.error(error_msg)
        raise PersistenceError(error_msg) from e</code></pre>
</details>
<div class="desc"><p>Get metadata from a save file without loading the full game.</p>
<p>This is useful for displaying save file information in a load menu.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filepath</code></strong></dt>
<dd>Path to the save file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dictionary containing save metadata (timestamp, version, etc.).</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="space_hulk_game.engine.PersistenceError" href="#space_hulk_game.engine.PersistenceError">PersistenceError</a></code></dt>
<dd>If reading metadata fails.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; metadata = get_save_metadata(&quot;mysave.json&quot;)
&gt;&gt;&gt; print(metadata['timestamp'])
'2024-01-15T14:30:00'
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.list_save_files"><code class="name flex">
<span>def <span class="ident">list_save_files</span></span>(<span>save_directory: str = 'saves') ‑> list</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_save_files(save_directory: str = &#34;saves&#34;) -&gt; list:
    &#34;&#34;&#34;
    List all save files in a directory.

    Args:
        save_directory: Directory to search for save files.

    Returns:
        List of save file paths.

    Examples:
        &gt;&gt;&gt; saves = list_save_files(&#34;saves&#34;)
        &gt;&gt;&gt; for save in saves:
        ...     print(save)
        saves/autosave.json
        saves/mysave.json
    &#34;&#34;&#34;
    try:
        save_dir = Path(save_directory)
        if not save_dir.exists():
            return []

        # Use a list to avoid multiple stat() calls
        save_files = []
        for file_path in save_dir.glob(&#34;*.json&#34;):
            save_files.append((file_path, file_path.stat().st_mtime))

        # Sort by modification time (newest first)
        save_files.sort(key=lambda x: x[1], reverse=True)

        return [str(f[0]) for f in save_files]

    except Exception as e:
        logger.error(f&#34;Failed to list save files: {e}&#34;)
        return []</code></pre>
</details>
<div class="desc"><p>List all save files in a directory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>save_directory</code></strong></dt>
<dd>Directory to search for save files.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of save file paths.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; saves = list_save_files(&quot;saves&quot;)
&gt;&gt;&gt; for save in saves:
...     print(save)
saves/autosave.json
saves/mysave.json
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.load_game"><code class="name flex">
<span>def <span class="ident">load_game</span></span>(<span>filepath: str) ‑> tuple[<a title="space_hulk_game.engine.game_state.GameState" href="game_state.html#space_hulk_game.engine.game_state.GameState">GameState</a>, dict[str, <a title="space_hulk_game.engine.scene.Scene" href="scene.html#space_hulk_game.engine.scene.Scene">Scene</a>]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_game(filepath: str) -&gt; tuple[GameState, dict[str, Scene]]:
    &#34;&#34;&#34;
    Load a game state and scenes from a JSON file.

    This function deserializes a previously saved game, restoring the
    game state and all scenes. It validates the save file format and
    data integrity.

    Args:
        filepath: Path to the save file to load.

    Returns:
        A tuple of (GameState, scenes_dict).

    Raises:
        PersistenceError: If loading fails due to file not found,
                         invalid format, or data corruption.

    Examples:
        &gt;&gt;&gt; state, scenes = load_game(&#34;mysave.json&#34;)
        &gt;&gt;&gt; state.current_scene
        &#39;room1&#39;
    &#34;&#34;&#34;
    try:
        # Check if file exists
        filepath_obj = Path(filepath)
        if not filepath_obj.exists():
            raise PersistenceError(f&#34;Save file not found: {filepath}&#34;)

        # Read file
        with open(filepath, encoding=&#34;utf-8&#34;) as f:
            save_data = json.load(f)

        # Validate save file structure
        _validate_save_data(save_data)

        # Deserialize game state
        game_state = GameState.from_dict(save_data[&#34;game_state&#34;])

        # Deserialize scenes
        scenes = {}
        for scene_id, scene_data in save_data[&#34;scenes&#34;].items():
            scenes[scene_id] = Scene.from_dict(scene_data)

        logger.info(f&#34;Game loaded from: {filepath}&#34;)
        logger.debug(f&#34;Loaded {len(scenes)} scenes&#34;)

        return game_state, scenes

    except PersistenceError:
        # Re-raise our own exceptions
        raise

    except OSError as e:
        error_msg = f&#34;Failed to load game: {e}&#34;
        logger.error(error_msg)
        raise PersistenceError(error_msg) from e

    except (json.JSONDecodeError, ValueError) as e:
        error_msg = f&#34;Invalid save file format: {e}&#34;
        logger.error(error_msg)
        raise PersistenceError(error_msg) from e

    except KeyError as e:
        error_msg = f&#34;Missing required data in save file: {e}&#34;
        logger.error(error_msg)
        raise PersistenceError(error_msg) from e

    except Exception as e:
        error_msg = f&#34;Unexpected error during load: {e}&#34;
        logger.error(error_msg)
        raise PersistenceError(error_msg) from e</code></pre>
</details>
<div class="desc"><p>Load a game state and scenes from a JSON file.</p>
<p>This function deserializes a previously saved game, restoring the
game state and all scenes. It validates the save file format and
data integrity.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filepath</code></strong></dt>
<dd>Path to the save file to load.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple of (GameState, scenes_dict).</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="space_hulk_game.engine.PersistenceError" href="#space_hulk_game.engine.PersistenceError">PersistenceError</a></code></dt>
<dd>If loading fails due to file not found,
invalid format, or data corruption.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; state, scenes = load_game(&quot;mysave.json&quot;)
&gt;&gt;&gt; state.current_scene
'room1'
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.save_game"><code class="name flex">
<span>def <span class="ident">save_game</span></span>(<span>filepath: str,<br>game_state: <a title="space_hulk_game.engine.game_state.GameState" href="game_state.html#space_hulk_game.engine.game_state.GameState">GameState</a>,<br>scenes: dict[str, <a title="space_hulk_game.engine.scene.Scene" href="scene.html#space_hulk_game.engine.scene.Scene">Scene</a>],<br>metadata: dict[str, typing.Any] = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_game(
    filepath: str, game_state: GameState, scenes: dict[str, Scene], metadata: dict[str, Any] = None
) -&gt; None:
    &#34;&#34;&#34;
    Save the game state and scenes to a JSON file.

    This function serializes the game state and all scenes to a JSON file,
    allowing the game to be resumed later. It includes metadata about when
    the save was created.

    Args:
        filepath: Path to the save file.
        game_state: The current game state to save.
        scenes: Dictionary of all scenes in the game.
        metadata: Optional additional metadata to save.

    Raises:
        PersistenceError: If saving fails due to serialization or I/O error.

    Examples:
        &gt;&gt;&gt; from space_hulk_game.engine import GameState, Scene
        &gt;&gt;&gt; state = GameState(current_scene=&#34;room1&#34;)
        &gt;&gt;&gt; scenes = {
        ...     &#34;room1&#34;: Scene(id=&#34;room1&#34;, name=&#34;Room&#34;, description=&#34;A room.&#34;)
        ... }
        &gt;&gt;&gt; save_game(&#34;mysave.json&#34;, state, scenes)
    &#34;&#34;&#34;
    try:
        # Prepare save data
        save_data = {
            &#34;version&#34;: &#34;1.0&#34;,
            &#34;timestamp&#34;: datetime.now().isoformat(),
            &#34;metadata&#34;: metadata or {},
            &#34;game_state&#34;: game_state.to_dict(),
            &#34;scenes&#34;: {scene_id: scene.to_dict() for scene_id, scene in scenes.items()},
        }

        # Ensure directory exists
        filepath_obj = Path(filepath)
        filepath_obj.parent.mkdir(parents=True, exist_ok=True)

        # Write to file with pretty formatting
        with open(filepath, &#34;w&#34;, encoding=&#34;utf-8&#34;) as f:
            json.dump(save_data, f, indent=2, ensure_ascii=False)

        logger.info(f&#34;Game saved to: {filepath}&#34;)

    except OSError as e:
        error_msg = f&#34;Failed to save game: {e}&#34;
        logger.error(error_msg)
        raise PersistenceError(error_msg) from e

    except (TypeError, ValueError) as e:
        error_msg = f&#34;Failed to serialize game data: {e}&#34;
        logger.error(error_msg)
        raise PersistenceError(error_msg) from e

    except Exception as e:
        error_msg = f&#34;Unexpected error during save: {e}&#34;
        logger.error(error_msg)
        raise PersistenceError(error_msg) from e</code></pre>
</details>
<div class="desc"><p>Save the game state and scenes to a JSON file.</p>
<p>This function serializes the game state and all scenes to a JSON file,
allowing the game to be resumed later. It includes metadata about when
the save was created.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filepath</code></strong></dt>
<dd>Path to the save file.</dd>
<dt><strong><code>game_state</code></strong></dt>
<dd>The current game state to save.</dd>
<dt><strong><code>scenes</code></strong></dt>
<dd>Dictionary of all scenes in the game.</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Optional additional metadata to save.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="space_hulk_game.engine.PersistenceError" href="#space_hulk_game.engine.PersistenceError">PersistenceError</a></code></dt>
<dd>If saving fails due to serialization or I/O error.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from space_hulk_game.engine import GameState, Scene
&gt;&gt;&gt; state = GameState(current_scene=&quot;room1&quot;)
&gt;&gt;&gt; scenes = {
...     &quot;room1&quot;: Scene(id=&quot;room1&quot;, name=&quot;Room&quot;, description=&quot;A room.&quot;)
... }
&gt;&gt;&gt; save_game(&quot;mysave.json&quot;, state, scenes)
</code></pre></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="space_hulk_game.engine.Action"><code class="flex name class">
<span>class <span class="ident">Action</span></span>
<span>(</span><span>raw_command: str = '')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class Action:
    &#34;&#34;&#34;
    Base class for all player actions.

    Actions represent the player&#39;s intent after parsing their command.
    They are immutable and contain all information needed to execute
    the action in the game engine.

    This follows the Command Pattern from Gang of Four design patterns,
    encapsulating requests as objects.

    Attributes:
        raw_command: The original text command from the player.

    Examples:
        Actions are typically created by CommandParser, not directly:
        &gt;&gt;&gt; action = Action(raw_command=&#34;look around&#34;)
        &gt;&gt;&gt; action.raw_command
        &#39;look around&#39;
    &#34;&#34;&#34;

    raw_command: str = &#34;&#34;

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Return a string representation of the action.&#34;&#34;&#34;
        return f&#34;{self.__class__.__name__}()&#34;</code></pre>
</details>
<div class="desc"><p>Base class for all player actions.</p>
<p>Actions represent the player's intent after parsing their command.
They are immutable and contain all information needed to execute
the action in the game engine.</p>
<p>This follows the Command Pattern from Gang of Four design patterns,
encapsulating requests as objects.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>raw_command</code></strong></dt>
<dd>The original text command from the player.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Actions are typically created by CommandParser, not directly:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; action = Action(raw_command=&quot;look around&quot;)
&gt;&gt;&gt; action.raw_command
'look around'
</code></pre></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="space_hulk_game.engine.actions.DropAction" href="actions.html#space_hulk_game.engine.actions.DropAction">DropAction</a></li>
<li><a title="space_hulk_game.engine.actions.HelpAction" href="actions.html#space_hulk_game.engine.actions.HelpAction">HelpAction</a></li>
<li><a title="space_hulk_game.engine.actions.InventoryAction" href="actions.html#space_hulk_game.engine.actions.InventoryAction">InventoryAction</a></li>
<li><a title="space_hulk_game.engine.actions.LookAction" href="actions.html#space_hulk_game.engine.actions.LookAction">LookAction</a></li>
<li><a title="space_hulk_game.engine.actions.MoveAction" href="actions.html#space_hulk_game.engine.actions.MoveAction">MoveAction</a></li>
<li><a title="space_hulk_game.engine.actions.TakeAction" href="actions.html#space_hulk_game.engine.actions.TakeAction">TakeAction</a></li>
<li><a title="space_hulk_game.engine.actions.TalkAction" href="actions.html#space_hulk_game.engine.actions.TalkAction">TalkAction</a></li>
<li><a title="space_hulk_game.engine.actions.UnknownAction" href="actions.html#space_hulk_game.engine.actions.UnknownAction">UnknownAction</a></li>
<li><a title="space_hulk_game.engine.actions.UseAction" href="actions.html#space_hulk_game.engine.actions.UseAction">UseAction</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="space_hulk_game.engine.Action.raw_command"><code class="name">var <span class="ident">raw_command</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.engine.CommandParser"><code class="flex name class">
<span>class <span class="ident">CommandParser</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CommandParser:
    &#34;&#34;&#34;
    Parses natural language commands into Action objects.

    This class implements a facade pattern for command parsing, providing
    a simple interface that hides the complexity of synonym matching,
    fuzzy matching, and context-aware parsing.

    The parser is designed to be forgiving and helpful, using fuzzy matching
    for typos and providing suggestions when commands aren&#39;t recognized.

    Attributes:
        COMMANDS: Dictionary mapping action types to lists of synonyms.
        CUTOFF: Minimum similarity score for fuzzy matching (0.0 to 1.0).

    Examples:
        Basic usage:
        &gt;&gt;&gt; parser = CommandParser()
        &gt;&gt;&gt; action = parser.parse(&#34;go north&#34;)
        &gt;&gt;&gt; isinstance(action, MoveAction)
        True

        With context for better suggestions:
        &gt;&gt;&gt; from space_hulk_game.engine import GameState, Scene
        &gt;&gt;&gt; state = GameState(current_scene=&#34;room&#34;)
        &gt;&gt;&gt; scene = Scene(id=&#34;room&#34;, name=&#34;Room&#34;, description=&#34;A room.&#34;,
        ...               exits={&#34;north&#34;: &#34;hallway&#34;})
        &gt;&gt;&gt; action = parser.parse(&#34;go nrth&#34;, state, scene)  # typo
        &gt;&gt;&gt; isinstance(action, MoveAction)
        True
    &#34;&#34;&#34;

    # Command synonyms mapping
    COMMANDS: dict[str, list[str]] = {
        &#34;move&#34;: [&#34;go&#34;, &#34;move&#34;, &#34;walk&#34;, &#34;run&#34;, &#34;travel&#34;, &#34;head&#34;, &#34;proceed&#34;, &#34;enter&#34;],
        &#34;take&#34;: [&#34;take&#34;, &#34;get&#34;, &#34;grab&#34;, &#34;pick&#34;, &#34;pickup&#34;, &#34;acquire&#34;, &#34;collect&#34;],
        &#34;drop&#34;: [&#34;drop&#34;, &#34;leave&#34;, &#34;discard&#34;, &#34;put down&#34;, &#34;release&#34;],
        &#34;use&#34;: [&#34;use&#34;, &#34;activate&#34;, &#34;apply&#34;, &#34;employ&#34;, &#34;utilize&#34;, &#34;engage&#34;],
        &#34;look&#34;: [&#34;look&#34;, &#34;examine&#34;, &#34;inspect&#34;, &#34;check&#34;, &#34;observe&#34;, &#34;search&#34;, &#34;view&#34;, &#34;l&#34;, &#34;x&#34;],
        &#34;inventory&#34;: [&#34;inventory&#34;, &#34;inv&#34;, &#34;i&#34;, &#34;items&#34;, &#34;possessions&#34;, &#34;backpack&#34;, &#34;bag&#34;],
        &#34;talk&#34;: [&#34;talk&#34;, &#34;speak&#34;, &#34;chat&#34;, &#34;converse&#34;, &#34;ask&#34;, &#34;tell&#34;, &#34;discuss&#34;],
        &#34;help&#34;: [&#34;help&#34;, &#34;h&#34;, &#34;?&#34;, &#34;commands&#34;, &#34;instructions&#34;],
    }

    # Fuzzy matching threshold
    CUTOFF: float = 0.6

    def __init__(self):
        &#34;&#34;&#34;Initialize the command parser.&#34;&#34;&#34;
        # Build reverse mapping for fast lookup
        self._command_map: dict[str, str] = {}
        for action_type, synonyms in self.COMMANDS.items():
            for synonym in synonyms:
                self._command_map[synonym.lower()] = action_type

        logger.debug(f&#34;CommandParser initialized with {len(self._command_map)} command synonyms&#34;)

    def parse(
        self,
        command: str,
        game_state: Optional[GameState] = None,
        current_scene: Optional[Scene] = None,
    ) -&gt; Action:
        &#34;&#34;&#34;
        Parse a text command into an Action object.

        This is the main entry point for command parsing. It handles:
        1. Text normalization and tokenization
        2. Command word identification (with fuzzy matching)
        3. Argument extraction
        4. Context-aware parsing
        5. Action object creation

        Args:
            command: The raw text command from the player.
            game_state: Optional current game state for context.
            current_scene: Optional current scene for context.

        Returns:
            An Action object representing the parsed command.

        Examples:
            &gt;&gt;&gt; parser = CommandParser()
            &gt;&gt;&gt; action = parser.parse(&#34;go north&#34;)
            &gt;&gt;&gt; action.direction
            &#39;north&#39;

            &gt;&gt;&gt; action = parser.parse(&#34;take medkit&#34;)
            &gt;&gt;&gt; action.item_id
            &#39;medkit&#39;

            &gt;&gt;&gt; action = parser.parse(&#34;look&#34;)
            &gt;&gt;&gt; isinstance(action, LookAction)
            True
        &#34;&#34;&#34;
        # Normalize input
        command = command.strip().lower()

        if not command:
            logger.debug(&#34;Empty command received&#34;)
            return UnknownAction(raw_command=&#34;&#34;)

        logger.debug(f&#34;Parsing command: &#39;{command}&#39;&#34;)

        # Tokenize command
        tokens = self._tokenize(command)

        if not tokens:
            return UnknownAction(raw_command=command)

        # Identify command type
        action_type, command_word, remaining_tokens = self._identify_command(tokens)

        if not action_type:
            # Try to find a close match
            suggestion = self._suggest_command(command_word)
            logger.debug(f&#34;Unknown command: &#39;{command_word}&#39;, suggestion: &#39;{suggestion}&#39;&#34;)
            return UnknownAction(raw_command=command, suggestion=suggestion)

        # Parse based on action type
        logger.debug(f&#34;Identified action type: {action_type}&#34;)

        if action_type == &#34;move&#34;:
            return self._parse_move(command, remaining_tokens, current_scene)
        elif action_type == &#34;take&#34;:
            return self._parse_take(command, remaining_tokens, current_scene)
        elif action_type == &#34;drop&#34;:
            return self._parse_drop(command, remaining_tokens, game_state)
        elif action_type == &#34;use&#34;:
            return self._parse_use(command, remaining_tokens, game_state, current_scene)
        elif action_type == &#34;look&#34;:
            return self._parse_look(command, remaining_tokens, current_scene)
        elif action_type == &#34;inventory&#34;:
            return InventoryAction(raw_command=command)
        elif action_type == &#34;talk&#34;:
            return self._parse_talk(command, remaining_tokens, current_scene)
        elif action_type == &#34;help&#34;:
            return HelpAction(raw_command=command)
        else:
            return UnknownAction(raw_command=command)

    def _tokenize(self, command: str) -&gt; list[str]:
        &#34;&#34;&#34;
        Tokenize a command into words.

        Args:
            command: The command string to tokenize.

        Returns:
            List of tokens (words).

        Examples:
            &gt;&gt;&gt; parser = CommandParser()
            &gt;&gt;&gt; parser._tokenize(&#34;go north&#34;)
            [&#39;go&#39;, &#39;north&#39;]
            &gt;&gt;&gt; parser._tokenize(&#34;  take   medkit  &#34;)
            [&#39;take&#39;, &#39;medkit&#39;]
        &#34;&#34;&#34;
        # Split on whitespace and filter empty strings
        return [token for token in command.split() if token]

    def _identify_command(self, tokens: list[str]) -&gt; tuple[Optional[str], str, list[str]]:
        &#34;&#34;&#34;
        Identify the command type from tokens.

        This method handles multi-word commands (e.g., &#34;pick up&#34;) and
        uses fuzzy matching for typos.

        Args:
            tokens: List of command tokens.

        Returns:
            Tuple of (action_type, command_word, remaining_tokens).
            action_type is None if no match found.

        Examples:
            &gt;&gt;&gt; parser = CommandParser()
            &gt;&gt;&gt; parser._identify_command([&#39;go&#39;, &#39;north&#39;])
            (&#39;move&#39;, &#39;go&#39;, [&#39;north&#39;])
            &gt;&gt;&gt; parser._identify_command([&#39;take&#39;, &#39;medkit&#39;])
            (&#39;take&#39;, &#39;take&#39;, [&#39;medkit&#39;])
        &#34;&#34;&#34;
        if not tokens:
            return None, &#34;&#34;, []

        # Try exact match for first word
        first_word = tokens[0]
        if first_word in self._command_map:
            return self._command_map[first_word], first_word, tokens[1:]

        # Try multi-word commands (e.g., &#34;pick up&#34;, &#34;put down&#34;)
        if len(tokens) &gt;= 2:
            two_word = f&#34;{tokens[0]} {tokens[1]}&#34;
            if two_word in self._command_map:
                return self._command_map[two_word], two_word, tokens[2:]

        # Try fuzzy matching
        matches = difflib.get_close_matches(
            first_word,
            self._command_map.keys(),
            n=5,  # Get multiple matches for prioritization
            cutoff=self.CUTOFF,
        )

        if matches:
            # If we have multiple matches, prefer certain command types
            # Priority: take &gt; move &gt; use &gt; look &gt; talk &gt; drop &gt; inventory &gt; help
            priority_order = [&#34;take&#34;, &#34;move&#34;, &#34;use&#34;, &#34;look&#34;, &#34;talk&#34;, &#34;drop&#34;, &#34;inventory&#34;, &#34;help&#34;]

            # Get action types for all matches
            match_action_types = [(match, self._command_map[match]) for match in matches]

            # Sort by priority
            for priority_type in priority_order:
                for match, action_type in match_action_types:
                    if action_type == priority_type:
                        logger.debug(
                            f&#34;Fuzzy match: &#39;{first_word}&#39; -&gt; &#39;{match}&#39; (type: {action_type})&#34;
                        )
                        return action_type, first_word, tokens[1:]

            # If no priority match, use first match
            matched_word = matches[0]
            logger.debug(f&#34;Fuzzy match: &#39;{first_word}&#39; -&gt; &#39;{matched_word}&#39;&#34;)
            return self._command_map[matched_word], first_word, tokens[1:]

        return None, first_word, tokens[1:]

    def _suggest_command(self, word: str) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Suggest a command based on fuzzy matching.

        Args:
            word: The unrecognized word.

        Returns:
            A suggested command word, or None if no close match.

        Examples:
            &gt;&gt;&gt; parser = CommandParser()
            &gt;&gt;&gt; parser._suggest_command(&#34;tak&#34;)
            &#39;take&#39;
            &gt;&gt;&gt; parser._suggest_command(&#34;examne&#34;)
            &#39;examine&#39;
        &#34;&#34;&#34;
        matches = difflib.get_close_matches(
            word,
            self._command_map.keys(),
            n=1,
            cutoff=0.5,  # Lower cutoff for suggestions
        )

        return matches[0] if matches else None

    def _parse_move(self, command: str, tokens: list[str], scene: Optional[Scene]) -&gt; Action:
        &#34;&#34;&#34;
        Parse a movement command.

        Args:
            command: The raw command string.
            tokens: Remaining tokens after command word.
            scene: Optional current scene for context.

        Returns:
            A MoveAction or UnknownAction.

        Examples:
            &gt;&gt;&gt; parser = CommandParser()
            &gt;&gt;&gt; action = parser._parse_move(&#34;go north&#34;, [&#34;north&#34;], None)
            &gt;&gt;&gt; action.direction
            &#39;north&#39;
        &#34;&#34;&#34;
        if not tokens:
            logger.debug(&#34;Move command missing direction&#34;)
            return UnknownAction(raw_command=command, suggestion=&#34;go &lt;direction&gt;&#34;)

        direction = tokens[0]

        # If we have scene context, validate and fuzzy match against available exits
        if scene and scene.exits:
            available_exits = list(scene.exits.keys())

            # Exact match
            if direction in available_exits:
                return MoveAction(direction=direction, raw_command=command)

            # Fuzzy match
            matches = difflib.get_close_matches(direction, available_exits, n=1, cutoff=self.CUTOFF)

            if matches:
                matched_direction = matches[0]
                logger.debug(f&#34;Fuzzy matched direction: &#39;{direction}&#39; -&gt; &#39;{matched_direction}&#39;&#34;)
                return MoveAction(direction=matched_direction, raw_command=command)

        # No context or no match, return as-is
        return MoveAction(direction=direction, raw_command=command)

    def _parse_take(self, command: str, tokens: list[str], scene: Optional[Scene]) -&gt; Action:
        &#34;&#34;&#34;
        Parse a take/get command.

        Args:
            command: The raw command string.
            tokens: Remaining tokens after command word.
            scene: Optional current scene for context.

        Returns:
            A TakeAction or UnknownAction.

        Examples:
            &gt;&gt;&gt; parser = CommandParser()
            &gt;&gt;&gt; action = parser._parse_take(&#34;take medkit&#34;, [&#34;medkit&#34;], None)
            &gt;&gt;&gt; action.item_id
            &#39;medkit&#39;
        &#34;&#34;&#34;
        if not tokens:
            logger.debug(&#34;Take command missing item&#34;)
            return UnknownAction(raw_command=command, suggestion=&#34;take &lt;item&gt;&#34;)

        item_name = &#34; &#34;.join(tokens)

        # If we have scene context, try to match against available items
        if scene and scene.items:
            item = self._find_item_in_scene(item_name, scene)
            if item:
                return TakeAction(item_id=item.id, raw_command=command)

        # No context or no match, use the name as-is
        return TakeAction(item_id=item_name, raw_command=command)

    def _parse_drop(
        self, command: str, tokens: list[str], game_state: Optional[GameState]
    ) -&gt; Action:
        &#34;&#34;&#34;
        Parse a drop command.

        Args:
            command: The raw command string.
            tokens: Remaining tokens after command word.
            game_state: Optional game state for inventory context.

        Returns:
            A DropAction or UnknownAction.

        Examples:
            &gt;&gt;&gt; parser = CommandParser()
            &gt;&gt;&gt; action = parser._parse_drop(&#34;drop sword&#34;, [&#34;sword&#34;], None)
            &gt;&gt;&gt; action.item_id
            &#39;sword&#39;
        &#34;&#34;&#34;
        if not tokens:
            logger.debug(&#34;Drop command missing item&#34;)
            return UnknownAction(raw_command=command, suggestion=&#34;drop &lt;item&gt;&#34;)

        item_name = &#34; &#34;.join(tokens)

        # If we have game state, try to match against inventory
        if game_state and game_state.inventory:
            matches = difflib.get_close_matches(
                item_name, game_state.inventory, n=1, cutoff=self.CUTOFF
            )
            if matches:
                matched_item = matches[0]
                logger.debug(f&#34;Fuzzy matched inventory item: &#39;{item_name}&#39; -&gt; &#39;{matched_item}&#39;&#34;)
                return DropAction(item_id=matched_item, raw_command=command)

        # No context or no match, use the name as-is
        return DropAction(item_id=item_name, raw_command=command)

    def _parse_use(
        self,
        command: str,
        tokens: list[str],
        game_state: Optional[GameState],
        scene: Optional[Scene],
    ) -&gt; Action:
        &#34;&#34;&#34;
        Parse a use command.

        Handles both &#34;use item&#34; and &#34;use item on target&#34; formats.

        Args:
            command: The raw command string.
            tokens: Remaining tokens after command word.
            game_state: Optional game state for inventory context.
            scene: Optional current scene for context.

        Returns:
            A UseAction or UnknownAction.

        Examples:
            &gt;&gt;&gt; parser = CommandParser()
            &gt;&gt;&gt; action = parser._parse_use(&#34;use medkit&#34;, [&#34;medkit&#34;], None, None)
            &gt;&gt;&gt; action.item_id
            &#39;medkit&#39;

            &gt;&gt;&gt; action = parser._parse_use(&#34;use key on door&#34;, [&#34;key&#34;, &#34;on&#34;, &#34;door&#34;], None, None)
            &gt;&gt;&gt; action.item_id
            &#39;key&#39;
            &gt;&gt;&gt; action.target_id
            &#39;door&#39;
        &#34;&#34;&#34;
        if not tokens:
            logger.debug(&#34;Use command missing item&#34;)
            return UnknownAction(raw_command=command, suggestion=&#34;use &lt;item&gt; [on &lt;target&gt;]&#34;)

        # Look for &#34;on&#34; or &#34;with&#34; to separate item from target
        item_tokens = []
        target_tokens = []
        found_separator = False

        for i, token in enumerate(tokens):
            if token in [&#34;on&#34;, &#34;with&#34;, &#34;to&#34;]:
                found_separator = True
                item_tokens = tokens[:i]
                target_tokens = tokens[i + 1 :]
                break

        if not found_separator:
            item_tokens = tokens

        item_name = &#34; &#34;.join(item_tokens)
        target_name = &#34; &#34;.join(target_tokens) if target_tokens else None

        # Try to match item against inventory if we have game state
        item_id = item_name
        if game_state and game_state.inventory:
            matches = difflib.get_close_matches(
                item_name, game_state.inventory, n=1, cutoff=self.CUTOFF
            )
            if matches:
                item_id = matches[0]
                logger.debug(f&#34;Fuzzy matched use item: &#39;{item_name}&#39; -&gt; &#39;{item_id}&#39;&#34;)

        # Try to match target against scene items/NPCs if we have scene
        target_id = target_name
        if target_name and scene:
            # Check items
            if scene.items:
                item = self._find_item_in_scene(target_name, scene)
                if item:
                    target_id = item.id
            # Check NPCs
            if scene.npcs and target_id == target_name:
                npc = self._find_npc_in_scene(target_name, scene)
                if npc:
                    target_id = npc.id

        return UseAction(item_id=item_id, target_id=target_id, raw_command=command)

    def _parse_look(self, command: str, tokens: list[str], scene: Optional[Scene]) -&gt; Action:
        &#34;&#34;&#34;
        Parse a look/examine command.

        Args:
            command: The raw command string.
            tokens: Remaining tokens after command word.
            scene: Optional current scene for context.

        Returns:
            A LookAction.

        Examples:
            &gt;&gt;&gt; parser = CommandParser()
            &gt;&gt;&gt; action = parser._parse_look(&#34;look&#34;, [], None)
            &gt;&gt;&gt; action.target is None
            True

            &gt;&gt;&gt; action = parser._parse_look(&#34;examine console&#34;, [&#34;console&#34;], None)
            &gt;&gt;&gt; action.target
            &#39;console&#39;
        &#34;&#34;&#34;
        if not tokens:
            # Just &#34;look&#34; - examine the scene
            return LookAction(raw_command=command)

        # Filter out common words
        filter_words = {&#34;at&#34;, &#34;the&#34;, &#34;a&#34;, &#34;an&#34;}
        filtered_tokens = [t for t in tokens if t not in filter_words]

        if not filtered_tokens:
            return LookAction(raw_command=command)

        target_name = &#34; &#34;.join(filtered_tokens)

        # Try to match against scene items/NPCs if we have scene
        target_id = target_name
        if scene:
            # Check items
            if scene.items:
                item = self._find_item_in_scene(target_name, scene)
                if item:
                    target_id = item.id
            # Check NPCs
            if scene.npcs and target_id == target_name:
                npc = self._find_npc_in_scene(target_name, scene)
                if npc:
                    target_id = npc.id

        return LookAction(target=target_id, raw_command=command)

    def _parse_talk(self, command: str, tokens: list[str], scene: Optional[Scene]) -&gt; Action:
        &#34;&#34;&#34;
        Parse a talk command.

        Handles formats like:
        - &#34;talk to guard&#34;
        - &#34;ask guard about quest&#34;
        - &#34;tell guard about problem&#34;

        Args:
            command: The raw command string.
            tokens: Remaining tokens after command word.
            scene: Optional current scene for context.

        Returns:
            A TalkAction or UnknownAction.

        Examples:
            &gt;&gt;&gt; parser = CommandParser()
            &gt;&gt;&gt; action = parser._parse_talk(&#34;talk to guard&#34;, [&#34;to&#34;, &#34;guard&#34;], None)
            &gt;&gt;&gt; action.npc_id
            &#39;guard&#39;

            &gt;&gt;&gt; action = parser._parse_talk(&#34;ask guard about quest&#34;, [&#34;guard&#34;, &#34;about&#34;, &#34;quest&#34;], None)
            &gt;&gt;&gt; action.npc_id
            &#39;guard&#39;
            &gt;&gt;&gt; action.topic
            &#39;quest&#39;
        &#34;&#34;&#34;
        if not tokens:
            logger.debug(&#34;Talk command missing NPC&#34;)
            return UnknownAction(raw_command=command, suggestion=&#34;talk to &lt;NPC&gt;&#34;)

        # Remove common prepositions
        filter_words = {&#34;to&#34;, &#34;with&#34;}
        filtered_tokens = [t for t in tokens if t not in filter_words]

        if not filtered_tokens:
            return UnknownAction(raw_command=command, suggestion=&#34;talk to &lt;NPC&gt;&#34;)

        # Look for &#34;about&#34; to separate NPC from topic
        npc_tokens = []
        topic_tokens = []
        found_about = False

        for i, token in enumerate(filtered_tokens):
            if token == &#34;about&#34;:
                found_about = True
                npc_tokens = filtered_tokens[:i]
                topic_tokens = filtered_tokens[i + 1 :]
                break

        if not found_about:
            npc_tokens = filtered_tokens

        npc_name = &#34; &#34;.join(npc_tokens)
        topic = &#34; &#34;.join(topic_tokens) if topic_tokens else None

        # Try to match NPC against scene NPCs if we have scene
        npc_id = npc_name
        if scene and scene.npcs:
            npc = self._find_npc_in_scene(npc_name, scene)
            if npc:
                npc_id = npc.id
                logger.debug(f&#34;Matched NPC: &#39;{npc_name}&#39; -&gt; &#39;{npc_id}&#39;&#34;)

        return TalkAction(npc_id=npc_id, topic=topic, raw_command=command)

    def _find_item_in_scene(self, item_name: str, scene: Scene) -&gt; Optional[Item]:
        &#34;&#34;&#34;
        Find an item in the scene by name or ID using fuzzy matching.

        Args:
            item_name: The name or ID to search for.
            scene: The scene to search in.

        Returns:
            The matching Item object, or None if not found.

        Examples:
            &gt;&gt;&gt; from space_hulk_game.engine import Scene, Item
            &gt;&gt;&gt; item = Item(id=&#34;medkit&#34;, name=&#34;Medical Kit&#34;, description=&#34;A medkit.&#34;)
            &gt;&gt;&gt; scene = Scene(id=&#34;room&#34;, name=&#34;Room&#34;, description=&#34;A room.&#34;, items=[item])
            &gt;&gt;&gt; parser = CommandParser()
            &gt;&gt;&gt; found = parser._find_item_in_scene(&#34;medkit&#34;, scene)
            &gt;&gt;&gt; found.id
            &#39;medkit&#39;
        &#34;&#34;&#34;
        # Try exact match on ID first
        for item in scene.items:
            if item.id.lower() == item_name.lower():
                return item

        # Try exact match on name
        for item in scene.items:
            if item.name.lower() == item_name.lower():
                return item

        # Try fuzzy match on ID
        item_ids = [item.id.lower() for item in scene.items]
        matches = difflib.get_close_matches(item_name.lower(), item_ids, n=1, cutoff=self.CUTOFF)

        if matches:
            for item in scene.items:
                if item.id.lower() == matches[0]:
                    logger.debug(f&#34;Fuzzy matched item ID: &#39;{item_name}&#39; -&gt; &#39;{item.id}&#39;&#34;)
                    return item

        # Try fuzzy match on name
        item_names = [item.name.lower() for item in scene.items]
        matches = difflib.get_close_matches(item_name.lower(), item_names, n=1, cutoff=self.CUTOFF)

        if matches:
            for item in scene.items:
                if item.name.lower() == matches[0]:
                    logger.debug(f&#34;Fuzzy matched item name: &#39;{item_name}&#39; -&gt; &#39;{item.name}&#39;&#34;)
                    return item

        return None

    def _find_npc_in_scene(self, npc_name: str, scene: Scene) -&gt; Optional[NPC]:
        &#34;&#34;&#34;
        Find an NPC in the scene by name or ID using fuzzy matching.

        Args:
            npc_name: The name or ID to search for.
            scene: The scene to search in.

        Returns:
            The matching NPC object, or None if not found.

        Examples:
            &gt;&gt;&gt; from space_hulk_game.engine import Scene, NPC
            &gt;&gt;&gt; npc = NPC(id=&#34;guard&#34;, name=&#34;Imperial Guard&#34;, description=&#34;A guard.&#34;)
            &gt;&gt;&gt; scene = Scene(id=&#34;room&#34;, name=&#34;Room&#34;, description=&#34;A room.&#34;, npcs=[npc])
            &gt;&gt;&gt; parser = CommandParser()
            &gt;&gt;&gt; found = parser._find_npc_in_scene(&#34;guard&#34;, scene)
            &gt;&gt;&gt; found.id
            &#39;guard&#39;
        &#34;&#34;&#34;
        # Try exact match on ID first
        for npc in scene.npcs:
            if npc.id.lower() == npc_name.lower():
                return npc

        # Try exact match on name
        for npc in scene.npcs:
            if npc.name.lower() == npc_name.lower():
                return npc

        # Try fuzzy match on ID
        npc_ids = [npc.id.lower() for npc in scene.npcs]
        matches = difflib.get_close_matches(npc_name.lower(), npc_ids, n=1, cutoff=self.CUTOFF)

        if matches:
            for npc in scene.npcs:
                if npc.id.lower() == matches[0]:
                    logger.debug(f&#34;Fuzzy matched NPC ID: &#39;{npc_name}&#39; -&gt; &#39;{npc.id}&#39;&#34;)
                    return npc

        # Try fuzzy match on name
        npc_names = [npc.name.lower() for npc in scene.npcs]
        matches = difflib.get_close_matches(npc_name.lower(), npc_names, n=1, cutoff=self.CUTOFF)

        if matches:
            for npc in scene.npcs:
                if npc.name.lower() == matches[0]:
                    logger.debug(f&#34;Fuzzy matched NPC name: &#39;{npc_name}&#39; -&gt; &#39;{npc.name}&#39;&#34;)
                    return npc

        return None</code></pre>
</details>
<div class="desc"><p>Parses natural language commands into Action objects.</p>
<p>This class implements a facade pattern for command parsing, providing
a simple interface that hides the complexity of synonym matching,
fuzzy matching, and context-aware parsing.</p>
<p>The parser is designed to be forgiving and helpful, using fuzzy matching
for typos and providing suggestions when commands aren't recognized.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>COMMANDS</code></strong></dt>
<dd>Dictionary mapping action types to lists of synonyms.</dd>
<dt><strong><code>CUTOFF</code></strong></dt>
<dd>Minimum similarity score for fuzzy matching (0.0 to 1.0).</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Basic usage:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; parser = CommandParser()
&gt;&gt;&gt; action = parser.parse(&quot;go north&quot;)
&gt;&gt;&gt; isinstance(action, MoveAction)
True
</code></pre>
<p>With context for better suggestions:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from space_hulk_game.engine import GameState, Scene
&gt;&gt;&gt; state = GameState(current_scene=&quot;room&quot;)
&gt;&gt;&gt; scene = Scene(id=&quot;room&quot;, name=&quot;Room&quot;, description=&quot;A room.&quot;,
...               exits={&quot;north&quot;: &quot;hallway&quot;})
&gt;&gt;&gt; action = parser.parse(&quot;go nrth&quot;, state, scene)  # typo
&gt;&gt;&gt; isinstance(action, MoveAction)
True
</code></pre>
<p>Initialize the command parser.</p></div>
<h3>Class variables</h3>
<dl>
<dt id="space_hulk_game.engine.CommandParser.COMMANDS"><code class="name">var <span class="ident">COMMANDS</span> : dict[str, list[str]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.CommandParser.CUTOFF"><code class="name">var <span class="ident">CUTOFF</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="space_hulk_game.engine.CommandParser.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self,<br>command: str,<br>game_state: <a title="space_hulk_game.engine.game_state.GameState" href="game_state.html#space_hulk_game.engine.game_state.GameState">GameState</a> | None = None,<br>current_scene: <a title="space_hulk_game.engine.scene.Scene" href="scene.html#space_hulk_game.engine.scene.Scene">Scene</a> | None = None) ‑> <a title="space_hulk_game.engine.actions.Action" href="actions.html#space_hulk_game.engine.actions.Action">Action</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(
    self,
    command: str,
    game_state: Optional[GameState] = None,
    current_scene: Optional[Scene] = None,
) -&gt; Action:
    &#34;&#34;&#34;
    Parse a text command into an Action object.

    This is the main entry point for command parsing. It handles:
    1. Text normalization and tokenization
    2. Command word identification (with fuzzy matching)
    3. Argument extraction
    4. Context-aware parsing
    5. Action object creation

    Args:
        command: The raw text command from the player.
        game_state: Optional current game state for context.
        current_scene: Optional current scene for context.

    Returns:
        An Action object representing the parsed command.

    Examples:
        &gt;&gt;&gt; parser = CommandParser()
        &gt;&gt;&gt; action = parser.parse(&#34;go north&#34;)
        &gt;&gt;&gt; action.direction
        &#39;north&#39;

        &gt;&gt;&gt; action = parser.parse(&#34;take medkit&#34;)
        &gt;&gt;&gt; action.item_id
        &#39;medkit&#39;

        &gt;&gt;&gt; action = parser.parse(&#34;look&#34;)
        &gt;&gt;&gt; isinstance(action, LookAction)
        True
    &#34;&#34;&#34;
    # Normalize input
    command = command.strip().lower()

    if not command:
        logger.debug(&#34;Empty command received&#34;)
        return UnknownAction(raw_command=&#34;&#34;)

    logger.debug(f&#34;Parsing command: &#39;{command}&#39;&#34;)

    # Tokenize command
    tokens = self._tokenize(command)

    if not tokens:
        return UnknownAction(raw_command=command)

    # Identify command type
    action_type, command_word, remaining_tokens = self._identify_command(tokens)

    if not action_type:
        # Try to find a close match
        suggestion = self._suggest_command(command_word)
        logger.debug(f&#34;Unknown command: &#39;{command_word}&#39;, suggestion: &#39;{suggestion}&#39;&#34;)
        return UnknownAction(raw_command=command, suggestion=suggestion)

    # Parse based on action type
    logger.debug(f&#34;Identified action type: {action_type}&#34;)

    if action_type == &#34;move&#34;:
        return self._parse_move(command, remaining_tokens, current_scene)
    elif action_type == &#34;take&#34;:
        return self._parse_take(command, remaining_tokens, current_scene)
    elif action_type == &#34;drop&#34;:
        return self._parse_drop(command, remaining_tokens, game_state)
    elif action_type == &#34;use&#34;:
        return self._parse_use(command, remaining_tokens, game_state, current_scene)
    elif action_type == &#34;look&#34;:
        return self._parse_look(command, remaining_tokens, current_scene)
    elif action_type == &#34;inventory&#34;:
        return InventoryAction(raw_command=command)
    elif action_type == &#34;talk&#34;:
        return self._parse_talk(command, remaining_tokens, current_scene)
    elif action_type == &#34;help&#34;:
        return HelpAction(raw_command=command)
    else:
        return UnknownAction(raw_command=command)</code></pre>
</details>
<div class="desc"><p>Parse a text command into an Action object.</p>
<p>This is the main entry point for command parsing. It handles:
1. Text normalization and tokenization
2. Command word identification (with fuzzy matching)
3. Argument extraction
4. Context-aware parsing
5. Action object creation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong></dt>
<dd>The raw text command from the player.</dd>
<dt><strong><code>game_state</code></strong></dt>
<dd>Optional current game state for context.</dd>
<dt><strong><code>current_scene</code></strong></dt>
<dd>Optional current scene for context.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An Action object representing the parsed command.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; parser = CommandParser()
&gt;&gt;&gt; action = parser.parse(&quot;go north&quot;)
&gt;&gt;&gt; action.direction
'north'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; action = parser.parse(&quot;take medkit&quot;)
&gt;&gt;&gt; action.item_id
'medkit'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; action = parser.parse(&quot;look&quot;)
&gt;&gt;&gt; isinstance(action, LookAction)
True
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.engine.ContentLoader"><code class="flex name class">
<span>class <span class="ident">ContentLoader</span></span>
<span>(</span><span>strict_mode: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContentLoader:
    &#34;&#34;&#34;
    Loads AI-generated YAML files and converts them into GameData.

    The ContentLoader implements a Facade pattern to simplify the complex process
    of loading and merging multiple YAML files. It uses Strategy pattern internally
    for handling different file formats and Builder pattern for constructing GameData.

    Attributes:
        strict_mode: If True, raises exceptions on validation errors.
                    If False, logs warnings and uses defaults.

    Examples:
        Load a complete game:
        &gt;&gt;&gt; loader = ContentLoader()
        &gt;&gt;&gt; game_data = loader.load_game(&#34;game-config/&#34;)
        &gt;&gt;&gt; print(f&#34;Loaded: {game_data.title}&#34;)

        Load with lenient error handling:
        &gt;&gt;&gt; loader = ContentLoader(strict_mode=False)
        &gt;&gt;&gt; game_data = loader.load_game(&#34;game-config/&#34;)

        Load individual files:
        &gt;&gt;&gt; plot_data = loader.load_yaml(&#34;game-config/plot_outline.yaml&#34;)
    &#34;&#34;&#34;

    def __init__(self, strict_mode: bool = False):
        &#34;&#34;&#34;
        Initialize the ContentLoader.

        Args:
            strict_mode: If True, raise exceptions on validation errors.
                        If False, log warnings and use defaults.
        &#34;&#34;&#34;
        self.strict_mode = strict_mode
        logger.info(f&#34;ContentLoader initialized (strict_mode={strict_mode})&#34;)

    def load_game(self, output_dir: str) -&gt; GameData:
        &#34;&#34;&#34;
        Load all generated YAML files into a playable game.

        This is the main entry point for loading a complete game. It loads
        all 5 YAML files, validates them, converts them to engine objects,
        and merges them into a single GameData structure.

        Args:
            output_dir: Directory containing the generated YAML files.

        Returns:
            GameData object containing all loaded content.

        Raises:
            LoaderError: If critical files are missing or invalid.

        Examples:
            &gt;&gt;&gt; loader = ContentLoader()
            &gt;&gt;&gt; game_data = loader.load_game(&#34;game-config/&#34;)
            &gt;&gt;&gt; len(game_data.scenes) &gt; 0
            True
        &#34;&#34;&#34;
        logger.info(f&#34;Loading game from directory: {output_dir}&#34;)

        # Load all YAML files
        plot = self.load_yaml(os.path.join(output_dir, &#34;plot_outline.yaml&#34;))
        narrative = self.load_yaml(os.path.join(output_dir, &#34;narrative_map.yaml&#34;))
        puzzles = self.load_yaml(os.path.join(output_dir, &#34;puzzle_design.yaml&#34;))
        scenes = self.load_yaml(os.path.join(output_dir, &#34;scene_texts.yaml&#34;))
        mechanics = self.load_yaml(os.path.join(output_dir, &#34;prd_document.yaml&#34;))

        logger.info(&#34;All YAML files loaded successfully&#34;)

        # Merge into GameData
        game_data = self.merge_into_game_data(plot, narrative, puzzles, scenes, mechanics)

        logger.info(f&#34;Game loaded: &#39;{game_data.title}&#39; with {len(game_data.scenes)} scenes&#34;)
        return game_data

    def load_yaml(self, filepath: str) -&gt; dict[str, Any]:
        &#34;&#34;&#34;
        Load and parse a YAML file with error handling.

        Handles common issues with AI-generated YAML:
        - Markdown code fence wrapping (```yaml ... ```)
        - Extra whitespace
        - Missing files
        - Invalid YAML syntax

        Args:
            filepath: Path to the YAML file to load.

        Returns:
            Parsed YAML content as a dictionary.

        Raises:
            LoaderError: If file is missing or cannot be parsed.

        Examples:
            &gt;&gt;&gt; loader = ContentLoader()
            &gt;&gt;&gt; data = loader.load_yaml(&#34;game-config/plot_outline.yaml&#34;)
            &gt;&gt;&gt; isinstance(data, dict)
            True
        &#34;&#34;&#34;
        logger.debug(f&#34;Loading YAML file: {filepath}&#34;)

        # Check if file exists
        if not os.path.exists(filepath):
            error_msg = f&#34;File not found: {filepath}&#34;
            logger.error(error_msg)
            if self.strict_mode:
                raise LoaderError(error_msg)
            else:
                logger.warning(f&#34;File missing, returning empty dict: {filepath}&#34;)
                return {}

        try:
            # Read file content
            with open(filepath, encoding=&#34;utf-8&#34;) as f:
                content = f.read()

            # Clean up markdown wrapping (common AI output issue)
            content = self._clean_yaml_content(content)

            # Parse YAML
            data = yaml.safe_load(content)

            if data is None:
                logger.warning(f&#34;Empty YAML file: {filepath}&#34;)
                return {}

            if not isinstance(data, dict):
                error_msg = f&#34;Invalid YAML structure in {filepath}: expected dict, got {type(data)}&#34;
                logger.error(error_msg)
                if self.strict_mode:
                    raise YAMLParseError(error_msg)
                return {}

            logger.debug(f&#34;Successfully loaded {filepath}: {len(data)} top-level keys&#34;)
            return data

        except yaml.YAMLError as e:
            error_msg = f&#34;YAML parsing error in {filepath}: {e}&#34;
            logger.error(error_msg)
            if self.strict_mode:
                raise YAMLParseError(error_msg) from e
            else:
                logger.warning(f&#34;YAML error, returning empty dict: {filepath}&#34;)
                return {}
        except Exception as e:
            error_msg = f&#34;Unexpected error loading {filepath}: {e}&#34;
            logger.error(error_msg)
            if self.strict_mode:
                raise LoaderError(error_msg) from e
            else:
                logger.warning(f&#34;Error loading file, returning empty dict: {filepath}&#34;)
                return {}

    def _clean_yaml_content(self, content: str) -&gt; str:
        &#34;&#34;&#34;
        Clean up common issues in AI-generated YAML content.

        Specifically, this method:
            - Removes markdown code fences (e.g., ```yaml ... ```) that may wrap YAML content.
            - Strips leading and trailing whitespace from the content.

        Args:
            content: Raw YAML content string.

        Returns:
            Cleaned YAML content with code fences and extraneous whitespace removed.
        &#34;&#34;&#34;
        # Remove markdown code fences
        content = re.sub(r&#34;^```ya?ml\s*\n&#34;, &#34;&#34;, content, flags=re.MULTILINE)
        content = re.sub(r&#34;\n```\s*$&#34;, &#34;&#34;, content, flags=re.MULTILINE)

        # Strip leading/trailing whitespace
        content = content.strip()

        return content

    def merge_into_game_data(
        self,
        plot: dict[str, Any],
        narrative: dict[str, Any],
        puzzles: dict[str, Any],
        scenes_text: dict[str, Any],
        mechanics: dict[str, Any],
    ) -&gt; GameData:
        &#34;&#34;&#34;
        Merge all loaded YAML data into a GameData object.

        This method implements the core conversion logic, transforming
        the YAML structures into Scene, Item, NPC, and Event objects.

        Args:
            plot: Data from plot_outline.yaml
            narrative: Data from narrative_map.yaml
            puzzles: Data from puzzle_design.yaml
            scenes_text: Data from scene_texts.yaml
            mechanics: Data from prd_document.yaml

        Returns:
            Complete GameData object.

        Raises:
            ValidationError: If required data is missing.
        &#34;&#34;&#34;
        logger.info(&#34;Merging YAML data into GameData&#34;)

        # Extract title and description
        title = self._extract_title(plot, narrative, mechanics)
        description = self._extract_description(plot, mechanics)

        # Build scenes from narrative map
        scenes = self._build_scenes(narrative, scenes_text, puzzles)

        # Find starting scene
        starting_scene = self._find_starting_scene(narrative, scenes)

        # Extract global items and NPCs
        global_items = self._extract_global_items(puzzles)
        global_npcs = self._extract_global_npcs(puzzles)

        # Extract additional data
        themes = self._extract_themes(plot)
        plot_points = self._extract_plot_points(plot)
        endings = self._extract_endings(plot)
        game_rules = self._extract_game_rules(mechanics)

        # Build GameData
        game_data = GameData(
            title=title,
            description=description,
            scenes=scenes,
            starting_scene=starting_scene,
            global_items=global_items,
            global_npcs=global_npcs,
            themes=themes,
            plot_points=plot_points,
            endings=endings,
            game_rules=game_rules,
            metadata={
                &#34;loaded_from_ai&#34;: True,
                &#34;source_files&#34;: [
                    &#34;plot_outline&#34;,
                    &#34;narrative_map&#34;,
                    &#34;puzzle_design&#34;,
                    &#34;scene_texts&#34;,
                    &#34;prd_document&#34;,
                ],
            },
        )

        logger.info(&#34;GameData merge complete&#34;)
        return game_data

    def _extract_title(self, plot: dict, narrative: dict, mechanics: dict) -&gt; str:
        &#34;&#34;&#34;Extract game title from available sources.&#34;&#34;&#34;
        # Try multiple sources
        title = (
            plot.get(&#34;narrative_foundation&#34;, {}).get(&#34;title&#34;)
            or narrative.get(&#34;title&#34;)
            or mechanics.get(&#34;title&#34;)
            or mechanics.get(&#34;game_title&#34;)
            or &#34;Untitled Space Hulk Adventure&#34;
        )
        logger.debug(f&#34;Extracted title: {title}&#34;)
        return title

    def _extract_description(self, plot: dict, mechanics: dict) -&gt; str:
        &#34;&#34;&#34;Extract game description from available sources.&#34;&#34;&#34;
        description = (
            plot.get(&#34;narrative_foundation&#34;, {}).get(&#34;setting&#34;)
            or mechanics.get(&#34;description&#34;)
            or mechanics.get(&#34;game_overview&#34;)
            or &#34;A text adventure set in the grim darkness of the far future.&#34;
        )
        logger.debug(f&#34;Extracted description: {description[:50]}...&#34;)
        return description

    def _extract_themes(self, plot: dict) -&gt; list[str]:
        &#34;&#34;&#34;Extract narrative themes from plot data.&#34;&#34;&#34;
        foundation = plot.get(&#34;narrative_foundation&#34;, {})
        themes = foundation.get(&#34;themes&#34;, [])

        if isinstance(themes, str):
            # Handle single theme as string
            themes = [themes]

        logger.debug(f&#34;Extracted {len(themes)} themes&#34;)
        return list(themes) if themes else []

    def _extract_plot_points(self, plot: dict) -&gt; list[dict[str, Any]]:
        &#34;&#34;&#34;Extract major plot points from plot data.&#34;&#34;&#34;
        foundation = plot.get(&#34;narrative_foundation&#34;, {})
        plot_points = foundation.get(&#34;plot_points&#34;, [])

        if not isinstance(plot_points, list):
            logger.warning(f&#34;Invalid plot_points format: {type(plot_points)}&#34;)
            return []

        logger.debug(f&#34;Extracted {len(plot_points)} plot points&#34;)
        return plot_points

    def _extract_endings(self, plot: dict) -&gt; list[dict[str, Any]]:
        &#34;&#34;&#34;Extract possible endings from plot data.&#34;&#34;&#34;
        foundation = plot.get(&#34;narrative_foundation&#34;, {})
        endings = foundation.get(&#34;endings&#34;, [])

        if not isinstance(endings, list):
            logger.warning(f&#34;Invalid endings format: {type(endings)}&#34;)
            return []

        logger.debug(f&#34;Extracted {len(endings)} endings&#34;)
        return endings

    def _extract_game_rules(self, mechanics: dict) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Extract game mechanics and rules.&#34;&#34;&#34;
        rules = {}

        # Common keys in PRD documents
        for key in [&#34;mechanics&#34;, &#34;game_mechanics&#34;, &#34;rules&#34;, &#34;systems&#34;]:
            if key in mechanics:
                rules[key] = mechanics[key]

        logger.debug(f&#34;Extracted {len(rules)} game rule categories&#34;)
        return rules

    def _build_scenes(self, narrative: dict, scenes_text: dict, puzzles: dict) -&gt; dict[str, Scene]:
        &#34;&#34;&#34;
        Build Scene objects from narrative map and scene texts.

        Args:
            narrative: Narrative map data.
            scenes_text: Scene description data.
            puzzles: Puzzle and artifact data.

        Returns:
            Dictionary mapping scene IDs to Scene objects.
        &#34;&#34;&#34;
        logger.info(&#34;Building scenes from narrative data&#34;)

        scenes = {}

        # Get scene data from narrative map
        narrative_scenes = (
            narrative.get(&#34;narrative_map&#34;, {}).get(&#34;scenes&#34;, {})
            or narrative.get(&#34;scenes&#34;, {})
            or {}
        )

        if not narrative_scenes:
            logger.warning(&#34;No scenes found in narrative map&#34;)
            # Create a default starting scene
            default_scene = Scene(
                id=&#34;start&#34;,
                name=&#34;Starting Location&#34;,
                description=&#34;The adventure begins here.&#34;,
                exits={},
            )
            return {&#34;start&#34;: default_scene}

        # Build each scene
        for scene_id, scene_data in narrative_scenes.items():
            try:
                scene = self._build_single_scene(scene_id, scene_data, scenes_text, puzzles)
                scenes[scene_id] = scene
                logger.debug(f&#34;Built scene: {scene_id}&#34;)
            except Exception as e:
                logger.error(f&#34;Error building scene &#39;{scene_id}&#39;: {e}&#34;)
                if self.strict_mode:
                    raise ValidationError(f&#34;Failed to build scene &#39;{scene_id}&#39;: {e}&#34;) from e

        if not scenes:
            logger.error(&#34;No scenes were successfully built&#34;)
            if self.strict_mode:
                raise ValidationError(&#34;No valid scenes found&#34;)
            # Create fallback scene
            scenes[&#34;start&#34;] = Scene(
                id=&#34;start&#34;, name=&#34;Starting Location&#34;, description=&#34;The adventure begins.&#34;, exits={}
            )

        logger.info(f&#34;Built {len(scenes)} scenes&#34;)
        return scenes

    def _build_single_scene(
        self, scene_id: str, scene_data: dict, scenes_text: dict, puzzles: dict
    ) -&gt; Scene:
        &#34;&#34;&#34;
        Build a single Scene object from its data.

        Args:
            scene_id: The scene&#39;s unique identifier.
            scene_data: Scene data from narrative map.
            scenes_text: All scene text data.
            puzzles: Puzzle and artifact data.

        Returns:
            Constructed Scene object.
        &#34;&#34;&#34;
        # Extract name and description
        name = scene_data.get(&#34;name&#34;, scene_id.replace(&#34;_&#34;, &#34; &#34;).title())

        # Look for description in scene_data or scenes_text
        description = (
            scene_data.get(&#34;description&#34;)
            or scenes_text.get(scene_id, {}).get(&#34;description&#34;)
            or &#34;A location in the Space Hulk.&#34;
        )

        # Extract exits/connections
        exits = self._extract_exits(scene_data)

        # Extract items
        items = self._extract_scene_items(scene_data, puzzles)

        # Extract NPCs
        npcs = self._extract_scene_npcs(scene_data, puzzles)

        # Extract events
        events = self._extract_scene_events(scene_data)

        # Extract additional properties
        dark = scene_data.get(&#34;dark&#34;, False)
        locked_exits = scene_data.get(&#34;locked_exits&#34;, {})

        scene = Scene(
            id=scene_id,
            name=name,
            description=description,
            exits=exits,
            items=items,
            npcs=npcs,
            events=events,
            dark=dark,
            locked_exits=locked_exits,
        )

        return scene

    def _extract_exits(self, scene_data: dict) -&gt; dict[str, str]:
        &#34;&#34;&#34;Extract exits from scene data.&#34;&#34;&#34;
        exits = scene_data.get(&#34;exits&#34;, {}) or scene_data.get(&#34;connections&#34;, {}) or {}

        # Normalize exits to dict
        if isinstance(exits, list):
            # Convert list of exit names to dict
            exits_dict = {}
            for exit_item in exits:
                if isinstance(exit_item, str):
                    exits_dict[exit_item] = exit_item
                elif isinstance(exit_item, dict):
                    direction = exit_item.get(&#34;direction&#34;) or exit_item.get(&#34;name&#34;)
                    target = exit_item.get(&#34;target&#34;) or exit_item.get(&#34;scene_id&#34;)
                    if direction and target:
                        exits_dict[direction] = target
            exits = exits_dict

        return exits if isinstance(exits, dict) else {}

    def _extract_scene_items(self, scene_data: dict, puzzles: dict) -&gt; list[Item]:
        &#34;&#34;&#34;Extract items present in this scene.&#34;&#34;&#34;
        items = []
        item_ids = scene_data.get(&#34;items&#34;, []) or []

        if not isinstance(item_ids, list):
            item_ids = [item_ids]

        # Get item definitions from puzzles
        item_definitions = puzzles.get(&#34;artifacts&#34;, {}) or puzzles.get(&#34;items&#34;, {}) or {}

        for item_id in item_ids:
            if isinstance(item_id, str):
                item_def = item_definitions.get(item_id, {})
                if item_def:
                    try:
                        item = self._build_item(item_id, item_def)
                        items.append(item)
                    except Exception as e:
                        logger.warning(f&#34;Failed to build item &#39;{item_id}&#39;: {e}&#34;)

        return items

    def _extract_scene_npcs(self, scene_data: dict, puzzles: dict) -&gt; list[NPC]:
        &#34;&#34;&#34;Extract NPCs present in this scene.&#34;&#34;&#34;
        npcs = []
        npc_ids = scene_data.get(&#34;npcs&#34;, []) or []

        if not isinstance(npc_ids, list):
            npc_ids = [npc_ids]

        # Get NPC definitions from puzzles
        npc_definitions = puzzles.get(&#34;npcs&#34;, {}) or puzzles.get(&#34;characters&#34;, {}) or {}

        for npc_id in npc_ids:
            if isinstance(npc_id, str):
                npc_def = npc_definitions.get(npc_id, {})
                if npc_def:
                    try:
                        npc = self._build_npc(npc_id, npc_def)
                        npcs.append(npc)
                    except Exception as e:
                        logger.warning(f&#34;Failed to build NPC &#39;{npc_id}&#39;: {e}&#34;)

        return npcs

    def _extract_scene_events(self, scene_data: dict) -&gt; list[Event]:
        &#34;&#34;&#34;Extract events that can trigger in this scene.&#34;&#34;&#34;
        events = []
        event_list = scene_data.get(&#34;events&#34;, []) or []

        if not isinstance(event_list, list):
            event_list = [event_list]

        for event_data in event_list:
            if isinstance(event_data, dict):
                try:
                    event = self._build_event(event_data)
                    events.append(event)
                except Exception as e:
                    logger.warning(f&#34;Failed to build event: {e}&#34;)

        return events

    def _build_item(self, item_id: str, item_def: dict) -&gt; Item:
        &#34;&#34;&#34;Build an Item object from its definition.&#34;&#34;&#34;
        return Item(
            id=item_id,
            name=item_def.get(&#34;name&#34;, item_id.replace(&#34;_&#34;, &#34; &#34;).title()),
            description=item_def.get(&#34;description&#34;, &#34;An item.&#34;),
            takeable=item_def.get(&#34;takeable&#34;, True),
            useable=item_def.get(&#34;useable&#34;, False),
            use_text=item_def.get(&#34;use_text&#34;),
            required_flag=item_def.get(&#34;required_flag&#34;),
            effects=item_def.get(&#34;effects&#34;, {}),
        )

    def _build_npc(self, npc_id: str, npc_def: dict) -&gt; NPC:
        &#34;&#34;&#34;Build an NPC object from its definition.&#34;&#34;&#34;
        return NPC(
            id=npc_id,
            name=npc_def.get(&#34;name&#34;, npc_id.replace(&#34;_&#34;, &#34; &#34;).title()),
            description=npc_def.get(&#34;description&#34;, &#34;A character.&#34;),
            dialogue=npc_def.get(&#34;dialogue&#34;, {}),
            hostile=npc_def.get(&#34;hostile&#34;, False),
            health=npc_def.get(&#34;health&#34;, 100),
            gives_item=npc_def.get(&#34;gives_item&#34;),
            required_flag=npc_def.get(&#34;required_flag&#34;),
        )

    def _build_event(self, event_data: dict) -&gt; Event:
        &#34;&#34;&#34;Build an Event object from its data.&#34;&#34;&#34;
        return Event(
            id=event_data.get(&#34;id&#34;, &#34;event&#34;),
            description=event_data.get(&#34;description&#34;, &#34;Something happens.&#34;),
            trigger_on_entry=event_data.get(&#34;trigger_on_entry&#34;, False),
            required_flag=event_data.get(&#34;required_flag&#34;),
            one_time=event_data.get(&#34;one_time&#34;, True),
            effects=event_data.get(&#34;effects&#34;, {}),
        )

    def _extract_global_items(self, puzzles: dict) -&gt; dict[str, Item]:
        &#34;&#34;&#34;Extract global item definitions (not placed in scenes).&#34;&#34;&#34;
        global_items = {}

        item_defs = puzzles.get(&#34;artifacts&#34;, {}) or puzzles.get(&#34;items&#34;, {}) or {}

        for item_id, item_def in item_defs.items():
            if isinstance(item_def, dict):
                try:
                    item = self._build_item(item_id, item_def)
                    global_items[item_id] = item
                except Exception as e:
                    logger.warning(f&#34;Failed to build global item &#39;{item_id}&#39;: {e}&#34;)

        logger.debug(f&#34;Extracted {len(global_items)} global items&#34;)
        return global_items

    def _extract_global_npcs(self, puzzles: dict) -&gt; dict[str, NPC]:
        &#34;&#34;&#34;Extract global NPC definitions (not placed in scenes).&#34;&#34;&#34;
        global_npcs = {}

        npc_defs = puzzles.get(&#34;npcs&#34;, {}) or puzzles.get(&#34;characters&#34;, {}) or {}

        for npc_id, npc_def in npc_defs.items():
            if isinstance(npc_def, dict):
                try:
                    npc = self._build_npc(npc_id, npc_def)
                    global_npcs[npc_id] = npc
                except Exception as e:
                    logger.warning(f&#34;Failed to build global NPC &#39;{npc_id}&#39;: {e}&#34;)

        logger.debug(f&#34;Extracted {len(global_npcs)} global NPCs&#34;)
        return global_npcs

    def _find_starting_scene(self, narrative: dict, scenes: dict[str, Scene]) -&gt; str:
        &#34;&#34;&#34;Find the starting scene ID.&#34;&#34;&#34;
        # Try to find explicitly defined starting scene
        starting_scene = (
            narrative.get(&#34;starting_scene&#34;)
            or narrative.get(&#34;narrative_map&#34;, {}).get(&#34;starting_scene&#34;)
            or narrative.get(&#34;start_scene&#34;)
        )

        if starting_scene and starting_scene in scenes:
            logger.debug(f&#34;Found starting scene: {starting_scene}&#34;)
            return starting_scene

        # Fall back to first scene or &#39;start&#39;
        if &#34;start&#34; in scenes:
            logger.debug(&#34;Using &#39;start&#39; as starting scene&#34;)
            return &#34;start&#34;

        if scenes:
            first_scene = next(iter(scenes.keys()))
            logger.debug(f&#34;Using first scene as starting scene: {first_scene}&#34;)
            return first_scene

        # This should not happen if scenes validation passed
        logger.error(&#34;No starting scene found&#34;)
        if self.strict_mode:
            raise ValidationError(&#34;No starting scene found&#34;)
        return &#34;start&#34;</code></pre>
</details>
<div class="desc"><p>Loads AI-generated YAML files and converts them into GameData.</p>
<p>The ContentLoader implements a Facade pattern to simplify the complex process
of loading and merging multiple YAML files. It uses Strategy pattern internally
for handling different file formats and Builder pattern for constructing GameData.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>strict_mode</code></strong></dt>
<dd>If True, raises exceptions on validation errors.
If False, logs warnings and uses defaults.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Load a complete game:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; loader = ContentLoader()
&gt;&gt;&gt; game_data = loader.load_game(&quot;game-config/&quot;)
&gt;&gt;&gt; print(f&quot;Loaded: {game_data.title}&quot;)
</code></pre>
<p>Load with lenient error handling:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; loader = ContentLoader(strict_mode=False)
&gt;&gt;&gt; game_data = loader.load_game(&quot;game-config/&quot;)
</code></pre>
<p>Load individual files:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; plot_data = loader.load_yaml(&quot;game-config/plot_outline.yaml&quot;)
</code></pre>
<p>Initialize the ContentLoader.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>strict_mode</code></strong></dt>
<dd>If True, raise exceptions on validation errors.
If False, log warnings and use defaults.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="space_hulk_game.engine.ContentLoader.load_game"><code class="name flex">
<span>def <span class="ident">load_game</span></span>(<span>self, output_dir: str) ‑> <a title="space_hulk_game.engine.game_data.GameData" href="game_data.html#space_hulk_game.engine.game_data.GameData">GameData</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_game(self, output_dir: str) -&gt; GameData:
    &#34;&#34;&#34;
    Load all generated YAML files into a playable game.

    This is the main entry point for loading a complete game. It loads
    all 5 YAML files, validates them, converts them to engine objects,
    and merges them into a single GameData structure.

    Args:
        output_dir: Directory containing the generated YAML files.

    Returns:
        GameData object containing all loaded content.

    Raises:
        LoaderError: If critical files are missing or invalid.

    Examples:
        &gt;&gt;&gt; loader = ContentLoader()
        &gt;&gt;&gt; game_data = loader.load_game(&#34;game-config/&#34;)
        &gt;&gt;&gt; len(game_data.scenes) &gt; 0
        True
    &#34;&#34;&#34;
    logger.info(f&#34;Loading game from directory: {output_dir}&#34;)

    # Load all YAML files
    plot = self.load_yaml(os.path.join(output_dir, &#34;plot_outline.yaml&#34;))
    narrative = self.load_yaml(os.path.join(output_dir, &#34;narrative_map.yaml&#34;))
    puzzles = self.load_yaml(os.path.join(output_dir, &#34;puzzle_design.yaml&#34;))
    scenes = self.load_yaml(os.path.join(output_dir, &#34;scene_texts.yaml&#34;))
    mechanics = self.load_yaml(os.path.join(output_dir, &#34;prd_document.yaml&#34;))

    logger.info(&#34;All YAML files loaded successfully&#34;)

    # Merge into GameData
    game_data = self.merge_into_game_data(plot, narrative, puzzles, scenes, mechanics)

    logger.info(f&#34;Game loaded: &#39;{game_data.title}&#39; with {len(game_data.scenes)} scenes&#34;)
    return game_data</code></pre>
</details>
<div class="desc"><p>Load all generated YAML files into a playable game.</p>
<p>This is the main entry point for loading a complete game. It loads
all 5 YAML files, validates them, converts them to engine objects,
and merges them into a single GameData structure.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>output_dir</code></strong></dt>
<dd>Directory containing the generated YAML files.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>GameData object containing all loaded content.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="space_hulk_game.engine.LoaderError" href="#space_hulk_game.engine.LoaderError">LoaderError</a></code></dt>
<dd>If critical files are missing or invalid.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; loader = ContentLoader()
&gt;&gt;&gt; game_data = loader.load_game(&quot;game-config/&quot;)
&gt;&gt;&gt; len(game_data.scenes) &gt; 0
True
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.ContentLoader.load_yaml"><code class="name flex">
<span>def <span class="ident">load_yaml</span></span>(<span>self, filepath: str) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_yaml(self, filepath: str) -&gt; dict[str, Any]:
    &#34;&#34;&#34;
    Load and parse a YAML file with error handling.

    Handles common issues with AI-generated YAML:
    - Markdown code fence wrapping (```yaml ... ```)
    - Extra whitespace
    - Missing files
    - Invalid YAML syntax

    Args:
        filepath: Path to the YAML file to load.

    Returns:
        Parsed YAML content as a dictionary.

    Raises:
        LoaderError: If file is missing or cannot be parsed.

    Examples:
        &gt;&gt;&gt; loader = ContentLoader()
        &gt;&gt;&gt; data = loader.load_yaml(&#34;game-config/plot_outline.yaml&#34;)
        &gt;&gt;&gt; isinstance(data, dict)
        True
    &#34;&#34;&#34;
    logger.debug(f&#34;Loading YAML file: {filepath}&#34;)

    # Check if file exists
    if not os.path.exists(filepath):
        error_msg = f&#34;File not found: {filepath}&#34;
        logger.error(error_msg)
        if self.strict_mode:
            raise LoaderError(error_msg)
        else:
            logger.warning(f&#34;File missing, returning empty dict: {filepath}&#34;)
            return {}

    try:
        # Read file content
        with open(filepath, encoding=&#34;utf-8&#34;) as f:
            content = f.read()

        # Clean up markdown wrapping (common AI output issue)
        content = self._clean_yaml_content(content)

        # Parse YAML
        data = yaml.safe_load(content)

        if data is None:
            logger.warning(f&#34;Empty YAML file: {filepath}&#34;)
            return {}

        if not isinstance(data, dict):
            error_msg = f&#34;Invalid YAML structure in {filepath}: expected dict, got {type(data)}&#34;
            logger.error(error_msg)
            if self.strict_mode:
                raise YAMLParseError(error_msg)
            return {}

        logger.debug(f&#34;Successfully loaded {filepath}: {len(data)} top-level keys&#34;)
        return data

    except yaml.YAMLError as e:
        error_msg = f&#34;YAML parsing error in {filepath}: {e}&#34;
        logger.error(error_msg)
        if self.strict_mode:
            raise YAMLParseError(error_msg) from e
        else:
            logger.warning(f&#34;YAML error, returning empty dict: {filepath}&#34;)
            return {}
    except Exception as e:
        error_msg = f&#34;Unexpected error loading {filepath}: {e}&#34;
        logger.error(error_msg)
        if self.strict_mode:
            raise LoaderError(error_msg) from e
        else:
            logger.warning(f&#34;Error loading file, returning empty dict: {filepath}&#34;)
            return {}</code></pre>
</details>
<div class="desc"><p>Load and parse a YAML file with error handling.</p>
<p>Handles common issues with AI-generated YAML:
- Markdown code fence wrapping (<code>yaml ...</code>)
- Extra whitespace
- Missing files
- Invalid YAML syntax</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filepath</code></strong></dt>
<dd>Path to the YAML file to load.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Parsed YAML content as a dictionary.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="space_hulk_game.engine.LoaderError" href="#space_hulk_game.engine.LoaderError">LoaderError</a></code></dt>
<dd>If file is missing or cannot be parsed.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; loader = ContentLoader()
&gt;&gt;&gt; data = loader.load_yaml(&quot;game-config/plot_outline.yaml&quot;)
&gt;&gt;&gt; isinstance(data, dict)
True
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.ContentLoader.merge_into_game_data"><code class="name flex">
<span>def <span class="ident">merge_into_game_data</span></span>(<span>self,<br>plot: dict[str, typing.Any],<br>narrative: dict[str, typing.Any],<br>puzzles: dict[str, typing.Any],<br>scenes_text: dict[str, typing.Any],<br>mechanics: dict[str, typing.Any]) ‑> <a title="space_hulk_game.engine.game_data.GameData" href="game_data.html#space_hulk_game.engine.game_data.GameData">GameData</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_into_game_data(
    self,
    plot: dict[str, Any],
    narrative: dict[str, Any],
    puzzles: dict[str, Any],
    scenes_text: dict[str, Any],
    mechanics: dict[str, Any],
) -&gt; GameData:
    &#34;&#34;&#34;
    Merge all loaded YAML data into a GameData object.

    This method implements the core conversion logic, transforming
    the YAML structures into Scene, Item, NPC, and Event objects.

    Args:
        plot: Data from plot_outline.yaml
        narrative: Data from narrative_map.yaml
        puzzles: Data from puzzle_design.yaml
        scenes_text: Data from scene_texts.yaml
        mechanics: Data from prd_document.yaml

    Returns:
        Complete GameData object.

    Raises:
        ValidationError: If required data is missing.
    &#34;&#34;&#34;
    logger.info(&#34;Merging YAML data into GameData&#34;)

    # Extract title and description
    title = self._extract_title(plot, narrative, mechanics)
    description = self._extract_description(plot, mechanics)

    # Build scenes from narrative map
    scenes = self._build_scenes(narrative, scenes_text, puzzles)

    # Find starting scene
    starting_scene = self._find_starting_scene(narrative, scenes)

    # Extract global items and NPCs
    global_items = self._extract_global_items(puzzles)
    global_npcs = self._extract_global_npcs(puzzles)

    # Extract additional data
    themes = self._extract_themes(plot)
    plot_points = self._extract_plot_points(plot)
    endings = self._extract_endings(plot)
    game_rules = self._extract_game_rules(mechanics)

    # Build GameData
    game_data = GameData(
        title=title,
        description=description,
        scenes=scenes,
        starting_scene=starting_scene,
        global_items=global_items,
        global_npcs=global_npcs,
        themes=themes,
        plot_points=plot_points,
        endings=endings,
        game_rules=game_rules,
        metadata={
            &#34;loaded_from_ai&#34;: True,
            &#34;source_files&#34;: [
                &#34;plot_outline&#34;,
                &#34;narrative_map&#34;,
                &#34;puzzle_design&#34;,
                &#34;scene_texts&#34;,
                &#34;prd_document&#34;,
            ],
        },
    )

    logger.info(&#34;GameData merge complete&#34;)
    return game_data</code></pre>
</details>
<div class="desc"><p>Merge all loaded YAML data into a GameData object.</p>
<p>This method implements the core conversion logic, transforming
the YAML structures into Scene, Item, NPC, and Event objects.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>plot</code></strong></dt>
<dd>Data from plot_outline.yaml</dd>
<dt><strong><code>narrative</code></strong></dt>
<dd>Data from narrative_map.yaml</dd>
<dt><strong><code>puzzles</code></strong></dt>
<dd>Data from puzzle_design.yaml</dd>
<dt><strong><code>scenes_text</code></strong></dt>
<dd>Data from scene_texts.yaml</dd>
<dt><strong><code>mechanics</code></strong></dt>
<dd>Data from prd_document.yaml</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Complete GameData object.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="space_hulk_game.engine.ValidationError" href="#space_hulk_game.engine.ValidationError">ValidationError</a></code></dt>
<dd>If required data is missing.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.engine.DropAction"><code class="flex name class">
<span>class <span class="ident">DropAction</span></span>
<span>(</span><span>raw_command: str = '', item_id: str = '')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class DropAction(Action):
    &#34;&#34;&#34;
    Represents dropping an item from inventory.

    Attributes:
        item_id: The ID or name of the item to drop.
        raw_command: The original text command from the player.

    Examples:
        &gt;&gt;&gt; action = DropAction(item_id=&#34;sword&#34;, raw_command=&#34;drop sword&#34;)
        &gt;&gt;&gt; action.item_id
        &#39;sword&#39;
    &#34;&#34;&#34;

    item_id: str = &#34;&#34;

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Return a string representation of the action.&#34;&#34;&#34;
        return f&#34;DropAction(item_id=&#39;{self.item_id}&#39;)&#34;</code></pre>
</details>
<div class="desc"><p>Represents dropping an item from inventory.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>item_id</code></strong></dt>
<dd>The ID or name of the item to drop.</dd>
<dt><strong><code>raw_command</code></strong></dt>
<dd>The original text command from the player.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; action = DropAction(item_id=&quot;sword&quot;, raw_command=&quot;drop sword&quot;)
&gt;&gt;&gt; action.item_id
'sword'
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="space_hulk_game.engine.actions.Action" href="actions.html#space_hulk_game.engine.actions.Action">Action</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="space_hulk_game.engine.DropAction.item_id"><code class="name">var <span class="ident">item_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.engine.Event"><code class="flex name class">
<span>class <span class="ident">Event</span></span>
<span>(</span><span>id: str,<br>description: str,<br>trigger_on_entry: bool = False,<br>required_flag: str | None = None,<br>one_time: bool = True,<br>effects: dict[str, typing.Any] = &lt;factory&gt;,<br>triggered: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Event:
    &#34;&#34;&#34;
    Represents a triggerable event in a scene.

    Events are scripted occurrences that can happen when the player enters
    a scene, performs an action, or meets certain conditions. They can
    modify game state, trigger dialogue, or cause other effects.

    Attributes:
        id: Unique identifier for the event.
        description: Text description of what happens.
        trigger_on_entry: Whether the event triggers when entering the scene.
        required_flag: Optional game flag required to trigger this event.
        one_time: Whether the event can only trigger once.
        effects: Dictionary of effects applied when event triggers.

    Examples:
        Create an entry event:
        &gt;&gt;&gt; ambush = Event(
        ...     id=&#34;genestealer_ambush&#34;,
        ...     description=&#34;A genestealer drops from the ceiling!&#34;,
        ...     trigger_on_entry=True,
        ...     effects={&#39;spawn_enemy&#39;: &#39;genestealer&#39;, &#39;damage&#39;: 20}
        ... )

        Create a conditional event:
        &gt;&gt;&gt; discovery = Event(
        ...     id=&#34;find_clue&#34;,
        ...     description=&#34;You notice strange markings on the wall.&#34;,
        ...     required_flag=&#34;has_enhanced_vision&#34;,
        ...     one_time=True,
        ...     effects={&#39;set_flag&#39;: &#39;clue_found&#39;}
        ... )

        Create a narrative event:
        &gt;&gt;&gt; flashback = Event(
        ...     id=&#34;vision&#34;,
        ...     description=&#34;A psychic vision overwhelms you...&#34;,
        ...     trigger_on_entry=True,
        ...     one_time=True,
        ...     effects={&#39;set_flag&#39;: &#39;vision_seen&#39;, &#39;damage&#39;: 5}
        ... )
    &#34;&#34;&#34;

    id: str
    description: str
    trigger_on_entry: bool = False
    required_flag: Optional[str] = None
    one_time: bool = True
    effects: dict[str, Any] = field(default_factory=dict)
    triggered: bool = False

    def __post_init__(self):
        &#34;&#34;&#34;Validate the event after initialization.&#34;&#34;&#34;
        if not self.id:
            raise ValueError(&#34;Event id cannot be empty&#34;)
        if not self.description:
            raise ValueError(&#34;Event description cannot be empty&#34;)

    def can_trigger(self, game_flags: dict[str, bool]) -&gt; bool:
        &#34;&#34;&#34;
        Check if the event can trigger given current game flags.

        Args:
            game_flags: Dictionary of current game flags.

        Returns:
            True if the event can trigger, False otherwise.

        Examples:
            &gt;&gt;&gt; event = Event(id=&#34;test&#34;, description=&#34;Test event&#34;,
            ...               required_flag=&#34;key_found&#34;, one_time=True)
            &gt;&gt;&gt; event.can_trigger({})
            False
            &gt;&gt;&gt; event.can_trigger({&#34;key_found&#34;: True})
            True
            &gt;&gt;&gt; event.triggered = True
            &gt;&gt;&gt; event.can_trigger({&#34;key_found&#34;: True})
            False
        &#34;&#34;&#34;
        if self.one_time and self.triggered:
            return False
        if self.required_flag:
            return game_flags.get(self.required_flag, False)
        return True

    def trigger(self) -&gt; None:
        &#34;&#34;&#34;
        Mark the event as triggered.

        Examples:
            &gt;&gt;&gt; event = Event(id=&#34;test&#34;, description=&#34;Test&#34;, one_time=True)
            &gt;&gt;&gt; event.triggered
            False
            &gt;&gt;&gt; event.trigger()
            &gt;&gt;&gt; event.triggered
            True
        &#34;&#34;&#34;
        self.triggered = True

    def reset(self) -&gt; None:
        &#34;&#34;&#34;
        Reset the event so it can trigger again.

        Examples:
            &gt;&gt;&gt; event = Event(id=&#34;test&#34;, description=&#34;Test&#34;)
            &gt;&gt;&gt; event.trigger()
            &gt;&gt;&gt; event.triggered
            True
            &gt;&gt;&gt; event.reset()
            &gt;&gt;&gt; event.triggered
            False
        &#34;&#34;&#34;
        self.triggered = False

    def to_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        Convert the event to a dictionary for serialization.

        Returns:
            Dictionary representation of the event.
        &#34;&#34;&#34;
        return {
            &#34;id&#34;: self.id,
            &#34;description&#34;: self.description,
            &#34;trigger_on_entry&#34;: self.trigger_on_entry,
            &#34;required_flag&#34;: self.required_flag,
            &#34;one_time&#34;: self.one_time,
            &#34;effects&#34;: self.effects,
            &#34;triggered&#34;: self.triggered,
        }

    @classmethod
    def from_dict(cls, data: dict) -&gt; &#34;Event&#34;:
        &#34;&#34;&#34;
        Create an Event from a dictionary.

        Args:
            data: Dictionary containing event data.

        Returns:
            A new Event instance.
        &#34;&#34;&#34;
        event = cls(
            id=data[&#34;id&#34;],
            description=data[&#34;description&#34;],
            trigger_on_entry=data.get(&#34;trigger_on_entry&#34;, False),
            required_flag=data.get(&#34;required_flag&#34;),
            one_time=data.get(&#34;one_time&#34;, True),
            effects=data.get(&#34;effects&#34;, {}),
        )
        event.triggered = data.get(&#34;triggered&#34;, False)
        return event</code></pre>
</details>
<div class="desc"><p>Represents a triggerable event in a scene.</p>
<p>Events are scripted occurrences that can happen when the player enters
a scene, performs an action, or meets certain conditions. They can
modify game state, trigger dialogue, or cause other effects.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>Unique identifier for the event.</dd>
<dt><strong><code>description</code></strong></dt>
<dd>Text description of what happens.</dd>
<dt><strong><code>trigger_on_entry</code></strong></dt>
<dd>Whether the event triggers when entering the scene.</dd>
<dt><strong><code>required_flag</code></strong></dt>
<dd>Optional game flag required to trigger this event.</dd>
<dt><strong><code>one_time</code></strong></dt>
<dd>Whether the event can only trigger once.</dd>
<dt><strong><code>effects</code></strong></dt>
<dd>Dictionary of effects applied when event triggers.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Create an entry event:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ambush = Event(
...     id=&quot;genestealer_ambush&quot;,
...     description=&quot;A genestealer drops from the ceiling!&quot;,
...     trigger_on_entry=True,
...     effects={'spawn_enemy': 'genestealer', 'damage': 20}
... )
</code></pre>
<p>Create a conditional event:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; discovery = Event(
...     id=&quot;find_clue&quot;,
...     description=&quot;You notice strange markings on the wall.&quot;,
...     required_flag=&quot;has_enhanced_vision&quot;,
...     one_time=True,
...     effects={'set_flag': 'clue_found'}
... )
</code></pre>
<p>Create a narrative event:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flashback = Event(
...     id=&quot;vision&quot;,
...     description=&quot;A psychic vision overwhelms you...&quot;,
...     trigger_on_entry=True,
...     one_time=True,
...     effects={'set_flag': 'vision_seen', 'damage': 5}
... )
</code></pre></div>
<h3>Static methods</h3>
<dl>
<dt id="space_hulk_game.engine.Event.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict) ‑> <a title="space_hulk_game.engine.entities.Event" href="entities.html#space_hulk_game.engine.entities.Event">Event</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create an Event from a dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing event data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new Event instance.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="space_hulk_game.engine.Event.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Event.effects"><code class="name">var <span class="ident">effects</span> : dict[str, typing.Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Event.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Event.one_time"><code class="name">var <span class="ident">one_time</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Event.required_flag"><code class="name">var <span class="ident">required_flag</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Event.trigger_on_entry"><code class="name">var <span class="ident">trigger_on_entry</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Event.triggered"><code class="name">var <span class="ident">triggered</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="space_hulk_game.engine.Event.can_trigger"><code class="name flex">
<span>def <span class="ident">can_trigger</span></span>(<span>self, game_flags: dict[str, bool]) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def can_trigger(self, game_flags: dict[str, bool]) -&gt; bool:
    &#34;&#34;&#34;
    Check if the event can trigger given current game flags.

    Args:
        game_flags: Dictionary of current game flags.

    Returns:
        True if the event can trigger, False otherwise.

    Examples:
        &gt;&gt;&gt; event = Event(id=&#34;test&#34;, description=&#34;Test event&#34;,
        ...               required_flag=&#34;key_found&#34;, one_time=True)
        &gt;&gt;&gt; event.can_trigger({})
        False
        &gt;&gt;&gt; event.can_trigger({&#34;key_found&#34;: True})
        True
        &gt;&gt;&gt; event.triggered = True
        &gt;&gt;&gt; event.can_trigger({&#34;key_found&#34;: True})
        False
    &#34;&#34;&#34;
    if self.one_time and self.triggered:
        return False
    if self.required_flag:
        return game_flags.get(self.required_flag, False)
    return True</code></pre>
</details>
<div class="desc"><p>Check if the event can trigger given current game flags.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>game_flags</code></strong></dt>
<dd>Dictionary of current game flags.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the event can trigger, False otherwise.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; event = Event(id=&quot;test&quot;, description=&quot;Test event&quot;,
...               required_flag=&quot;key_found&quot;, one_time=True)
&gt;&gt;&gt; event.can_trigger({})
False
&gt;&gt;&gt; event.can_trigger({&quot;key_found&quot;: True})
True
&gt;&gt;&gt; event.triggered = True
&gt;&gt;&gt; event.can_trigger({&quot;key_found&quot;: True})
False
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.Event.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self) -&gt; None:
    &#34;&#34;&#34;
    Reset the event so it can trigger again.

    Examples:
        &gt;&gt;&gt; event = Event(id=&#34;test&#34;, description=&#34;Test&#34;)
        &gt;&gt;&gt; event.trigger()
        &gt;&gt;&gt; event.triggered
        True
        &gt;&gt;&gt; event.reset()
        &gt;&gt;&gt; event.triggered
        False
    &#34;&#34;&#34;
    self.triggered = False</code></pre>
</details>
<div class="desc"><p>Reset the event so it can trigger again.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; event = Event(id=&quot;test&quot;, description=&quot;Test&quot;)
&gt;&gt;&gt; event.trigger()
&gt;&gt;&gt; event.triggered
True
&gt;&gt;&gt; event.reset()
&gt;&gt;&gt; event.triggered
False
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.Event.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict:
    &#34;&#34;&#34;
    Convert the event to a dictionary for serialization.

    Returns:
        Dictionary representation of the event.
    &#34;&#34;&#34;
    return {
        &#34;id&#34;: self.id,
        &#34;description&#34;: self.description,
        &#34;trigger_on_entry&#34;: self.trigger_on_entry,
        &#34;required_flag&#34;: self.required_flag,
        &#34;one_time&#34;: self.one_time,
        &#34;effects&#34;: self.effects,
        &#34;triggered&#34;: self.triggered,
    }</code></pre>
</details>
<div class="desc"><p>Convert the event to a dictionary for serialization.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary representation of the event.</p></div>
</dd>
<dt id="space_hulk_game.engine.Event.trigger"><code class="name flex">
<span>def <span class="ident">trigger</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trigger(self) -&gt; None:
    &#34;&#34;&#34;
    Mark the event as triggered.

    Examples:
        &gt;&gt;&gt; event = Event(id=&#34;test&#34;, description=&#34;Test&#34;, one_time=True)
        &gt;&gt;&gt; event.triggered
        False
        &gt;&gt;&gt; event.trigger()
        &gt;&gt;&gt; event.triggered
        True
    &#34;&#34;&#34;
    self.triggered = True</code></pre>
</details>
<div class="desc"><p>Mark the event as triggered.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; event = Event(id=&quot;test&quot;, description=&quot;Test&quot;, one_time=True)
&gt;&gt;&gt; event.triggered
False
&gt;&gt;&gt; event.trigger()
&gt;&gt;&gt; event.triggered
True
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.engine.GameData"><code class="flex name class">
<span>class <span class="ident">GameData</span></span>
<span>(</span><span>title: str,<br>description: str,<br>scenes: dict[str, <a title="space_hulk_game.engine.scene.Scene" href="scene.html#space_hulk_game.engine.scene.Scene">Scene</a>],<br>starting_scene: str,<br>global_items: dict[str, <a title="space_hulk_game.engine.entities.Item" href="entities.html#space_hulk_game.engine.entities.Item">Item</a>] = &lt;factory&gt;,<br>global_npcs: dict[str, <a title="space_hulk_game.engine.entities.NPC" href="entities.html#space_hulk_game.engine.entities.NPC">NPC</a>] = &lt;factory&gt;,<br>endings: list[dict[str, typing.Any]] = &lt;factory&gt;,<br>game_rules: dict[str, typing.Any] = &lt;factory&gt;,<br>themes: list[str] = &lt;factory&gt;,<br>plot_points: list[dict[str, typing.Any]] = &lt;factory&gt;,<br>metadata: dict[str, typing.Any] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class GameData:
    &#34;&#34;&#34;
    Holds all game content loaded from generated YAML files.

    This is the complete game definition, including all scenes, items, NPCs,
    game mechanics, and narrative structure. The TextAdventureEngine uses
    GameData to run the game.

    Attributes:
        title: The title of the game.
        description: Brief description of the game&#39;s premise.
        scenes: Dictionary mapping scene IDs to Scene objects.
        starting_scene: ID of the scene where the game begins.
        global_items: Dictionary of item definitions (not placed in any scene yet).
        global_npcs: Dictionary of NPC definitions (not placed in any scene yet).
        endings: List of possible game endings with their conditions.
        game_rules: Dictionary of game-specific mechanics and rules.
        themes: List of narrative themes.
        plot_points: List of major plot points.
        metadata: Additional metadata from the YAML files.

    Examples:
        Create minimal game data:
        &gt;&gt;&gt; from space_hulk_game.engine import Scene
        &gt;&gt;&gt; start_scene = Scene(
        ...     id=&#34;entrance&#34;,
        ...     name=&#34;Entrance Hall&#34;,
        ...     description=&#34;You are in the entrance.&#34;
        ... )
        &gt;&gt;&gt; data = GameData(
        ...     title=&#34;Test Adventure&#34;,
        ...     description=&#34;A test game&#34;,
        ...     scenes={&#34;entrance&#34;: start_scene},
        ...     starting_scene=&#34;entrance&#34;
        ... )

        Access scenes:
        &gt;&gt;&gt; scene = data.get_scene(&#34;entrance&#34;)
        &gt;&gt;&gt; scene.name
        &#39;Entrance Hall&#39;

        Check for scenes:
        &gt;&gt;&gt; data.has_scene(&#34;entrance&#34;)
        True
        &gt;&gt;&gt; data.has_scene(&#34;unknown&#34;)
        False
    &#34;&#34;&#34;

    title: str
    description: str
    scenes: dict[str, Scene]
    starting_scene: str
    global_items: dict[str, Item] = field(default_factory=dict)
    global_npcs: dict[str, NPC] = field(default_factory=dict)
    endings: list[dict[str, Any]] = field(default_factory=list)
    game_rules: dict[str, Any] = field(default_factory=dict)
    themes: list[str] = field(default_factory=list)
    plot_points: list[dict[str, Any]] = field(default_factory=list)
    metadata: dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        &#34;&#34;&#34;Validate the game data after initialization.&#34;&#34;&#34;
        if not self.title:
            raise ValueError(&#34;Game title cannot be empty&#34;)
        if not self.description:
            raise ValueError(&#34;Game description cannot be empty&#34;)
        if not self.scenes:
            raise ValueError(&#34;Game must have at least one scene&#34;)
        if not self.starting_scene:
            raise ValueError(&#34;Starting scene must be specified&#34;)
        if self.starting_scene not in self.scenes:
            raise ValueError(f&#34;Starting scene &#39;{self.starting_scene}&#39; not found in scenes&#34;)

    def get_scene(self, scene_id: str) -&gt; Optional[Scene]:
        &#34;&#34;&#34;
        Get a scene by its ID.

        Args:
            scene_id: The ID of the scene to retrieve.

        Returns:
            The Scene object if found, None otherwise.

        Examples:
            &gt;&gt;&gt; from space_hulk_game.engine import Scene
            &gt;&gt;&gt; scene = Scene(id=&#34;test&#34;, name=&#34;Test&#34;, description=&#34;Test scene&#34;)
            &gt;&gt;&gt; data = GameData(
            ...     title=&#34;Test&#34;,
            ...     description=&#34;Test&#34;,
            ...     scenes={&#34;test&#34;: scene},
            ...     starting_scene=&#34;test&#34;
            ... )
            &gt;&gt;&gt; found = data.get_scene(&#34;test&#34;)
            &gt;&gt;&gt; found.name
            &#39;Test&#39;
            &gt;&gt;&gt; data.get_scene(&#34;missing&#34;)
        &#34;&#34;&#34;
        return self.scenes.get(scene_id)

    def has_scene(self, scene_id: str) -&gt; bool:
        &#34;&#34;&#34;
        Check if a scene exists.

        Args:
            scene_id: The ID of the scene to check.

        Returns:
            True if the scene exists, False otherwise.

        Examples:
            &gt;&gt;&gt; from space_hulk_game.engine import Scene
            &gt;&gt;&gt; scene = Scene(id=&#34;test&#34;, name=&#34;Test&#34;, description=&#34;Test&#34;)
            &gt;&gt;&gt; data = GameData(
            ...     title=&#34;Test&#34;,
            ...     description=&#34;Test&#34;,
            ...     scenes={&#34;test&#34;: scene},
            ...     starting_scene=&#34;test&#34;
            ... )
            &gt;&gt;&gt; data.has_scene(&#34;test&#34;)
            True
            &gt;&gt;&gt; data.has_scene(&#34;unknown&#34;)
            False
        &#34;&#34;&#34;
        return scene_id in self.scenes

    def get_item_definition(self, item_id: str) -&gt; Optional[Item]:
        &#34;&#34;&#34;
        Get a global item definition by ID.

        Args:
            item_id: The ID of the item to retrieve.

        Returns:
            The Item object if found, None otherwise.

        Examples:
            &gt;&gt;&gt; from space_hulk_game.engine import Item, Scene
            &gt;&gt;&gt; item = Item(id=&#34;key&#34;, name=&#34;Key&#34;, description=&#34;A key&#34;)
            &gt;&gt;&gt; scene = Scene(id=&#34;start&#34;, name=&#34;Start&#34;, description=&#34;Start scene&#34;)
            &gt;&gt;&gt; data = GameData(
            ...     title=&#34;Test&#34;,
            ...     description=&#34;Test&#34;,
            ...     scenes={&#34;start&#34;: scene},
            ...     starting_scene=&#34;start&#34;,
            ...     global_items={&#34;key&#34;: item}
            ... )
            &gt;&gt;&gt; found = data.get_item_definition(&#34;key&#34;)
            &gt;&gt;&gt; found.name
            &#39;Key&#39;
        &#34;&#34;&#34;
        return self.global_items.get(item_id)

    def get_npc_definition(self, npc_id: str) -&gt; Optional[NPC]:
        &#34;&#34;&#34;
        Get a global NPC definition by ID.

        Args:
            npc_id: The ID of the NPC to retrieve.

        Returns:
            The NPC object if found, None otherwise.

        Examples:
            &gt;&gt;&gt; from space_hulk_game.engine import NPC, Scene
            &gt;&gt;&gt; npc = NPC(id=&#34;guard&#34;, name=&#34;Guard&#34;, description=&#34;A guard&#34;)
            &gt;&gt;&gt; scene = Scene(id=&#34;start&#34;, name=&#34;Start&#34;, description=&#34;Start scene&#34;)
            &gt;&gt;&gt; data = GameData(
            ...     title=&#34;Test&#34;,
            ...     description=&#34;Test&#34;,
            ...     scenes={&#34;start&#34;: scene},
            ...     starting_scene=&#34;start&#34;,
            ...     global_npcs={&#34;guard&#34;: npc}
            ... )
            &gt;&gt;&gt; found = data.get_npc_definition(&#34;guard&#34;)
            &gt;&gt;&gt; found.name
            &#39;Guard&#39;
        &#34;&#34;&#34;
        return self.global_npcs.get(npc_id)

    def to_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        Convert the game data to a dictionary for serialization.

        Returns:
            Dictionary representation of the game data.
        &#34;&#34;&#34;
        return {
            &#34;title&#34;: self.title,
            &#34;description&#34;: self.description,
            &#34;scenes&#34;: {sid: scene.to_dict() for sid, scene in self.scenes.items()},
            &#34;starting_scene&#34;: self.starting_scene,
            &#34;global_items&#34;: {iid: item.to_dict() for iid, item in self.global_items.items()},
            &#34;global_npcs&#34;: {nid: npc.to_dict() for nid, npc in self.global_npcs.items()},
            &#34;endings&#34;: self.endings,
            &#34;game_rules&#34;: self.game_rules,
            &#34;themes&#34;: self.themes,
            &#34;plot_points&#34;: self.plot_points,
            &#34;metadata&#34;: self.metadata,
        }

    @classmethod
    def from_dict(cls, data: dict) -&gt; &#34;GameData&#34;:
        &#34;&#34;&#34;
        Create GameData from a dictionary.

        Args:
            data: Dictionary containing game data.

        Returns:
            A new GameData instance.
        &#34;&#34;&#34;
        return cls(
            title=data[&#34;title&#34;],
            description=data[&#34;description&#34;],
            scenes={
                sid: Scene.from_dict(scene_data)
                for sid, scene_data in data.get(&#34;scenes&#34;, {}).items()
            },
            starting_scene=data[&#34;starting_scene&#34;],
            global_items={
                iid: Item.from_dict(item_data)
                for iid, item_data in data.get(&#34;global_items&#34;, {}).items()
            },
            global_npcs={
                nid: NPC.from_dict(npc_data)
                for nid, npc_data in data.get(&#34;global_npcs&#34;, {}).items()
            },
            endings=data.get(&#34;endings&#34;, []),
            game_rules=data.get(&#34;game_rules&#34;, {}),
            themes=data.get(&#34;themes&#34;, []),
            plot_points=data.get(&#34;plot_points&#34;, []),
            metadata=data.get(&#34;metadata&#34;, {}),
        )</code></pre>
</details>
<div class="desc"><p>Holds all game content loaded from generated YAML files.</p>
<p>This is the complete game definition, including all scenes, items, NPCs,
game mechanics, and narrative structure. The TextAdventureEngine uses
GameData to run the game.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>title</code></strong></dt>
<dd>The title of the game.</dd>
<dt><strong><code>description</code></strong></dt>
<dd>Brief description of the game's premise.</dd>
<dt><strong><code>scenes</code></strong></dt>
<dd>Dictionary mapping scene IDs to Scene objects.</dd>
<dt><strong><code>starting_scene</code></strong></dt>
<dd>ID of the scene where the game begins.</dd>
<dt><strong><code>global_items</code></strong></dt>
<dd>Dictionary of item definitions (not placed in any scene yet).</dd>
<dt><strong><code>global_npcs</code></strong></dt>
<dd>Dictionary of NPC definitions (not placed in any scene yet).</dd>
<dt><strong><code>endings</code></strong></dt>
<dd>List of possible game endings with their conditions.</dd>
<dt><strong><code>game_rules</code></strong></dt>
<dd>Dictionary of game-specific mechanics and rules.</dd>
<dt><strong><code>themes</code></strong></dt>
<dd>List of narrative themes.</dd>
<dt><strong><code>plot_points</code></strong></dt>
<dd>List of major plot points.</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Additional metadata from the YAML files.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Create minimal game data:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from space_hulk_game.engine import Scene
&gt;&gt;&gt; start_scene = Scene(
...     id=&quot;entrance&quot;,
...     name=&quot;Entrance Hall&quot;,
...     description=&quot;You are in the entrance.&quot;
... )
&gt;&gt;&gt; data = GameData(
...     title=&quot;Test Adventure&quot;,
...     description=&quot;A test game&quot;,
...     scenes={&quot;entrance&quot;: start_scene},
...     starting_scene=&quot;entrance&quot;
... )
</code></pre>
<p>Access scenes:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; scene = data.get_scene(&quot;entrance&quot;)
&gt;&gt;&gt; scene.name
'Entrance Hall'
</code></pre>
<p>Check for scenes:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; data.has_scene(&quot;entrance&quot;)
True
&gt;&gt;&gt; data.has_scene(&quot;unknown&quot;)
False
</code></pre></div>
<h3>Static methods</h3>
<dl>
<dt id="space_hulk_game.engine.GameData.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict) ‑> <a title="space_hulk_game.engine.game_data.GameData" href="game_data.html#space_hulk_game.engine.game_data.GameData">GameData</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create GameData from a dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing game data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new GameData instance.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="space_hulk_game.engine.GameData.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.GameData.endings"><code class="name">var <span class="ident">endings</span> : list[dict[str, typing.Any]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.GameData.game_rules"><code class="name">var <span class="ident">game_rules</span> : dict[str, typing.Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.GameData.global_items"><code class="name">var <span class="ident">global_items</span> : dict[str, <a title="space_hulk_game.engine.entities.Item" href="entities.html#space_hulk_game.engine.entities.Item">Item</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.GameData.global_npcs"><code class="name">var <span class="ident">global_npcs</span> : dict[str, <a title="space_hulk_game.engine.entities.NPC" href="entities.html#space_hulk_game.engine.entities.NPC">NPC</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.GameData.metadata"><code class="name">var <span class="ident">metadata</span> : dict[str, typing.Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.GameData.plot_points"><code class="name">var <span class="ident">plot_points</span> : list[dict[str, typing.Any]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.GameData.scenes"><code class="name">var <span class="ident">scenes</span> : dict[str, <a title="space_hulk_game.engine.scene.Scene" href="scene.html#space_hulk_game.engine.scene.Scene">Scene</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.GameData.starting_scene"><code class="name">var <span class="ident">starting_scene</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.GameData.themes"><code class="name">var <span class="ident">themes</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.GameData.title"><code class="name">var <span class="ident">title</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="space_hulk_game.engine.GameData.get_item_definition"><code class="name flex">
<span>def <span class="ident">get_item_definition</span></span>(<span>self, item_id: str) ‑> <a title="space_hulk_game.engine.entities.Item" href="entities.html#space_hulk_game.engine.entities.Item">Item</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_item_definition(self, item_id: str) -&gt; Optional[Item]:
    &#34;&#34;&#34;
    Get a global item definition by ID.

    Args:
        item_id: The ID of the item to retrieve.

    Returns:
        The Item object if found, None otherwise.

    Examples:
        &gt;&gt;&gt; from space_hulk_game.engine import Item, Scene
        &gt;&gt;&gt; item = Item(id=&#34;key&#34;, name=&#34;Key&#34;, description=&#34;A key&#34;)
        &gt;&gt;&gt; scene = Scene(id=&#34;start&#34;, name=&#34;Start&#34;, description=&#34;Start scene&#34;)
        &gt;&gt;&gt; data = GameData(
        ...     title=&#34;Test&#34;,
        ...     description=&#34;Test&#34;,
        ...     scenes={&#34;start&#34;: scene},
        ...     starting_scene=&#34;start&#34;,
        ...     global_items={&#34;key&#34;: item}
        ... )
        &gt;&gt;&gt; found = data.get_item_definition(&#34;key&#34;)
        &gt;&gt;&gt; found.name
        &#39;Key&#39;
    &#34;&#34;&#34;
    return self.global_items.get(item_id)</code></pre>
</details>
<div class="desc"><p>Get a global item definition by ID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item_id</code></strong></dt>
<dd>The ID of the item to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The Item object if found, None otherwise.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from space_hulk_game.engine import Item, Scene
&gt;&gt;&gt; item = Item(id=&quot;key&quot;, name=&quot;Key&quot;, description=&quot;A key&quot;)
&gt;&gt;&gt; scene = Scene(id=&quot;start&quot;, name=&quot;Start&quot;, description=&quot;Start scene&quot;)
&gt;&gt;&gt; data = GameData(
...     title=&quot;Test&quot;,
...     description=&quot;Test&quot;,
...     scenes={&quot;start&quot;: scene},
...     starting_scene=&quot;start&quot;,
...     global_items={&quot;key&quot;: item}
... )
&gt;&gt;&gt; found = data.get_item_definition(&quot;key&quot;)
&gt;&gt;&gt; found.name
'Key'
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.GameData.get_npc_definition"><code class="name flex">
<span>def <span class="ident">get_npc_definition</span></span>(<span>self, npc_id: str) ‑> <a title="space_hulk_game.engine.entities.NPC" href="entities.html#space_hulk_game.engine.entities.NPC">NPC</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_npc_definition(self, npc_id: str) -&gt; Optional[NPC]:
    &#34;&#34;&#34;
    Get a global NPC definition by ID.

    Args:
        npc_id: The ID of the NPC to retrieve.

    Returns:
        The NPC object if found, None otherwise.

    Examples:
        &gt;&gt;&gt; from space_hulk_game.engine import NPC, Scene
        &gt;&gt;&gt; npc = NPC(id=&#34;guard&#34;, name=&#34;Guard&#34;, description=&#34;A guard&#34;)
        &gt;&gt;&gt; scene = Scene(id=&#34;start&#34;, name=&#34;Start&#34;, description=&#34;Start scene&#34;)
        &gt;&gt;&gt; data = GameData(
        ...     title=&#34;Test&#34;,
        ...     description=&#34;Test&#34;,
        ...     scenes={&#34;start&#34;: scene},
        ...     starting_scene=&#34;start&#34;,
        ...     global_npcs={&#34;guard&#34;: npc}
        ... )
        &gt;&gt;&gt; found = data.get_npc_definition(&#34;guard&#34;)
        &gt;&gt;&gt; found.name
        &#39;Guard&#39;
    &#34;&#34;&#34;
    return self.global_npcs.get(npc_id)</code></pre>
</details>
<div class="desc"><p>Get a global NPC definition by ID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>npc_id</code></strong></dt>
<dd>The ID of the NPC to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The NPC object if found, None otherwise.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from space_hulk_game.engine import NPC, Scene
&gt;&gt;&gt; npc = NPC(id=&quot;guard&quot;, name=&quot;Guard&quot;, description=&quot;A guard&quot;)
&gt;&gt;&gt; scene = Scene(id=&quot;start&quot;, name=&quot;Start&quot;, description=&quot;Start scene&quot;)
&gt;&gt;&gt; data = GameData(
...     title=&quot;Test&quot;,
...     description=&quot;Test&quot;,
...     scenes={&quot;start&quot;: scene},
...     starting_scene=&quot;start&quot;,
...     global_npcs={&quot;guard&quot;: npc}
... )
&gt;&gt;&gt; found = data.get_npc_definition(&quot;guard&quot;)
&gt;&gt;&gt; found.name
'Guard'
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.GameData.get_scene"><code class="name flex">
<span>def <span class="ident">get_scene</span></span>(<span>self, scene_id: str) ‑> <a title="space_hulk_game.engine.scene.Scene" href="scene.html#space_hulk_game.engine.scene.Scene">Scene</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_scene(self, scene_id: str) -&gt; Optional[Scene]:
    &#34;&#34;&#34;
    Get a scene by its ID.

    Args:
        scene_id: The ID of the scene to retrieve.

    Returns:
        The Scene object if found, None otherwise.

    Examples:
        &gt;&gt;&gt; from space_hulk_game.engine import Scene
        &gt;&gt;&gt; scene = Scene(id=&#34;test&#34;, name=&#34;Test&#34;, description=&#34;Test scene&#34;)
        &gt;&gt;&gt; data = GameData(
        ...     title=&#34;Test&#34;,
        ...     description=&#34;Test&#34;,
        ...     scenes={&#34;test&#34;: scene},
        ...     starting_scene=&#34;test&#34;
        ... )
        &gt;&gt;&gt; found = data.get_scene(&#34;test&#34;)
        &gt;&gt;&gt; found.name
        &#39;Test&#39;
        &gt;&gt;&gt; data.get_scene(&#34;missing&#34;)
    &#34;&#34;&#34;
    return self.scenes.get(scene_id)</code></pre>
</details>
<div class="desc"><p>Get a scene by its ID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scene_id</code></strong></dt>
<dd>The ID of the scene to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The Scene object if found, None otherwise.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from space_hulk_game.engine import Scene
&gt;&gt;&gt; scene = Scene(id=&quot;test&quot;, name=&quot;Test&quot;, description=&quot;Test scene&quot;)
&gt;&gt;&gt; data = GameData(
...     title=&quot;Test&quot;,
...     description=&quot;Test&quot;,
...     scenes={&quot;test&quot;: scene},
...     starting_scene=&quot;test&quot;
... )
&gt;&gt;&gt; found = data.get_scene(&quot;test&quot;)
&gt;&gt;&gt; found.name
'Test'
&gt;&gt;&gt; data.get_scene(&quot;missing&quot;)
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.GameData.has_scene"><code class="name flex">
<span>def <span class="ident">has_scene</span></span>(<span>self, scene_id: str) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_scene(self, scene_id: str) -&gt; bool:
    &#34;&#34;&#34;
    Check if a scene exists.

    Args:
        scene_id: The ID of the scene to check.

    Returns:
        True if the scene exists, False otherwise.

    Examples:
        &gt;&gt;&gt; from space_hulk_game.engine import Scene
        &gt;&gt;&gt; scene = Scene(id=&#34;test&#34;, name=&#34;Test&#34;, description=&#34;Test&#34;)
        &gt;&gt;&gt; data = GameData(
        ...     title=&#34;Test&#34;,
        ...     description=&#34;Test&#34;,
        ...     scenes={&#34;test&#34;: scene},
        ...     starting_scene=&#34;test&#34;
        ... )
        &gt;&gt;&gt; data.has_scene(&#34;test&#34;)
        True
        &gt;&gt;&gt; data.has_scene(&#34;unknown&#34;)
        False
    &#34;&#34;&#34;
    return scene_id in self.scenes</code></pre>
</details>
<div class="desc"><p>Check if a scene exists.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scene_id</code></strong></dt>
<dd>The ID of the scene to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the scene exists, False otherwise.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from space_hulk_game.engine import Scene
&gt;&gt;&gt; scene = Scene(id=&quot;test&quot;, name=&quot;Test&quot;, description=&quot;Test&quot;)
&gt;&gt;&gt; data = GameData(
...     title=&quot;Test&quot;,
...     description=&quot;Test&quot;,
...     scenes={&quot;test&quot;: scene},
...     starting_scene=&quot;test&quot;
... )
&gt;&gt;&gt; data.has_scene(&quot;test&quot;)
True
&gt;&gt;&gt; data.has_scene(&quot;unknown&quot;)
False
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.GameData.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict:
    &#34;&#34;&#34;
    Convert the game data to a dictionary for serialization.

    Returns:
        Dictionary representation of the game data.
    &#34;&#34;&#34;
    return {
        &#34;title&#34;: self.title,
        &#34;description&#34;: self.description,
        &#34;scenes&#34;: {sid: scene.to_dict() for sid, scene in self.scenes.items()},
        &#34;starting_scene&#34;: self.starting_scene,
        &#34;global_items&#34;: {iid: item.to_dict() for iid, item in self.global_items.items()},
        &#34;global_npcs&#34;: {nid: npc.to_dict() for nid, npc in self.global_npcs.items()},
        &#34;endings&#34;: self.endings,
        &#34;game_rules&#34;: self.game_rules,
        &#34;themes&#34;: self.themes,
        &#34;plot_points&#34;: self.plot_points,
        &#34;metadata&#34;: self.metadata,
    }</code></pre>
</details>
<div class="desc"><p>Convert the game data to a dictionary for serialization.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary representation of the game data.</p></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.engine.GameState"><code class="flex name class">
<span>class <span class="ident">GameState</span></span>
<span>(</span><span>current_scene: str,<br>inventory: list[str] = &lt;factory&gt;,<br>visited_scenes: set[str] = &lt;factory&gt;,<br>game_flags: dict[str, bool] = &lt;factory&gt;,<br>health: int = 100,<br>max_health: int = 100)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class GameState:
    &#34;&#34;&#34;
    Represents the current state of a game session.

    This class tracks all mutable state during gameplay, including player location,
    inventory, visited areas, game flags for puzzle/story progression, and health.

    Attributes:
        current_scene: The ID of the scene where the player is currently located.
        inventory: List of item IDs currently held by the player.
        visited_scenes: Set of scene IDs that the player has visited.
        game_flags: Dictionary of boolean flags for tracking game state
                   (e.g., puzzles solved, doors unlocked, NPCs encountered).
        health: Current health points of the player.
        max_health: Maximum health points the player can have.

    Examples:
        Create a new game state:
        &gt;&gt;&gt; state = GameState(
        ...     current_scene=&#34;cargo_bay&#34;,
        ...     inventory=[&#34;bolt_pistol&#34;],
        ...     visited_scenes={&#34;cargo_bay&#34;},
        ...     game_flags={&#34;hull_breach_sealed&#34;: False},
        ...     health=100,
        ...     max_health=100
        ... )

        Update player location:
        &gt;&gt;&gt; state.current_scene = &#34;bridge&#34;
        &gt;&gt;&gt; state.visited_scenes.add(&#34;bridge&#34;)

        Modify inventory:
        &gt;&gt;&gt; state.inventory.append(&#34;power_cell&#34;)

        Track puzzle progress:
        &gt;&gt;&gt; state.game_flags[&#34;airlock_opened&#34;] = True

        Manage health:
        &gt;&gt;&gt; state.health -= 20  # Take damage
        &gt;&gt;&gt; state.health = min(state.health + 30, state.max_health)  # Heal
    &#34;&#34;&#34;

    current_scene: str
    inventory: list[str] = field(default_factory=list)
    visited_scenes: set[str] = field(default_factory=set)
    game_flags: dict[str, bool] = field(default_factory=dict)
    health: int = 100
    max_health: int = 100

    def __post_init__(self):
        &#34;&#34;&#34;Validate the game state after initialization.&#34;&#34;&#34;
        if self.health &lt; 0:
            raise ValueError(&#34;Health cannot be negative&#34;)
        if self.max_health &lt;= 0:
            raise ValueError(&#34;Max health must be positive&#34;)
        if self.health &gt; self.max_health:
            raise ValueError(&#34;Health cannot exceed max_health&#34;)
        if not self.current_scene:
            raise ValueError(&#34;current_scene cannot be empty&#34;)

    def add_item(self, item_id: str) -&gt; None:
        &#34;&#34;&#34;
        Add an item to the player&#39;s inventory.

        Args:
            item_id: The ID of the item to add.

        Examples:
            &gt;&gt;&gt; state = GameState(current_scene=&#34;test&#34;)
            &gt;&gt;&gt; state.add_item(&#34;medkit&#34;)
            &gt;&gt;&gt; &#34;medkit&#34; in state.inventory
            True
        &#34;&#34;&#34;
        if item_id not in self.inventory:
            self.inventory.append(item_id)

    def remove_item(self, item_id: str) -&gt; bool:
        &#34;&#34;&#34;
        Remove an item from the player&#39;s inventory.

        Args:
            item_id: The ID of the item to remove.

        Returns:
            True if the item was removed, False if it wasn&#39;t in inventory.

        Examples:
            &gt;&gt;&gt; state = GameState(current_scene=&#34;test&#34;, inventory=[&#34;key&#34;])
            &gt;&gt;&gt; state.remove_item(&#34;key&#34;)
            True
            &gt;&gt;&gt; state.remove_item(&#34;key&#34;)
            False
        &#34;&#34;&#34;
        if item_id in self.inventory:
            self.inventory.remove(item_id)
            return True
        return False

    def has_item(self, item_id: str) -&gt; bool:
        &#34;&#34;&#34;
        Check if the player has a specific item.

        Args:
            item_id: The ID of the item to check.

        Returns:
            True if the player has the item, False otherwise.

        Examples:
            &gt;&gt;&gt; state = GameState(current_scene=&#34;test&#34;, inventory=[&#34;sword&#34;])
            &gt;&gt;&gt; state.has_item(&#34;sword&#34;)
            True
            &gt;&gt;&gt; state.has_item(&#34;shield&#34;)
            False
        &#34;&#34;&#34;
        return item_id in self.inventory

    def set_flag(self, flag_name: str, value: bool = True) -&gt; None:
        &#34;&#34;&#34;
        Set a game flag to track story or puzzle progress.

        Args:
            flag_name: The name of the flag to set.
            value: The boolean value to set (default: True).

        Examples:
            &gt;&gt;&gt; state = GameState(current_scene=&#34;test&#34;)
            &gt;&gt;&gt; state.set_flag(&#34;door_opened&#34;)
            &gt;&gt;&gt; state.game_flags[&#34;door_opened&#34;]
            True
        &#34;&#34;&#34;
        self.game_flags[flag_name] = value

    def get_flag(self, flag_name: str, default: bool = False) -&gt; bool:
        &#34;&#34;&#34;
        Get the value of a game flag.

        Args:
            flag_name: The name of the flag to retrieve.
            default: The default value if the flag doesn&#39;t exist.

        Returns:
            The boolean value of the flag, or the default if not set.

        Examples:
            &gt;&gt;&gt; state = GameState(current_scene=&#34;test&#34;)
            &gt;&gt;&gt; state.set_flag(&#34;puzzle_solved&#34;, True)
            &gt;&gt;&gt; state.get_flag(&#34;puzzle_solved&#34;)
            True
            &gt;&gt;&gt; state.get_flag(&#34;unknown_flag&#34;, False)
            False
        &#34;&#34;&#34;
        return self.game_flags.get(flag_name, default)

    def visit_scene(self, scene_id: str) -&gt; None:
        &#34;&#34;&#34;
        Mark a scene as visited and update current location.

        Args:
            scene_id: The ID of the scene to visit.

        Examples:
            &gt;&gt;&gt; state = GameState(current_scene=&#34;start&#34;)
            &gt;&gt;&gt; state.visit_scene(&#34;next_room&#34;)
            &gt;&gt;&gt; state.current_scene
            &#39;next_room&#39;
            &gt;&gt;&gt; &#34;next_room&#34; in state.visited_scenes
            True
        &#34;&#34;&#34;
        self.current_scene = scene_id
        self.visited_scenes.add(scene_id)

    def has_visited(self, scene_id: str) -&gt; bool:
        &#34;&#34;&#34;
        Check if the player has visited a specific scene.

        Args:
            scene_id: The ID of the scene to check.

        Returns:
            True if the scene has been visited, False otherwise.

        Examples:
            &gt;&gt;&gt; state = GameState(current_scene=&#34;test&#34;)
            &gt;&gt;&gt; state.visited_scenes.add(&#34;old_room&#34;)
            &gt;&gt;&gt; state.has_visited(&#34;old_room&#34;)
            True
            &gt;&gt;&gt; state.has_visited(&#34;new_room&#34;)
            False
        &#34;&#34;&#34;
        return scene_id in self.visited_scenes

    def take_damage(self, amount: int) -&gt; None:
        &#34;&#34;&#34;
        Reduce player health by the specified amount.

        Args:
            amount: The amount of damage to take (must be non-negative).

        Examples:
            &gt;&gt;&gt; state = GameState(current_scene=&#34;test&#34;, health=100)
            &gt;&gt;&gt; state.take_damage(30)
            &gt;&gt;&gt; state.health
            70
        &#34;&#34;&#34;
        if amount &lt; 0:
            raise ValueError(&#34;Damage amount must be non-negative&#34;)
        self.health = max(0, self.health - amount)

    def heal(self, amount: int) -&gt; None:
        &#34;&#34;&#34;
        Restore player health by the specified amount, up to max_health.

        Args:
            amount: The amount of health to restore (must be non-negative).

        Examples:
            &gt;&gt;&gt; state = GameState(current_scene=&#34;test&#34;, health=50, max_health=100)
            &gt;&gt;&gt; state.heal(30)
            &gt;&gt;&gt; state.health
            80
            &gt;&gt;&gt; state.heal(50)
            &gt;&gt;&gt; state.health
            100
        &#34;&#34;&#34;
        if amount &lt; 0:
            raise ValueError(&#34;Heal amount must be non-negative&#34;)
        self.health = min(self.max_health, self.health + amount)

    def is_alive(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if the player is still alive.

        Returns:
            True if health &gt; 0, False otherwise.

        Examples:
            &gt;&gt;&gt; state = GameState(current_scene=&#34;test&#34;, health=50)
            &gt;&gt;&gt; state.is_alive()
            True
            &gt;&gt;&gt; state.health = 0
            &gt;&gt;&gt; state.is_alive()
            False
        &#34;&#34;&#34;
        return self.health &gt; 0

    def to_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        Convert the game state to a dictionary for serialization.

        Returns:
            Dictionary representation of the game state.

        Examples:
            &gt;&gt;&gt; state = GameState(current_scene=&#34;test&#34;)
            &gt;&gt;&gt; data = state.to_dict()
            &gt;&gt;&gt; data[&#39;current_scene&#39;]
            &#39;test&#39;
        &#34;&#34;&#34;
        return {
            &#34;current_scene&#34;: self.current_scene,
            &#34;inventory&#34;: list(self.inventory),
            &#34;visited_scenes&#34;: list(self.visited_scenes),
            &#34;game_flags&#34;: dict(self.game_flags),
            &#34;health&#34;: self.health,
            &#34;max_health&#34;: self.max_health,
        }

    @classmethod
    def from_dict(cls, data: dict) -&gt; &#34;GameState&#34;:
        &#34;&#34;&#34;
        Create a GameState from a dictionary.

        Args:
            data: Dictionary containing game state data.

        Returns:
            A new GameState instance.

        Examples:
            &gt;&gt;&gt; data = {
            ...     &#39;current_scene&#39;: &#39;test&#39;,
            ...     &#39;inventory&#39;: [&#39;item1&#39;],
            ...     &#39;visited_scenes&#39;: [&#39;test&#39;, &#39;other&#39;],
            ...     &#39;game_flags&#39;: {&#39;flag1&#39;: True},
            ...     &#39;health&#39;: 80,
            ...     &#39;max_health&#39;: 100
            ... }
            &gt;&gt;&gt; state = GameState.from_dict(data)
            &gt;&gt;&gt; state.health
            80
        &#34;&#34;&#34;
        return cls(
            current_scene=data[&#34;current_scene&#34;],
            inventory=list(data.get(&#34;inventory&#34;, [])),
            visited_scenes=set(data.get(&#34;visited_scenes&#34;, [])),
            game_flags=dict(data.get(&#34;game_flags&#34;, {})),
            health=data.get(&#34;health&#34;, 100),
            max_health=data.get(&#34;max_health&#34;, 100),
        )</code></pre>
</details>
<div class="desc"><p>Represents the current state of a game session.</p>
<p>This class tracks all mutable state during gameplay, including player location,
inventory, visited areas, game flags for puzzle/story progression, and health.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>current_scene</code></strong></dt>
<dd>The ID of the scene where the player is currently located.</dd>
<dt><strong><code>inventory</code></strong></dt>
<dd>List of item IDs currently held by the player.</dd>
<dt><strong><code>visited_scenes</code></strong></dt>
<dd>Set of scene IDs that the player has visited.</dd>
<dt><strong><code>game_flags</code></strong></dt>
<dd>Dictionary of boolean flags for tracking game state
(e.g., puzzles solved, doors unlocked, NPCs encountered).</dd>
<dt><strong><code>health</code></strong></dt>
<dd>Current health points of the player.</dd>
<dt><strong><code>max_health</code></strong></dt>
<dd>Maximum health points the player can have.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Create a new game state:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; state = GameState(
...     current_scene=&quot;cargo_bay&quot;,
...     inventory=[&quot;bolt_pistol&quot;],
...     visited_scenes={&quot;cargo_bay&quot;},
...     game_flags={&quot;hull_breach_sealed&quot;: False},
...     health=100,
...     max_health=100
... )
</code></pre>
<p>Update player location:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; state.current_scene = &quot;bridge&quot;
&gt;&gt;&gt; state.visited_scenes.add(&quot;bridge&quot;)
</code></pre>
<p>Modify inventory:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; state.inventory.append(&quot;power_cell&quot;)
</code></pre>
<p>Track puzzle progress:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; state.game_flags[&quot;airlock_opened&quot;] = True
</code></pre>
<p>Manage health:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; state.health -= 20  # Take damage
&gt;&gt;&gt; state.health = min(state.health + 30, state.max_health)  # Heal
</code></pre></div>
<h3>Static methods</h3>
<dl>
<dt id="space_hulk_game.engine.GameState.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict) ‑> <a title="space_hulk_game.engine.game_state.GameState" href="game_state.html#space_hulk_game.engine.game_state.GameState">GameState</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a GameState from a dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing game state data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new GameState instance.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; data = {
...     'current_scene': 'test',
...     'inventory': ['item1'],
...     'visited_scenes': ['test', 'other'],
...     'game_flags': {'flag1': True},
...     'health': 80,
...     'max_health': 100
... }
&gt;&gt;&gt; state = GameState.from_dict(data)
&gt;&gt;&gt; state.health
80
</code></pre></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="space_hulk_game.engine.GameState.current_scene"><code class="name">var <span class="ident">current_scene</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.GameState.game_flags"><code class="name">var <span class="ident">game_flags</span> : dict[str, bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.GameState.health"><code class="name">var <span class="ident">health</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.GameState.inventory"><code class="name">var <span class="ident">inventory</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.GameState.max_health"><code class="name">var <span class="ident">max_health</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.GameState.visited_scenes"><code class="name">var <span class="ident">visited_scenes</span> : set[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="space_hulk_game.engine.GameState.add_item"><code class="name flex">
<span>def <span class="ident">add_item</span></span>(<span>self, item_id: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_item(self, item_id: str) -&gt; None:
    &#34;&#34;&#34;
    Add an item to the player&#39;s inventory.

    Args:
        item_id: The ID of the item to add.

    Examples:
        &gt;&gt;&gt; state = GameState(current_scene=&#34;test&#34;)
        &gt;&gt;&gt; state.add_item(&#34;medkit&#34;)
        &gt;&gt;&gt; &#34;medkit&#34; in state.inventory
        True
    &#34;&#34;&#34;
    if item_id not in self.inventory:
        self.inventory.append(item_id)</code></pre>
</details>
<div class="desc"><p>Add an item to the player's inventory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item_id</code></strong></dt>
<dd>The ID of the item to add.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; state = GameState(current_scene=&quot;test&quot;)
&gt;&gt;&gt; state.add_item(&quot;medkit&quot;)
&gt;&gt;&gt; &quot;medkit&quot; in state.inventory
True
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.GameState.get_flag"><code class="name flex">
<span>def <span class="ident">get_flag</span></span>(<span>self, flag_name: str, default: bool = False) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_flag(self, flag_name: str, default: bool = False) -&gt; bool:
    &#34;&#34;&#34;
    Get the value of a game flag.

    Args:
        flag_name: The name of the flag to retrieve.
        default: The default value if the flag doesn&#39;t exist.

    Returns:
        The boolean value of the flag, or the default if not set.

    Examples:
        &gt;&gt;&gt; state = GameState(current_scene=&#34;test&#34;)
        &gt;&gt;&gt; state.set_flag(&#34;puzzle_solved&#34;, True)
        &gt;&gt;&gt; state.get_flag(&#34;puzzle_solved&#34;)
        True
        &gt;&gt;&gt; state.get_flag(&#34;unknown_flag&#34;, False)
        False
    &#34;&#34;&#34;
    return self.game_flags.get(flag_name, default)</code></pre>
</details>
<div class="desc"><p>Get the value of a game flag.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>flag_name</code></strong></dt>
<dd>The name of the flag to retrieve.</dd>
<dt><strong><code>default</code></strong></dt>
<dd>The default value if the flag doesn't exist.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The boolean value of the flag, or the default if not set.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; state = GameState(current_scene=&quot;test&quot;)
&gt;&gt;&gt; state.set_flag(&quot;puzzle_solved&quot;, True)
&gt;&gt;&gt; state.get_flag(&quot;puzzle_solved&quot;)
True
&gt;&gt;&gt; state.get_flag(&quot;unknown_flag&quot;, False)
False
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.GameState.has_item"><code class="name flex">
<span>def <span class="ident">has_item</span></span>(<span>self, item_id: str) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_item(self, item_id: str) -&gt; bool:
    &#34;&#34;&#34;
    Check if the player has a specific item.

    Args:
        item_id: The ID of the item to check.

    Returns:
        True if the player has the item, False otherwise.

    Examples:
        &gt;&gt;&gt; state = GameState(current_scene=&#34;test&#34;, inventory=[&#34;sword&#34;])
        &gt;&gt;&gt; state.has_item(&#34;sword&#34;)
        True
        &gt;&gt;&gt; state.has_item(&#34;shield&#34;)
        False
    &#34;&#34;&#34;
    return item_id in self.inventory</code></pre>
</details>
<div class="desc"><p>Check if the player has a specific item.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item_id</code></strong></dt>
<dd>The ID of the item to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the player has the item, False otherwise.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; state = GameState(current_scene=&quot;test&quot;, inventory=[&quot;sword&quot;])
&gt;&gt;&gt; state.has_item(&quot;sword&quot;)
True
&gt;&gt;&gt; state.has_item(&quot;shield&quot;)
False
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.GameState.has_visited"><code class="name flex">
<span>def <span class="ident">has_visited</span></span>(<span>self, scene_id: str) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_visited(self, scene_id: str) -&gt; bool:
    &#34;&#34;&#34;
    Check if the player has visited a specific scene.

    Args:
        scene_id: The ID of the scene to check.

    Returns:
        True if the scene has been visited, False otherwise.

    Examples:
        &gt;&gt;&gt; state = GameState(current_scene=&#34;test&#34;)
        &gt;&gt;&gt; state.visited_scenes.add(&#34;old_room&#34;)
        &gt;&gt;&gt; state.has_visited(&#34;old_room&#34;)
        True
        &gt;&gt;&gt; state.has_visited(&#34;new_room&#34;)
        False
    &#34;&#34;&#34;
    return scene_id in self.visited_scenes</code></pre>
</details>
<div class="desc"><p>Check if the player has visited a specific scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scene_id</code></strong></dt>
<dd>The ID of the scene to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the scene has been visited, False otherwise.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; state = GameState(current_scene=&quot;test&quot;)
&gt;&gt;&gt; state.visited_scenes.add(&quot;old_room&quot;)
&gt;&gt;&gt; state.has_visited(&quot;old_room&quot;)
True
&gt;&gt;&gt; state.has_visited(&quot;new_room&quot;)
False
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.GameState.heal"><code class="name flex">
<span>def <span class="ident">heal</span></span>(<span>self, amount: int) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def heal(self, amount: int) -&gt; None:
    &#34;&#34;&#34;
    Restore player health by the specified amount, up to max_health.

    Args:
        amount: The amount of health to restore (must be non-negative).

    Examples:
        &gt;&gt;&gt; state = GameState(current_scene=&#34;test&#34;, health=50, max_health=100)
        &gt;&gt;&gt; state.heal(30)
        &gt;&gt;&gt; state.health
        80
        &gt;&gt;&gt; state.heal(50)
        &gt;&gt;&gt; state.health
        100
    &#34;&#34;&#34;
    if amount &lt; 0:
        raise ValueError(&#34;Heal amount must be non-negative&#34;)
    self.health = min(self.max_health, self.health + amount)</code></pre>
</details>
<div class="desc"><p>Restore player health by the specified amount, up to max_health.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>amount</code></strong></dt>
<dd>The amount of health to restore (must be non-negative).</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; state = GameState(current_scene=&quot;test&quot;, health=50, max_health=100)
&gt;&gt;&gt; state.heal(30)
&gt;&gt;&gt; state.health
80
&gt;&gt;&gt; state.heal(50)
&gt;&gt;&gt; state.health
100
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.GameState.is_alive"><code class="name flex">
<span>def <span class="ident">is_alive</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_alive(self) -&gt; bool:
    &#34;&#34;&#34;
    Check if the player is still alive.

    Returns:
        True if health &gt; 0, False otherwise.

    Examples:
        &gt;&gt;&gt; state = GameState(current_scene=&#34;test&#34;, health=50)
        &gt;&gt;&gt; state.is_alive()
        True
        &gt;&gt;&gt; state.health = 0
        &gt;&gt;&gt; state.is_alive()
        False
    &#34;&#34;&#34;
    return self.health &gt; 0</code></pre>
</details>
<div class="desc"><p>Check if the player is still alive.</p>
<h2 id="returns">Returns</h2>
<p>True if health &gt; 0, False otherwise.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; state = GameState(current_scene=&quot;test&quot;, health=50)
&gt;&gt;&gt; state.is_alive()
True
&gt;&gt;&gt; state.health = 0
&gt;&gt;&gt; state.is_alive()
False
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.GameState.remove_item"><code class="name flex">
<span>def <span class="ident">remove_item</span></span>(<span>self, item_id: str) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_item(self, item_id: str) -&gt; bool:
    &#34;&#34;&#34;
    Remove an item from the player&#39;s inventory.

    Args:
        item_id: The ID of the item to remove.

    Returns:
        True if the item was removed, False if it wasn&#39;t in inventory.

    Examples:
        &gt;&gt;&gt; state = GameState(current_scene=&#34;test&#34;, inventory=[&#34;key&#34;])
        &gt;&gt;&gt; state.remove_item(&#34;key&#34;)
        True
        &gt;&gt;&gt; state.remove_item(&#34;key&#34;)
        False
    &#34;&#34;&#34;
    if item_id in self.inventory:
        self.inventory.remove(item_id)
        return True
    return False</code></pre>
</details>
<div class="desc"><p>Remove an item from the player's inventory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item_id</code></strong></dt>
<dd>The ID of the item to remove.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the item was removed, False if it wasn't in inventory.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; state = GameState(current_scene=&quot;test&quot;, inventory=[&quot;key&quot;])
&gt;&gt;&gt; state.remove_item(&quot;key&quot;)
True
&gt;&gt;&gt; state.remove_item(&quot;key&quot;)
False
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.GameState.set_flag"><code class="name flex">
<span>def <span class="ident">set_flag</span></span>(<span>self, flag_name: str, value: bool = True) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_flag(self, flag_name: str, value: bool = True) -&gt; None:
    &#34;&#34;&#34;
    Set a game flag to track story or puzzle progress.

    Args:
        flag_name: The name of the flag to set.
        value: The boolean value to set (default: True).

    Examples:
        &gt;&gt;&gt; state = GameState(current_scene=&#34;test&#34;)
        &gt;&gt;&gt; state.set_flag(&#34;door_opened&#34;)
        &gt;&gt;&gt; state.game_flags[&#34;door_opened&#34;]
        True
    &#34;&#34;&#34;
    self.game_flags[flag_name] = value</code></pre>
</details>
<div class="desc"><p>Set a game flag to track story or puzzle progress.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>flag_name</code></strong></dt>
<dd>The name of the flag to set.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>The boolean value to set (default: True).</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; state = GameState(current_scene=&quot;test&quot;)
&gt;&gt;&gt; state.set_flag(&quot;door_opened&quot;)
&gt;&gt;&gt; state.game_flags[&quot;door_opened&quot;]
True
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.GameState.take_damage"><code class="name flex">
<span>def <span class="ident">take_damage</span></span>(<span>self, amount: int) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take_damage(self, amount: int) -&gt; None:
    &#34;&#34;&#34;
    Reduce player health by the specified amount.

    Args:
        amount: The amount of damage to take (must be non-negative).

    Examples:
        &gt;&gt;&gt; state = GameState(current_scene=&#34;test&#34;, health=100)
        &gt;&gt;&gt; state.take_damage(30)
        &gt;&gt;&gt; state.health
        70
    &#34;&#34;&#34;
    if amount &lt; 0:
        raise ValueError(&#34;Damage amount must be non-negative&#34;)
    self.health = max(0, self.health - amount)</code></pre>
</details>
<div class="desc"><p>Reduce player health by the specified amount.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>amount</code></strong></dt>
<dd>The amount of damage to take (must be non-negative).</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; state = GameState(current_scene=&quot;test&quot;, health=100)
&gt;&gt;&gt; state.take_damage(30)
&gt;&gt;&gt; state.health
70
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.GameState.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict:
    &#34;&#34;&#34;
    Convert the game state to a dictionary for serialization.

    Returns:
        Dictionary representation of the game state.

    Examples:
        &gt;&gt;&gt; state = GameState(current_scene=&#34;test&#34;)
        &gt;&gt;&gt; data = state.to_dict()
        &gt;&gt;&gt; data[&#39;current_scene&#39;]
        &#39;test&#39;
    &#34;&#34;&#34;
    return {
        &#34;current_scene&#34;: self.current_scene,
        &#34;inventory&#34;: list(self.inventory),
        &#34;visited_scenes&#34;: list(self.visited_scenes),
        &#34;game_flags&#34;: dict(self.game_flags),
        &#34;health&#34;: self.health,
        &#34;max_health&#34;: self.max_health,
    }</code></pre>
</details>
<div class="desc"><p>Convert the game state to a dictionary for serialization.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary representation of the game state.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; state = GameState(current_scene=&quot;test&quot;)
&gt;&gt;&gt; data = state.to_dict()
&gt;&gt;&gt; data['current_scene']
'test'
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.GameState.visit_scene"><code class="name flex">
<span>def <span class="ident">visit_scene</span></span>(<span>self, scene_id: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_scene(self, scene_id: str) -&gt; None:
    &#34;&#34;&#34;
    Mark a scene as visited and update current location.

    Args:
        scene_id: The ID of the scene to visit.

    Examples:
        &gt;&gt;&gt; state = GameState(current_scene=&#34;start&#34;)
        &gt;&gt;&gt; state.visit_scene(&#34;next_room&#34;)
        &gt;&gt;&gt; state.current_scene
        &#39;next_room&#39;
        &gt;&gt;&gt; &#34;next_room&#34; in state.visited_scenes
        True
    &#34;&#34;&#34;
    self.current_scene = scene_id
    self.visited_scenes.add(scene_id)</code></pre>
</details>
<div class="desc"><p>Mark a scene as visited and update current location.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scene_id</code></strong></dt>
<dd>The ID of the scene to visit.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; state = GameState(current_scene=&quot;start&quot;)
&gt;&gt;&gt; state.visit_scene(&quot;next_room&quot;)
&gt;&gt;&gt; state.current_scene
'next_room'
&gt;&gt;&gt; &quot;next_room&quot; in state.visited_scenes
True
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.engine.GameValidator"><code class="flex name class">
<span>class <span class="ident">GameValidator</span></span>
<span>(</span><span>strict_mode: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameValidator:
    &#34;&#34;&#34;
    Validates game content for playability issues.

    The GameValidator performs comprehensive checks on GameData to ensure:
    - All scenes are reachable from the starting scene
    - No dead ends exist (except intended endings)
    - All scene exits point to valid scenes
    - Required items for puzzles exist in the game
    - NPCs have valid dialogue
    - Puzzle prerequisites are satisfiable

    Attributes:
        strict_mode: If True, treats warnings as errors.

    Examples:
        Validate a game:
        &gt;&gt;&gt; from space_hulk_game.engine import GameData, Scene
        &gt;&gt;&gt; scene = Scene(id=&#34;start&#34;, name=&#34;Start&#34;, description=&#34;Begin here&#34;,
        ...               exits={&#34;north&#34;: &#34;room2&#34;})
        &gt;&gt;&gt; data = GameData(
        ...     title=&#34;Test&#34;,
        ...     description=&#34;Test game&#34;,
        ...     scenes={&#34;start&#34;: scene},
        ...     starting_scene=&#34;start&#34;
        ... )
        &gt;&gt;&gt; validator = GameValidator()
        &gt;&gt;&gt; result = validator.validate_game(data)
        &gt;&gt;&gt; # Should have issue about missing scene &#39;room2&#39;
        &gt;&gt;&gt; len(result.issues) &gt; 0
        True

        Use strict mode:
        &gt;&gt;&gt; validator = GameValidator(strict_mode=True)
        &gt;&gt;&gt; result = validator.validate_game(data)
    &#34;&#34;&#34;

    def __init__(self, strict_mode: bool = False):
        &#34;&#34;&#34;
        Initialize the GameValidator.

        Args:
            strict_mode: If True, treats warnings as errors.
        &#34;&#34;&#34;
        self.strict_mode = strict_mode
        logger.info(f&#34;GameValidator initialized (strict_mode={strict_mode})&#34;)

    def validate_game(self, game_data: GameData) -&gt; ValidationResult:
        &#34;&#34;&#34;
        Validate a complete game for playability issues.

        This is the main entry point for validation. It runs all validation
        checks and returns a comprehensive report.

        Args:
            game_data: The GameData object to validate.

        Returns:
            ValidationResult containing all issues, warnings, and suggestions.

        Examples:
            &gt;&gt;&gt; from space_hulk_game.engine import GameData, Scene
            &gt;&gt;&gt; scene = Scene(id=&#34;start&#34;, name=&#34;Start&#34;, description=&#34;Begin&#34;)
            &gt;&gt;&gt; data = GameData(
            ...     title=&#34;Test&#34;,
            ...     description=&#34;Test&#34;,
            ...     scenes={&#34;start&#34;: scene},
            ...     starting_scene=&#34;start&#34;
            ... )
            &gt;&gt;&gt; validator = GameValidator()
            &gt;&gt;&gt; result = validator.validate_game(data)
            &gt;&gt;&gt; result.is_valid()
            True
        &#34;&#34;&#34;
        logger.info(f&#34;Validating game: {game_data.title}&#34;)
        result = ValidationResult()

        # Collect statistics
        result.stats = {
            &#34;total_scenes&#34;: len(game_data.scenes),
            &#34;total_items&#34;: len(game_data.global_items),
            &#34;total_npcs&#34;: len(game_data.global_npcs),
            &#34;starting_scene&#34;: game_data.starting_scene,
        }

        # Run all validation checks
        self._check_scene_reachability(game_data, result)
        self._check_invalid_exits(game_data, result)
        self._check_dead_ends(game_data, result)
        self._check_missing_items(game_data, result)
        self._check_npc_dialogues(game_data, result)
        self._check_locked_exits(game_data, result)

        # Update statistics
        result.stats[&#34;reachable_scenes&#34;] = len(
            self._find_reachable_scenes(game_data.scenes, game_data.starting_scene)
        )

        logger.info(
            f&#34;Validation complete: {len(result.issues)} issues, &#34; f&#34;{len(result.warnings)} warnings&#34;
        )

        # If strict_mode is enabled, treat warnings as errors
        if self.strict_mode:
            result.issues.extend(result.warnings)
            result.warnings.clear()

        return result

    def _find_reachable_scenes(self, scenes: dict[str, Scene], starting_scene: str) -&gt; set[str]:
        &#34;&#34;&#34;
        Find all scenes reachable from the starting scene using BFS.

        Args:
            scenes: Dictionary of all scenes.
            starting_scene: ID of the starting scene.

        Returns:
            Set of scene IDs that are reachable.

        Examples:
            &gt;&gt;&gt; scene1 = Scene(id=&#34;s1&#34;, name=&#34;S1&#34;, description=&#34;First&#34;,
            ...                exits={&#34;north&#34;: &#34;s2&#34;})
            &gt;&gt;&gt; scene2 = Scene(id=&#34;s2&#34;, name=&#34;S2&#34;, description=&#34;Second&#34;)
            &gt;&gt;&gt; scenes = {&#34;s1&#34;: scene1, &#34;s2&#34;: scene2}
            &gt;&gt;&gt; validator = GameValidator()
            &gt;&gt;&gt; reachable = validator._find_reachable_scenes(scenes, &#34;s1&#34;)
            &gt;&gt;&gt; len(reachable)
            2
            &gt;&gt;&gt; &#34;s1&#34; in reachable and &#34;s2&#34; in reachable
            True
        &#34;&#34;&#34;
        reachable = set()
        queue = deque([starting_scene])

        while queue:
            current_id = queue.popleft()

            if current_id in reachable:
                continue

            if current_id not in scenes:
                # Invalid scene reference, but we&#39;ll handle this separately
                continue

            reachable.add(current_id)

            # Add all connected scenes to queue
            scene = scenes[current_id]
            for exit_target in scene.exits.values():
                if exit_target not in reachable:
                    queue.append(exit_target)

        return reachable

    def _check_scene_reachability(self, game_data: GameData, result: ValidationResult) -&gt; None:
        &#34;&#34;&#34;
        Check that all scenes are reachable from the starting scene.

        Args:
            game_data: The game data to check.
            result: ValidationResult to add issues to.
        &#34;&#34;&#34;
        logger.debug(&#34;Checking scene reachability&#34;)

        reachable = self._find_reachable_scenes(game_data.scenes, game_data.starting_scene)

        unreachable = set(game_data.scenes.keys()) - reachable

        if unreachable:
            unreachable_list = sorted(list(unreachable))
            result.add_issue(f&#34;Unreachable scenes: {&#39;, &#39;.join(unreachable_list)}&#34;)

            # Suggest connections
            for scene_id in unreachable_list:
                # Find closest reachable scene (simple heuristic: first reachable)
                if reachable:
                    closest = sorted(list(reachable))[0]
                    result.add_suggestion(closest, f&#34;Add exit to unreachable scene &#39;{scene_id}&#39;&#34;)

    def _check_invalid_exits(self, game_data: GameData, result: ValidationResult) -&gt; None:
        &#34;&#34;&#34;
        Check that all scene exits point to valid scenes.

        Args:
            game_data: The game data to check.
            result: ValidationResult to add issues to.
        &#34;&#34;&#34;
        logger.debug(&#34;Checking invalid exits&#34;)

        for scene_id, scene in game_data.scenes.items():
            for direction, target_id in scene.exits.items():
                if target_id not in game_data.scenes:
                    result.add_issue(
                        f&#34;Scene &#39;{scene_id}&#39; has invalid exit &#39;{direction}&#39; -&gt; &#34;
                        f&#34;&#39;{target_id}&#39; (scene does not exist)&#34;
                    )
                    result.add_suggestion(
                        scene_id, f&#34;Remove invalid exit &#39;{direction}&#39; or create scene &#39;{target_id}&#39;&#34;
                    )

    def _check_dead_ends(self, game_data: GameData, result: ValidationResult) -&gt; None:
        &#34;&#34;&#34;
        Check for dead ends (scenes with no exits).

        Dead ends are only acceptable if they&#39;re designated as endings.

        Args:
            game_data: The game data to check.
            result: ValidationResult to add issues to.
        &#34;&#34;&#34;
        logger.debug(&#34;Checking for dead ends&#34;)

        # Get list of valid ending scenes from game data
        valid_endings = set()
        for ending in game_data.endings:
            if isinstance(ending, dict) and &#34;scene_id&#34; in ending:
                valid_endings.add(ending[&#34;scene_id&#34;])

        dead_ends = []
        for scene_id, scene in game_data.scenes.items():
            if not scene.exits:
                # Check if this is a valid ending scene
                if scene_id not in valid_endings:
                    dead_ends.append(scene_id)

        if dead_ends:
            # Check if there are ANY defined endings
            if not game_data.endings:
                # If no endings defined, warn about dead ends
                result.add_warning(
                    f&#34;Dead end scenes found (no exits): {&#39;, &#39;.join(sorted(dead_ends))}. &#34;
                    f&#34;These should either have exits or be designated as ending scenes.&#34;
                )
            else:
                # If endings exist but these aren&#39;t marked, that&#39;s an issue
                result.add_issue(
                    f&#34;Dead end scenes found (not marked as endings): {&#39;, &#39;.join(sorted(dead_ends))}&#34;
                )

            for scene_id in dead_ends:
                result.add_suggestion(
                    scene_id, &#34;Add exits to other scenes or mark as an ending scene&#34;
                )

    def _check_missing_items(self, game_data: GameData, result: ValidationResult) -&gt; None:
        &#34;&#34;&#34;
        Check for references to items that don&#39;t exist.

        Checks:
        - Locked exits requiring non-existent items
        - NPCs giving non-existent items

        Args:
            game_data: The game data to check.
            result: ValidationResult to add issues to.
        &#34;&#34;&#34;
        logger.debug(&#34;Checking for missing items&#34;)

        # Build set of all available items
        all_items = set(game_data.global_items.keys())
        for scene in game_data.scenes.values():
            for item in scene.items:
                all_items.add(item.id)

        # Check locked exits
        for scene_id, scene in game_data.scenes.items():
            for direction, required_item in scene.locked_exits.items():
                # Could be an item or a flag
                # Only check if it looks like an item (not a flag pattern)
                if required_item and not required_item.startswith(&#34;flag_&#34;):
                    if required_item not in all_items:
                        result.add_warning(
                            f&#34;Scene &#39;{scene_id}&#39; exit &#39;{direction}&#39; requires &#34;
                            f&#34;&#39;{required_item}&#39; which may not exist as an item &#34;
                            f&#34;(could be a flag)&#34;
                        )

        # Check NPCs giving items
        for scene_id, scene in game_data.scenes.items():
            for npc in scene.npcs:
                if npc.gives_item and npc.gives_item not in all_items:
                    result.add_issue(
                        f&#34;NPC &#39;{npc.id}&#39; in scene &#39;{scene_id}&#39; gives item &#34;
                        f&#34;&#39;{npc.gives_item}&#39; which does not exist&#34;
                    )
                    result.add_suggestion(
                        scene_id, f&#34;Create item &#39;{npc.gives_item}&#39; or update NPC &#39;{npc.id}&#39;&#34;
                    )

        # Also check global NPCs
        for npc_id, npc in game_data.global_npcs.items():
            if npc.gives_item and npc.gives_item not in all_items:
                result.add_issue(
                    f&#34;Global NPC &#39;{npc_id}&#39; gives item &#39;{npc.gives_item}&#39; &#34; f&#34;which does not exist&#34;
                )

    def _check_npc_dialogues(self, game_data: GameData, result: ValidationResult) -&gt; None:
        &#34;&#34;&#34;
        Check that NPCs have valid dialogue.

        Warns about NPCs with no dialogue or empty dialogue.

        Args:
            game_data: The game data to check.
            result: ValidationResult to add issues to.
        &#34;&#34;&#34;
        logger.debug(&#34;Checking NPC dialogues&#34;)

        for scene_id, scene in game_data.scenes.items():
            for npc in scene.npcs:
                if not npc.dialogue:
                    result.add_warning(f&#34;NPC &#39;{npc.id}&#39; in scene &#39;{scene_id}&#39; has no dialogue&#34;)
                    result.add_suggestion(scene_id, f&#34;Add dialogue for NPC &#39;{npc.id}&#39;&#34;)
                elif all(not v for v in npc.dialogue.values()):
                    result.add_warning(f&#34;NPC &#39;{npc.id}&#39; in scene &#39;{scene_id}&#39; has empty dialogue&#34;)
                    result.add_suggestion(scene_id, f&#34;Add dialogue content for NPC &#39;{npc.id}&#39;&#34;)

        # Check global NPCs for dialogue issues
        for npc_id, npc in game_data.global_npcs.items():
            if not npc.dialogue:
                result.add_warning(f&#34;Global NPC &#39;{npc_id}&#39; has no dialogue&#34;)
            elif all(not v for v in npc.dialogue.values()):
                result.add_warning(f&#34;Global NPC &#39;{npc_id}&#39; has empty dialogue&#34;)

    def _check_locked_exits(self, game_data: GameData, result: ValidationResult) -&gt; None:
        &#34;&#34;&#34;
        Check that locked exits are solvable.

        Verifies that:
        - Required items/flags can be obtained
        - No circular dependencies

        Args:
            game_data: The game data to check.
            result: ValidationResult to add issues to.
        &#34;&#34;&#34;
        logger.debug(&#34;Checking locked exits&#34;)

        # Build set of obtainable items and flags
        obtainable_items = set(game_data.global_items.keys())

        # Items in scenes are obtainable
        for scene in game_data.scenes.values():
            for item in scene.items:
                if item.takeable:
                    obtainable_items.add(item.id)

        # Items given by NPCs are obtainable
        for scene in game_data.scenes.values():
            for npc in scene.npcs:
                if npc.gives_item:
                    obtainable_items.add(npc.gives_item)

        for npc in game_data.global_npcs.values():
            if npc.gives_item:
                obtainable_items.add(npc.gives_item)

        # Check locked exits in reachable scenes
        reachable = self._find_reachable_scenes(game_data.scenes, game_data.starting_scene)

        for scene_id in reachable:
            scene = game_data.scenes[scene_id]
            for direction, required in scene.locked_exits.items():
                target = scene.exits.get(direction)
                if target and target not in reachable:
                    # This exit leads to unreachable area
                    # Check if required item exists
                    if required not in obtainable_items:
                        # Could be a flag, not necessarily an error
                        if not required.startswith(&#34;flag_&#34;):
                            result.add_warning(
                                f&#34;Scene &#39;{scene_id}&#39; has locked exit &#39;{direction}&#39; &#34;
                                f&#34;requiring &#39;{required}&#39; which may not be obtainable&#34;
                            )</code></pre>
</details>
<div class="desc"><p>Validates game content for playability issues.</p>
<p>The GameValidator performs comprehensive checks on GameData to ensure:
- All scenes are reachable from the starting scene
- No dead ends exist (except intended endings)
- All scene exits point to valid scenes
- Required items for puzzles exist in the game
- NPCs have valid dialogue
- Puzzle prerequisites are satisfiable</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>strict_mode</code></strong></dt>
<dd>If True, treats warnings as errors.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Validate a game:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from space_hulk_game.engine import GameData, Scene
&gt;&gt;&gt; scene = Scene(id=&quot;start&quot;, name=&quot;Start&quot;, description=&quot;Begin here&quot;,
...               exits={&quot;north&quot;: &quot;room2&quot;})
&gt;&gt;&gt; data = GameData(
...     title=&quot;Test&quot;,
...     description=&quot;Test game&quot;,
...     scenes={&quot;start&quot;: scene},
...     starting_scene=&quot;start&quot;
... )
&gt;&gt;&gt; validator = GameValidator()
&gt;&gt;&gt; result = validator.validate_game(data)
&gt;&gt;&gt; # Should have issue about missing scene 'room2'
&gt;&gt;&gt; len(result.issues) &gt; 0
True
</code></pre>
<p>Use strict mode:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; validator = GameValidator(strict_mode=True)
&gt;&gt;&gt; result = validator.validate_game(data)
</code></pre>
<p>Initialize the GameValidator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>strict_mode</code></strong></dt>
<dd>If True, treats warnings as errors.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="space_hulk_game.engine.GameValidator.validate_game"><code class="name flex">
<span>def <span class="ident">validate_game</span></span>(<span>self,<br>game_data: <a title="space_hulk_game.engine.game_data.GameData" href="game_data.html#space_hulk_game.engine.game_data.GameData">GameData</a>) ‑> <a title="space_hulk_game.engine.validator.ValidationResult" href="validator.html#space_hulk_game.engine.validator.ValidationResult">ValidationResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_game(self, game_data: GameData) -&gt; ValidationResult:
    &#34;&#34;&#34;
    Validate a complete game for playability issues.

    This is the main entry point for validation. It runs all validation
    checks and returns a comprehensive report.

    Args:
        game_data: The GameData object to validate.

    Returns:
        ValidationResult containing all issues, warnings, and suggestions.

    Examples:
        &gt;&gt;&gt; from space_hulk_game.engine import GameData, Scene
        &gt;&gt;&gt; scene = Scene(id=&#34;start&#34;, name=&#34;Start&#34;, description=&#34;Begin&#34;)
        &gt;&gt;&gt; data = GameData(
        ...     title=&#34;Test&#34;,
        ...     description=&#34;Test&#34;,
        ...     scenes={&#34;start&#34;: scene},
        ...     starting_scene=&#34;start&#34;
        ... )
        &gt;&gt;&gt; validator = GameValidator()
        &gt;&gt;&gt; result = validator.validate_game(data)
        &gt;&gt;&gt; result.is_valid()
        True
    &#34;&#34;&#34;
    logger.info(f&#34;Validating game: {game_data.title}&#34;)
    result = ValidationResult()

    # Collect statistics
    result.stats = {
        &#34;total_scenes&#34;: len(game_data.scenes),
        &#34;total_items&#34;: len(game_data.global_items),
        &#34;total_npcs&#34;: len(game_data.global_npcs),
        &#34;starting_scene&#34;: game_data.starting_scene,
    }

    # Run all validation checks
    self._check_scene_reachability(game_data, result)
    self._check_invalid_exits(game_data, result)
    self._check_dead_ends(game_data, result)
    self._check_missing_items(game_data, result)
    self._check_npc_dialogues(game_data, result)
    self._check_locked_exits(game_data, result)

    # Update statistics
    result.stats[&#34;reachable_scenes&#34;] = len(
        self._find_reachable_scenes(game_data.scenes, game_data.starting_scene)
    )

    logger.info(
        f&#34;Validation complete: {len(result.issues)} issues, &#34; f&#34;{len(result.warnings)} warnings&#34;
    )

    # If strict_mode is enabled, treat warnings as errors
    if self.strict_mode:
        result.issues.extend(result.warnings)
        result.warnings.clear()

    return result</code></pre>
</details>
<div class="desc"><p>Validate a complete game for playability issues.</p>
<p>This is the main entry point for validation. It runs all validation
checks and returns a comprehensive report.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>game_data</code></strong></dt>
<dd>The GameData object to validate.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ValidationResult containing all issues, warnings, and suggestions.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from space_hulk_game.engine import GameData, Scene
&gt;&gt;&gt; scene = Scene(id=&quot;start&quot;, name=&quot;Start&quot;, description=&quot;Begin&quot;)
&gt;&gt;&gt; data = GameData(
...     title=&quot;Test&quot;,
...     description=&quot;Test&quot;,
...     scenes={&quot;start&quot;: scene},
...     starting_scene=&quot;start&quot;
... )
&gt;&gt;&gt; validator = GameValidator()
&gt;&gt;&gt; result = validator.validate_game(data)
&gt;&gt;&gt; result.is_valid()
True
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.engine.HelpAction"><code class="flex name class">
<span>class <span class="ident">HelpAction</span></span>
<span>(</span><span>raw_command: str = '')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class HelpAction(Action):
    &#34;&#34;&#34;
    Represents requesting help or available commands.

    Attributes:
        raw_command: The original text command from the player.

    Examples:
        &gt;&gt;&gt; action = HelpAction(raw_command=&#34;help&#34;)
        &gt;&gt;&gt; str(action)
        &#39;HelpAction()&#39;
    &#34;&#34;&#34;

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Return a string representation of the action.&#34;&#34;&#34;
        return &#34;HelpAction()&#34;</code></pre>
</details>
<div class="desc"><p>Represents requesting help or available commands.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>raw_command</code></strong></dt>
<dd>The original text command from the player.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; action = HelpAction(raw_command=&quot;help&quot;)
&gt;&gt;&gt; str(action)
'HelpAction()'
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="space_hulk_game.engine.actions.Action" href="actions.html#space_hulk_game.engine.actions.Action">Action</a></li>
</ul>
</dd>
<dt id="space_hulk_game.engine.InventoryAction"><code class="flex name class">
<span>class <span class="ident">InventoryAction</span></span>
<span>(</span><span>raw_command: str = '')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class InventoryAction(Action):
    &#34;&#34;&#34;
    Represents checking the player&#39;s inventory.

    Attributes:
        raw_command: The original text command from the player.

    Examples:
        &gt;&gt;&gt; action = InventoryAction(raw_command=&#34;inventory&#34;)
        &gt;&gt;&gt; str(action)
        &#39;InventoryAction()&#39;
    &#34;&#34;&#34;

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Return a string representation of the action.&#34;&#34;&#34;
        return &#34;InventoryAction()&#34;</code></pre>
</details>
<div class="desc"><p>Represents checking the player's inventory.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>raw_command</code></strong></dt>
<dd>The original text command from the player.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; action = InventoryAction(raw_command=&quot;inventory&quot;)
&gt;&gt;&gt; str(action)
'InventoryAction()'
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="space_hulk_game.engine.actions.Action" href="actions.html#space_hulk_game.engine.actions.Action">Action</a></li>
</ul>
</dd>
<dt id="space_hulk_game.engine.Item"><code class="flex name class">
<span>class <span class="ident">Item</span></span>
<span>(</span><span>id: str,<br>name: str,<br>description: str,<br>takeable: bool = False,<br>useable: bool = False,<br>use_text: str | None = None,<br>required_flag: str | None = None,<br>effects: dict[str, typing.Any] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Item:
    &#34;&#34;&#34;
    Represents an interactive item in the game world.

    Items can be picked up, examined, or used to solve puzzles and progress
    the story. They can have associated effects when used.

    Attributes:
        id: Unique identifier for the item.
        name: Display name of the item.
        description: Text description shown when examining the item.
        takeable: Whether the item can be added to inventory.
        useable: Whether the item can be used/activated.
        use_text: Text displayed when the item is used.
        required_flag: Optional game flag required to use this item.
        effects: Dictionary of effects applied when item is used
                (e.g., {&#39;unlock_door&#39;: &#39;door_id&#39;, &#39;heal&#39;: 20}).

    Examples:
        Create a simple takeable item:
        &gt;&gt;&gt; medkit = Item(
        ...     id=&#34;medkit&#34;,
        ...     name=&#34;Medical Kit&#34;,
        ...     description=&#34;A standard Imperial Guard medical kit.&#34;,
        ...     takeable=True,
        ...     useable=True,
        ...     use_text=&#34;You use the medkit and feel your wounds close.&#34;,
        ...     effects={&#39;heal&#39;: 30}
        ... )

        Create a key item for puzzles:
        &gt;&gt;&gt; key = Item(
        ...     id=&#34;brass_key&#34;,
        ...     name=&#34;Brass Key&#34;,
        ...     description=&#34;An ornate brass key with strange markings.&#34;,
        ...     takeable=True,
        ...     useable=True,
        ...     use_text=&#34;You insert the key and hear a satisfying click.&#34;,
        ...     effects={&#39;unlock_door&#39;: &#39;vault_door&#39;}
        ... )

        Create a scenery item:
        &gt;&gt;&gt; console = Item(
        ...     id=&#34;control_console&#34;,
        ...     name=&#34;Control Console&#34;,
        ...     description=&#34;A massive control console covered in blinking lights.&#34;,
        ...     takeable=False,
        ...     useable=True,
        ...     required_flag=&#34;has_access_card&#34;
        ... )
    &#34;&#34;&#34;

    id: str
    name: str
    description: str
    takeable: bool = False
    useable: bool = False
    use_text: Optional[str] = None
    required_flag: Optional[str] = None
    effects: dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        &#34;&#34;&#34;Validate the item after initialization.&#34;&#34;&#34;
        if not self.id:
            raise ValueError(&#34;Item id cannot be empty&#34;)
        if not self.name:
            raise ValueError(&#34;Item name cannot be empty&#34;)
        if not self.description:
            raise ValueError(&#34;Item description cannot be empty&#34;)

    def can_use(self, game_flags: dict[str, bool]) -&gt; bool:
        &#34;&#34;&#34;
        Check if the item can be used given current game flags.

        Args:
            game_flags: Dictionary of current game flags.

        Returns:
            True if the item can be used, False otherwise.

        Examples:
            &gt;&gt;&gt; item = Item(id=&#34;locked_box&#34;, name=&#34;Box&#34;, description=&#34;A locked box.&#34;,
            ...             required_flag=&#34;has_key&#34;)
            &gt;&gt;&gt; item.can_use({})
            False
            &gt;&gt;&gt; item.can_use({&#34;has_key&#34;: True})
            True
        &#34;&#34;&#34;
        if not self.useable:
            return False
        if self.required_flag:
            return game_flags.get(self.required_flag, False)
        return True

    def to_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        Convert the item to a dictionary for serialization.

        Returns:
            Dictionary representation of the item.
        &#34;&#34;&#34;
        return {
            &#34;id&#34;: self.id,
            &#34;name&#34;: self.name,
            &#34;description&#34;: self.description,
            &#34;takeable&#34;: self.takeable,
            &#34;useable&#34;: self.useable,
            &#34;use_text&#34;: self.use_text,
            &#34;required_flag&#34;: self.required_flag,
            &#34;effects&#34;: self.effects,
        }

    @classmethod
    def from_dict(cls, data: dict) -&gt; &#34;Item&#34;:
        &#34;&#34;&#34;
        Create an Item from a dictionary.

        Args:
            data: Dictionary containing item data.

        Returns:
            A new Item instance.
        &#34;&#34;&#34;
        return cls(
            id=data[&#34;id&#34;],
            name=data[&#34;name&#34;],
            description=data[&#34;description&#34;],
            takeable=data.get(&#34;takeable&#34;, False),
            useable=data.get(&#34;useable&#34;, False),
            use_text=data.get(&#34;use_text&#34;),
            required_flag=data.get(&#34;required_flag&#34;),
            effects=data.get(&#34;effects&#34;, {}),
        )</code></pre>
</details>
<div class="desc"><p>Represents an interactive item in the game world.</p>
<p>Items can be picked up, examined, or used to solve puzzles and progress
the story. They can have associated effects when used.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>Unique identifier for the item.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Display name of the item.</dd>
<dt><strong><code>description</code></strong></dt>
<dd>Text description shown when examining the item.</dd>
<dt><strong><code>takeable</code></strong></dt>
<dd>Whether the item can be added to inventory.</dd>
<dt><strong><code>useable</code></strong></dt>
<dd>Whether the item can be used/activated.</dd>
<dt><strong><code>use_text</code></strong></dt>
<dd>Text displayed when the item is used.</dd>
<dt><strong><code>required_flag</code></strong></dt>
<dd>Optional game flag required to use this item.</dd>
<dt><strong><code>effects</code></strong></dt>
<dd>Dictionary of effects applied when item is used
(e.g., {'unlock_door': 'door_id', 'heal': 20}).</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Create a simple takeable item:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; medkit = Item(
...     id=&quot;medkit&quot;,
...     name=&quot;Medical Kit&quot;,
...     description=&quot;A standard Imperial Guard medical kit.&quot;,
...     takeable=True,
...     useable=True,
...     use_text=&quot;You use the medkit and feel your wounds close.&quot;,
...     effects={'heal': 30}
... )
</code></pre>
<p>Create a key item for puzzles:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; key = Item(
...     id=&quot;brass_key&quot;,
...     name=&quot;Brass Key&quot;,
...     description=&quot;An ornate brass key with strange markings.&quot;,
...     takeable=True,
...     useable=True,
...     use_text=&quot;You insert the key and hear a satisfying click.&quot;,
...     effects={'unlock_door': 'vault_door'}
... )
</code></pre>
<p>Create a scenery item:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; console = Item(
...     id=&quot;control_console&quot;,
...     name=&quot;Control Console&quot;,
...     description=&quot;A massive control console covered in blinking lights.&quot;,
...     takeable=False,
...     useable=True,
...     required_flag=&quot;has_access_card&quot;
... )
</code></pre></div>
<h3>Static methods</h3>
<dl>
<dt id="space_hulk_game.engine.Item.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict) ‑> <a title="space_hulk_game.engine.entities.Item" href="entities.html#space_hulk_game.engine.entities.Item">Item</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create an Item from a dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing item data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new Item instance.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="space_hulk_game.engine.Item.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Item.effects"><code class="name">var <span class="ident">effects</span> : dict[str, typing.Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Item.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Item.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Item.required_flag"><code class="name">var <span class="ident">required_flag</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Item.takeable"><code class="name">var <span class="ident">takeable</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Item.use_text"><code class="name">var <span class="ident">use_text</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Item.useable"><code class="name">var <span class="ident">useable</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="space_hulk_game.engine.Item.can_use"><code class="name flex">
<span>def <span class="ident">can_use</span></span>(<span>self, game_flags: dict[str, bool]) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def can_use(self, game_flags: dict[str, bool]) -&gt; bool:
    &#34;&#34;&#34;
    Check if the item can be used given current game flags.

    Args:
        game_flags: Dictionary of current game flags.

    Returns:
        True if the item can be used, False otherwise.

    Examples:
        &gt;&gt;&gt; item = Item(id=&#34;locked_box&#34;, name=&#34;Box&#34;, description=&#34;A locked box.&#34;,
        ...             required_flag=&#34;has_key&#34;)
        &gt;&gt;&gt; item.can_use({})
        False
        &gt;&gt;&gt; item.can_use({&#34;has_key&#34;: True})
        True
    &#34;&#34;&#34;
    if not self.useable:
        return False
    if self.required_flag:
        return game_flags.get(self.required_flag, False)
    return True</code></pre>
</details>
<div class="desc"><p>Check if the item can be used given current game flags.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>game_flags</code></strong></dt>
<dd>Dictionary of current game flags.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the item can be used, False otherwise.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; item = Item(id=&quot;locked_box&quot;, name=&quot;Box&quot;, description=&quot;A locked box.&quot;,
...             required_flag=&quot;has_key&quot;)
&gt;&gt;&gt; item.can_use({})
False
&gt;&gt;&gt; item.can_use({&quot;has_key&quot;: True})
True
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.Item.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict:
    &#34;&#34;&#34;
    Convert the item to a dictionary for serialization.

    Returns:
        Dictionary representation of the item.
    &#34;&#34;&#34;
    return {
        &#34;id&#34;: self.id,
        &#34;name&#34;: self.name,
        &#34;description&#34;: self.description,
        &#34;takeable&#34;: self.takeable,
        &#34;useable&#34;: self.useable,
        &#34;use_text&#34;: self.use_text,
        &#34;required_flag&#34;: self.required_flag,
        &#34;effects&#34;: self.effects,
    }</code></pre>
</details>
<div class="desc"><p>Convert the item to a dictionary for serialization.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary representation of the item.</p></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.engine.LoaderError"><code class="flex name class">
<span>class <span class="ident">LoaderError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LoaderError(Exception):
    &#34;&#34;&#34;Base exception for content loading errors.&#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>Base exception for content loading errors.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="space_hulk_game.engine.loader.ValidationError" href="loader.html#space_hulk_game.engine.loader.ValidationError">ValidationError</a></li>
<li><a title="space_hulk_game.engine.loader.YAMLParseError" href="loader.html#space_hulk_game.engine.loader.YAMLParseError">YAMLParseError</a></li>
</ul>
</dd>
<dt id="space_hulk_game.engine.LookAction"><code class="flex name class">
<span>class <span class="ident">LookAction</span></span>
<span>(</span><span>raw_command: str = '', target: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class LookAction(Action):
    &#34;&#34;&#34;
    Represents examining the scene or an object.

    Attributes:
        target: Optional target to examine (if None, examine current scene).
        raw_command: The original text command from the player.

    Examples:
        &gt;&gt;&gt; action = LookAction(raw_command=&#34;look&#34;)
        &gt;&gt;&gt; action.target is None
        True

        &gt;&gt;&gt; action2 = LookAction(target=&#34;console&#34;, raw_command=&#34;examine console&#34;)
        &gt;&gt;&gt; action2.target
        &#39;console&#39;
    &#34;&#34;&#34;

    target: Optional[str] = None

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Return a string representation of the action.&#34;&#34;&#34;
        if self.target:
            return f&#34;LookAction(target=&#39;{self.target}&#39;)&#34;
        return &#34;LookAction()&#34;</code></pre>
</details>
<div class="desc"><p>Represents examining the scene or an object.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>target</code></strong></dt>
<dd>Optional target to examine (if None, examine current scene).</dd>
<dt><strong><code>raw_command</code></strong></dt>
<dd>The original text command from the player.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; action = LookAction(raw_command=&quot;look&quot;)
&gt;&gt;&gt; action.target is None
True
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; action2 = LookAction(target=&quot;console&quot;, raw_command=&quot;examine console&quot;)
&gt;&gt;&gt; action2.target
'console'
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="space_hulk_game.engine.actions.Action" href="actions.html#space_hulk_game.engine.actions.Action">Action</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="space_hulk_game.engine.LookAction.target"><code class="name">var <span class="ident">target</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.engine.MoveAction"><code class="flex name class">
<span>class <span class="ident">MoveAction</span></span>
<span>(</span><span>raw_command: str = '', direction: str = '')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class MoveAction(Action):
    &#34;&#34;&#34;
    Represents a movement action to another scene.

    Attributes:
        direction: The direction to move (e.g., &#34;north&#34;, &#34;south&#34;, &#34;door&#34;).
        raw_command: The original text command from the player.

    Examples:
        &gt;&gt;&gt; action = MoveAction(direction=&#34;north&#34;, raw_command=&#34;go north&#34;)
        &gt;&gt;&gt; action.direction
        &#39;north&#39;
    &#34;&#34;&#34;

    direction: str = &#34;&#34;

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Return a string representation of the action.&#34;&#34;&#34;
        return f&#34;MoveAction(direction=&#39;{self.direction}&#39;)&#34;</code></pre>
</details>
<div class="desc"><p>Represents a movement action to another scene.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>direction</code></strong></dt>
<dd>The direction to move (e.g., "north", "south", "door").</dd>
<dt><strong><code>raw_command</code></strong></dt>
<dd>The original text command from the player.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; action = MoveAction(direction=&quot;north&quot;, raw_command=&quot;go north&quot;)
&gt;&gt;&gt; action.direction
'north'
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="space_hulk_game.engine.actions.Action" href="actions.html#space_hulk_game.engine.actions.Action">Action</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="space_hulk_game.engine.MoveAction.direction"><code class="name">var <span class="ident">direction</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.engine.NPC"><code class="flex name class">
<span>class <span class="ident">NPC</span></span>
<span>(</span><span>id: str,<br>name: str,<br>description: str,<br>dialogue: dict[str, str] = &lt;factory&gt;,<br>hostile: bool = False,<br>health: int = 100,<br>gives_item: str | None = None,<br>required_flag: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class NPC:
    &#34;&#34;&#34;
    Represents a non-player character in the game.

    NPCs can provide dialogue, quests, information, and interact with the player
    in various ways. They can have multiple dialogue options and react to
    game state.

    Attributes:
        id: Unique identifier for the NPC.
        name: Display name of the NPC.
        description: Text description of the NPC&#39;s appearance.
        dialogue: Dictionary mapping dialogue keys to text responses.
        hostile: Whether the NPC is hostile to the player.
        health: NPC health points (for combat).
        gives_item: Optional item ID that the NPC gives to the player.
        required_flag: Optional game flag required to interact with this NPC.

    Examples:
        Create a friendly NPC:
        &gt;&gt;&gt; trader = NPC(
        ...     id=&#34;merchant&#34;,
        ...     name=&#34;Rogue Trader Jin&#34;,
        ...     description=&#34;A weathered trader in worn void armor.&#34;,
        ...     dialogue={
        ...         &#39;greeting&#39;: &#34;Looking to trade, stranger?&#34;,
        ...         &#39;help&#39;: &#34;I can offer you supplies... for a price.&#34;,
        ...         &#39;goodbye&#39;: &#34;Emperor protects, traveler.&#34;
        ...     }
        ... )

        Create a quest-giving NPC:
        &gt;&gt;&gt; survivor = NPC(
        ...     id=&#34;survivor_kane&#34;,
        ...     name=&#34;Guardsman Kane&#34;,
        ...     description=&#34;A wounded Imperial Guardsman.&#34;,
        ...     dialogue={
        ...         &#39;greeting&#39;: &#34;Thank the Emperor! You must warn the others!&#34;,
        ...         &#39;quest&#39;: &#34;There&#39;s a genestealer nest in the cargo hold!&#34;
        ...     },
        ...     gives_item=&#34;access_card&#34;
        ... )

        Create a hostile NPC:
        &gt;&gt;&gt; cultist = NPC(
        ...     id=&#34;chaos_cultist&#34;,
        ...     name=&#34;Chaos Cultist&#34;,
        ...     description=&#34;A twisted figure covered in profane symbols.&#34;,
        ...     hostile=True,
        ...     health=50
        ... )
    &#34;&#34;&#34;

    id: str
    name: str
    description: str
    dialogue: dict[str, str] = field(default_factory=dict)
    hostile: bool = False
    health: int = 100
    gives_item: Optional[str] = None
    required_flag: Optional[str] = None

    def __post_init__(self):
        &#34;&#34;&#34;Validate the NPC after initialization.&#34;&#34;&#34;
        if not self.id:
            raise ValueError(&#34;NPC id cannot be empty&#34;)
        if not self.name:
            raise ValueError(&#34;NPC name cannot be empty&#34;)
        if not self.description:
            raise ValueError(&#34;NPC description cannot be empty&#34;)
        if self.health &lt; 0:
            raise ValueError(&#34;NPC health cannot be negative&#34;)

    def can_interact(self, game_flags: dict[str, bool]) -&gt; bool:
        &#34;&#34;&#34;
        Check if the player can interact with this NPC.

        Args:
            game_flags: Dictionary of current game flags.

        Returns:
            True if interaction is possible, False otherwise.

        Examples:
            &gt;&gt;&gt; npc = NPC(id=&#34;guard&#34;, name=&#34;Guard&#34;, description=&#34;A guard.&#34;,
            ...           required_flag=&#34;guard_friendly&#34;)
            &gt;&gt;&gt; npc.can_interact({})
            False
            &gt;&gt;&gt; npc.can_interact({&#34;guard_friendly&#34;: True})
            True
        &#34;&#34;&#34;
        if self.required_flag:
            return game_flags.get(self.required_flag, False)
        return True

    def get_dialogue(self, key: str, default: str = &#34;...&#34;) -&gt; str:
        &#34;&#34;&#34;
        Get dialogue text for a specific key.

        Args:
            key: The dialogue key to retrieve.
            default: Default text if the key doesn&#39;t exist.

        Returns:
            The dialogue text.

        Examples:
            &gt;&gt;&gt; npc = NPC(id=&#34;test&#34;, name=&#34;Test&#34;, description=&#34;Test&#34;,
            ...           dialogue={&#34;hello&#34;: &#34;Greetings!&#34;})
            &gt;&gt;&gt; npc.get_dialogue(&#34;hello&#34;)
            &#39;Greetings!&#39;
            &gt;&gt;&gt; npc.get_dialogue(&#34;unknown&#34;)
            &#39;...&#39;
        &#34;&#34;&#34;
        return self.dialogue.get(key, default)

    def is_alive(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if the NPC is still alive.

        Returns:
            True if health &gt; 0, False otherwise.

        Examples:
            &gt;&gt;&gt; npc = NPC(id=&#34;test&#34;, name=&#34;Test&#34;, description=&#34;Test&#34;, health=50)
            &gt;&gt;&gt; npc.is_alive()
            True
            &gt;&gt;&gt; npc.health = 0
            &gt;&gt;&gt; npc.is_alive()
            False
        &#34;&#34;&#34;
        return self.health &gt; 0

    def to_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        Convert the NPC to a dictionary for serialization.

        Returns:
            Dictionary representation of the NPC.
        &#34;&#34;&#34;
        return {
            &#34;id&#34;: self.id,
            &#34;name&#34;: self.name,
            &#34;description&#34;: self.description,
            &#34;dialogue&#34;: self.dialogue,
            &#34;hostile&#34;: self.hostile,
            &#34;health&#34;: self.health,
            &#34;gives_item&#34;: self.gives_item,
            &#34;required_flag&#34;: self.required_flag,
        }

    @classmethod
    def from_dict(cls, data: dict) -&gt; &#34;NPC&#34;:
        &#34;&#34;&#34;
        Create an NPC from a dictionary.

        Args:
            data: Dictionary containing NPC data.

        Returns:
            A new NPC instance.
        &#34;&#34;&#34;
        return cls(
            id=data[&#34;id&#34;],
            name=data[&#34;name&#34;],
            description=data[&#34;description&#34;],
            dialogue=data.get(&#34;dialogue&#34;, {}),
            hostile=data.get(&#34;hostile&#34;, False),
            health=data.get(&#34;health&#34;, 100),
            gives_item=data.get(&#34;gives_item&#34;),
            required_flag=data.get(&#34;required_flag&#34;),
        )</code></pre>
</details>
<div class="desc"><p>Represents a non-player character in the game.</p>
<p>NPCs can provide dialogue, quests, information, and interact with the player
in various ways. They can have multiple dialogue options and react to
game state.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>Unique identifier for the NPC.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Display name of the NPC.</dd>
<dt><strong><code>description</code></strong></dt>
<dd>Text description of the NPC's appearance.</dd>
<dt><strong><code>dialogue</code></strong></dt>
<dd>Dictionary mapping dialogue keys to text responses.</dd>
<dt><strong><code>hostile</code></strong></dt>
<dd>Whether the NPC is hostile to the player.</dd>
<dt><strong><code>health</code></strong></dt>
<dd>NPC health points (for combat).</dd>
<dt><strong><code>gives_item</code></strong></dt>
<dd>Optional item ID that the NPC gives to the player.</dd>
<dt><strong><code>required_flag</code></strong></dt>
<dd>Optional game flag required to interact with this NPC.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Create a friendly NPC:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; trader = NPC(
...     id=&quot;merchant&quot;,
...     name=&quot;Rogue Trader Jin&quot;,
...     description=&quot;A weathered trader in worn void armor.&quot;,
...     dialogue={
...         'greeting': &quot;Looking to trade, stranger?&quot;,
...         'help': &quot;I can offer you supplies... for a price.&quot;,
...         'goodbye': &quot;Emperor protects, traveler.&quot;
...     }
... )
</code></pre>
<p>Create a quest-giving NPC:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; survivor = NPC(
...     id=&quot;survivor_kane&quot;,
...     name=&quot;Guardsman Kane&quot;,
...     description=&quot;A wounded Imperial Guardsman.&quot;,
...     dialogue={
...         'greeting': &quot;Thank the Emperor! You must warn the others!&quot;,
...         'quest': &quot;There's a genestealer nest in the cargo hold!&quot;
...     },
...     gives_item=&quot;access_card&quot;
... )
</code></pre>
<p>Create a hostile NPC:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; cultist = NPC(
...     id=&quot;chaos_cultist&quot;,
...     name=&quot;Chaos Cultist&quot;,
...     description=&quot;A twisted figure covered in profane symbols.&quot;,
...     hostile=True,
...     health=50
... )
</code></pre></div>
<h3>Static methods</h3>
<dl>
<dt id="space_hulk_game.engine.NPC.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict) ‑> <a title="space_hulk_game.engine.entities.NPC" href="entities.html#space_hulk_game.engine.entities.NPC">NPC</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create an NPC from a dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing NPC data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new NPC instance.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="space_hulk_game.engine.NPC.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.NPC.dialogue"><code class="name">var <span class="ident">dialogue</span> : dict[str, str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.NPC.gives_item"><code class="name">var <span class="ident">gives_item</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.NPC.health"><code class="name">var <span class="ident">health</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.NPC.hostile"><code class="name">var <span class="ident">hostile</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.NPC.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.NPC.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.NPC.required_flag"><code class="name">var <span class="ident">required_flag</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="space_hulk_game.engine.NPC.can_interact"><code class="name flex">
<span>def <span class="ident">can_interact</span></span>(<span>self, game_flags: dict[str, bool]) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def can_interact(self, game_flags: dict[str, bool]) -&gt; bool:
    &#34;&#34;&#34;
    Check if the player can interact with this NPC.

    Args:
        game_flags: Dictionary of current game flags.

    Returns:
        True if interaction is possible, False otherwise.

    Examples:
        &gt;&gt;&gt; npc = NPC(id=&#34;guard&#34;, name=&#34;Guard&#34;, description=&#34;A guard.&#34;,
        ...           required_flag=&#34;guard_friendly&#34;)
        &gt;&gt;&gt; npc.can_interact({})
        False
        &gt;&gt;&gt; npc.can_interact({&#34;guard_friendly&#34;: True})
        True
    &#34;&#34;&#34;
    if self.required_flag:
        return game_flags.get(self.required_flag, False)
    return True</code></pre>
</details>
<div class="desc"><p>Check if the player can interact with this NPC.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>game_flags</code></strong></dt>
<dd>Dictionary of current game flags.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if interaction is possible, False otherwise.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; npc = NPC(id=&quot;guard&quot;, name=&quot;Guard&quot;, description=&quot;A guard.&quot;,
...           required_flag=&quot;guard_friendly&quot;)
&gt;&gt;&gt; npc.can_interact({})
False
&gt;&gt;&gt; npc.can_interact({&quot;guard_friendly&quot;: True})
True
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.NPC.get_dialogue"><code class="name flex">
<span>def <span class="ident">get_dialogue</span></span>(<span>self, key: str, default: str = '...') ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dialogue(self, key: str, default: str = &#34;...&#34;) -&gt; str:
    &#34;&#34;&#34;
    Get dialogue text for a specific key.

    Args:
        key: The dialogue key to retrieve.
        default: Default text if the key doesn&#39;t exist.

    Returns:
        The dialogue text.

    Examples:
        &gt;&gt;&gt; npc = NPC(id=&#34;test&#34;, name=&#34;Test&#34;, description=&#34;Test&#34;,
        ...           dialogue={&#34;hello&#34;: &#34;Greetings!&#34;})
        &gt;&gt;&gt; npc.get_dialogue(&#34;hello&#34;)
        &#39;Greetings!&#39;
        &gt;&gt;&gt; npc.get_dialogue(&#34;unknown&#34;)
        &#39;...&#39;
    &#34;&#34;&#34;
    return self.dialogue.get(key, default)</code></pre>
</details>
<div class="desc"><p>Get dialogue text for a specific key.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>The dialogue key to retrieve.</dd>
<dt><strong><code>default</code></strong></dt>
<dd>Default text if the key doesn't exist.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The dialogue text.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; npc = NPC(id=&quot;test&quot;, name=&quot;Test&quot;, description=&quot;Test&quot;,
...           dialogue={&quot;hello&quot;: &quot;Greetings!&quot;})
&gt;&gt;&gt; npc.get_dialogue(&quot;hello&quot;)
'Greetings!'
&gt;&gt;&gt; npc.get_dialogue(&quot;unknown&quot;)
'...'
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.NPC.is_alive"><code class="name flex">
<span>def <span class="ident">is_alive</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_alive(self) -&gt; bool:
    &#34;&#34;&#34;
    Check if the NPC is still alive.

    Returns:
        True if health &gt; 0, False otherwise.

    Examples:
        &gt;&gt;&gt; npc = NPC(id=&#34;test&#34;, name=&#34;Test&#34;, description=&#34;Test&#34;, health=50)
        &gt;&gt;&gt; npc.is_alive()
        True
        &gt;&gt;&gt; npc.health = 0
        &gt;&gt;&gt; npc.is_alive()
        False
    &#34;&#34;&#34;
    return self.health &gt; 0</code></pre>
</details>
<div class="desc"><p>Check if the NPC is still alive.</p>
<h2 id="returns">Returns</h2>
<p>True if health &gt; 0, False otherwise.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; npc = NPC(id=&quot;test&quot;, name=&quot;Test&quot;, description=&quot;Test&quot;, health=50)
&gt;&gt;&gt; npc.is_alive()
True
&gt;&gt;&gt; npc.health = 0
&gt;&gt;&gt; npc.is_alive()
False
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.NPC.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict:
    &#34;&#34;&#34;
    Convert the NPC to a dictionary for serialization.

    Returns:
        Dictionary representation of the NPC.
    &#34;&#34;&#34;
    return {
        &#34;id&#34;: self.id,
        &#34;name&#34;: self.name,
        &#34;description&#34;: self.description,
        &#34;dialogue&#34;: self.dialogue,
        &#34;hostile&#34;: self.hostile,
        &#34;health&#34;: self.health,
        &#34;gives_item&#34;: self.gives_item,
        &#34;required_flag&#34;: self.required_flag,
    }</code></pre>
</details>
<div class="desc"><p>Convert the NPC to a dictionary for serialization.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary representation of the NPC.</p></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.engine.PersistenceError"><code class="flex name class">
<span>class <span class="ident">PersistenceError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PersistenceError(Exception):
    &#34;&#34;&#34;Exception raised for errors during save/load operations.&#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>Exception raised for errors during save/load operations.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="space_hulk_game.engine.SaveSystem"><code class="flex name class">
<span>class <span class="ident">SaveSystem</span></span>
<span>(</span><span>save_dir: str = 'saves')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SaveSystem:
    &#34;&#34;&#34;
    High-level save/load system with simplified interface.

    This class provides an object-oriented interface to the persistence
    functions, managing save directory and file naming conventions.

    Attributes:
        save_dir: Directory where save files are stored.

    Examples:
        Create a save system:
        &gt;&gt;&gt; save_system = SaveSystem(&#34;saves/&#34;)
        &gt;&gt;&gt; save_system.save(game_state, &#34;mysave&#34;)
        &gt;&gt;&gt; loaded_state = save_system.load(&#34;mysave&#34;)
        &gt;&gt;&gt; saves = save_system.list_saves()
    &#34;&#34;&#34;

    def __init__(self, save_dir: str = &#34;saves&#34;):
        &#34;&#34;&#34;
        Initialize the save system.

        Args:
            save_dir: Directory for save files (created if it doesn&#39;t exist).
        &#34;&#34;&#34;
        self.save_dir = Path(save_dir)
        self.save_dir.mkdir(parents=True, exist_ok=True)
        logger.info(f&#34;SaveSystem initialized (save_dir={self.save_dir})&#34;)

    def save(
        self,
        game_state: GameState,
        save_name: str,
        scenes: dict[str, Scene] = None,
        metadata: dict[str, Any] = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Save a game state.

        Args:
            game_state: Game state to save.
            save_name: Name for the save (without .json extension).
            scenes: Optional scenes dict (not needed for state-only saves).
            metadata: Optional metadata to include.

        Raises:
            PersistenceError: If save fails.
        &#34;&#34;&#34;
        # Add .json extension if not present
        if not save_name.endswith(&#34;.json&#34;):
            save_name = f&#34;{save_name}.json&#34;

        filepath = self.save_dir / save_name

        # For simplified saves, we only save the game state
        # Scenes will be loaded from the original game files
        save_data = {
            &#34;version&#34;: &#34;1.0&#34;,
            &#34;timestamp&#34;: datetime.now().isoformat(),
            &#34;metadata&#34;: metadata or {},
            &#34;game_state&#34;: game_state.to_dict(),
        }

        # If scenes provided, save them too (for compatibility)
        if scenes:
            save_data[&#34;scenes&#34;] = {scene_id: scene.to_dict() for scene_id, scene in scenes.items()}

        try:
            with open(filepath, &#34;w&#34;, encoding=&#34;utf-8&#34;) as f:
                json.dump(save_data, f, indent=2, ensure_ascii=False)

            logger.info(f&#34;Game saved to: {filepath}&#34;)

        except Exception as e:
            error_msg = f&#34;Failed to save game: {e}&#34;
            logger.error(error_msg)
            raise PersistenceError(error_msg) from e

    def load(self, save_name: str) -&gt; GameState:
        &#34;&#34;&#34;
        Load a game state.

        Args:
            save_name: Name of the save to load (with or without .json).

        Returns:
            Loaded game state.

        Raises:
            PersistenceError: If load fails.
        &#34;&#34;&#34;
        # Add .json extension if not present
        if not save_name.endswith(&#34;.json&#34;):
            save_name = f&#34;{save_name}.json&#34;

        filepath = self.save_dir / save_name

        try:
            with open(filepath, encoding=&#34;utf-8&#34;) as f:
                save_data = json.load(f)

            # Validate basic structure
            if &#34;game_state&#34; not in save_data:
                raise PersistenceError(&#34;Invalid save file: missing game_state&#34;)

            # Deserialize game state
            game_state = GameState.from_dict(save_data[&#34;game_state&#34;])

            logger.info(f&#34;Game loaded from: {filepath}&#34;)
            return game_state

        except FileNotFoundError:
            raise PersistenceError(f&#34;Save file not found: {save_name}&#34;)
        except Exception as e:
            error_msg = f&#34;Failed to load game: {e}&#34;
            logger.error(error_msg)
            raise PersistenceError(error_msg) from e

    def list_saves(self) -&gt; list:
        &#34;&#34;&#34;
        List all available save files.

        Returns:
            List of save names (without .json extension).
        &#34;&#34;&#34;
        try:
            save_files = []
            for file_path in self.save_dir.glob(&#34;*.json&#34;):
                # Return just the stem (filename without extension)
                save_files.append((file_path.stem, file_path.stat().st_mtime))

            # Sort by modification time (newest first)
            save_files.sort(key=lambda x: x[1], reverse=True)

            return [f[0] for f in save_files]

        except Exception as e:
            logger.error(f&#34;Failed to list save files: {e}&#34;)
            return []

    def delete(self, save_name: str) -&gt; None:
        &#34;&#34;&#34;
        Delete a save file.

        Args:
            save_name: Name of the save to delete (with or without .json).

        Raises:
            PersistenceError: If deletion fails.
        &#34;&#34;&#34;
        # Add .json extension if not present
        if not save_name.endswith(&#34;.json&#34;):
            save_name = f&#34;{save_name}.json&#34;

        filepath = self.save_dir / save_name
        delete_save(str(filepath))

    def get_metadata(self, save_name: str) -&gt; dict[str, Any]:
        &#34;&#34;&#34;
        Get metadata for a save file.

        Args:
            save_name: Name of the save (with or without .json).

        Returns:
            Dictionary of metadata.

        Raises:
            PersistenceError: If reading metadata fails.
        &#34;&#34;&#34;
        # Add .json extension if not present
        if not save_name.endswith(&#34;.json&#34;):
            save_name = f&#34;{save_name}.json&#34;

        filepath = self.save_dir / save_name
        return get_save_metadata(str(filepath))</code></pre>
</details>
<div class="desc"><p>High-level save/load system with simplified interface.</p>
<p>This class provides an object-oriented interface to the persistence
functions, managing save directory and file naming conventions.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>save_dir</code></strong></dt>
<dd>Directory where save files are stored.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Create a save system:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; save_system = SaveSystem(&quot;saves/&quot;)
&gt;&gt;&gt; save_system.save(game_state, &quot;mysave&quot;)
&gt;&gt;&gt; loaded_state = save_system.load(&quot;mysave&quot;)
&gt;&gt;&gt; saves = save_system.list_saves()
</code></pre>
<p>Initialize the save system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>save_dir</code></strong></dt>
<dd>Directory for save files (created if it doesn't exist).</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="space_hulk_game.engine.SaveSystem.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, save_name: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, save_name: str) -&gt; None:
    &#34;&#34;&#34;
    Delete a save file.

    Args:
        save_name: Name of the save to delete (with or without .json).

    Raises:
        PersistenceError: If deletion fails.
    &#34;&#34;&#34;
    # Add .json extension if not present
    if not save_name.endswith(&#34;.json&#34;):
        save_name = f&#34;{save_name}.json&#34;

    filepath = self.save_dir / save_name
    delete_save(str(filepath))</code></pre>
</details>
<div class="desc"><p>Delete a save file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>save_name</code></strong></dt>
<dd>Name of the save to delete (with or without .json).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="space_hulk_game.engine.PersistenceError" href="#space_hulk_game.engine.PersistenceError">PersistenceError</a></code></dt>
<dd>If deletion fails.</dd>
</dl></div>
</dd>
<dt id="space_hulk_game.engine.SaveSystem.get_metadata"><code class="name flex">
<span>def <span class="ident">get_metadata</span></span>(<span>self, save_name: str) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metadata(self, save_name: str) -&gt; dict[str, Any]:
    &#34;&#34;&#34;
    Get metadata for a save file.

    Args:
        save_name: Name of the save (with or without .json).

    Returns:
        Dictionary of metadata.

    Raises:
        PersistenceError: If reading metadata fails.
    &#34;&#34;&#34;
    # Add .json extension if not present
    if not save_name.endswith(&#34;.json&#34;):
        save_name = f&#34;{save_name}.json&#34;

    filepath = self.save_dir / save_name
    return get_save_metadata(str(filepath))</code></pre>
</details>
<div class="desc"><p>Get metadata for a save file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>save_name</code></strong></dt>
<dd>Name of the save (with or without .json).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dictionary of metadata.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="space_hulk_game.engine.PersistenceError" href="#space_hulk_game.engine.PersistenceError">PersistenceError</a></code></dt>
<dd>If reading metadata fails.</dd>
</dl></div>
</dd>
<dt id="space_hulk_game.engine.SaveSystem.list_saves"><code class="name flex">
<span>def <span class="ident">list_saves</span></span>(<span>self) ‑> list</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_saves(self) -&gt; list:
    &#34;&#34;&#34;
    List all available save files.

    Returns:
        List of save names (without .json extension).
    &#34;&#34;&#34;
    try:
        save_files = []
        for file_path in self.save_dir.glob(&#34;*.json&#34;):
            # Return just the stem (filename without extension)
            save_files.append((file_path.stem, file_path.stat().st_mtime))

        # Sort by modification time (newest first)
        save_files.sort(key=lambda x: x[1], reverse=True)

        return [f[0] for f in save_files]

    except Exception as e:
        logger.error(f&#34;Failed to list save files: {e}&#34;)
        return []</code></pre>
</details>
<div class="desc"><p>List all available save files.</p>
<h2 id="returns">Returns</h2>
<p>List of save names (without .json extension).</p></div>
</dd>
<dt id="space_hulk_game.engine.SaveSystem.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, save_name: str) ‑> <a title="space_hulk_game.engine.game_state.GameState" href="game_state.html#space_hulk_game.engine.game_state.GameState">GameState</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self, save_name: str) -&gt; GameState:
    &#34;&#34;&#34;
    Load a game state.

    Args:
        save_name: Name of the save to load (with or without .json).

    Returns:
        Loaded game state.

    Raises:
        PersistenceError: If load fails.
    &#34;&#34;&#34;
    # Add .json extension if not present
    if not save_name.endswith(&#34;.json&#34;):
        save_name = f&#34;{save_name}.json&#34;

    filepath = self.save_dir / save_name

    try:
        with open(filepath, encoding=&#34;utf-8&#34;) as f:
            save_data = json.load(f)

        # Validate basic structure
        if &#34;game_state&#34; not in save_data:
            raise PersistenceError(&#34;Invalid save file: missing game_state&#34;)

        # Deserialize game state
        game_state = GameState.from_dict(save_data[&#34;game_state&#34;])

        logger.info(f&#34;Game loaded from: {filepath}&#34;)
        return game_state

    except FileNotFoundError:
        raise PersistenceError(f&#34;Save file not found: {save_name}&#34;)
    except Exception as e:
        error_msg = f&#34;Failed to load game: {e}&#34;
        logger.error(error_msg)
        raise PersistenceError(error_msg) from e</code></pre>
</details>
<div class="desc"><p>Load a game state.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>save_name</code></strong></dt>
<dd>Name of the save to load (with or without .json).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Loaded game state.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="space_hulk_game.engine.PersistenceError" href="#space_hulk_game.engine.PersistenceError">PersistenceError</a></code></dt>
<dd>If load fails.</dd>
</dl></div>
</dd>
<dt id="space_hulk_game.engine.SaveSystem.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self,<br>game_state: <a title="space_hulk_game.engine.game_state.GameState" href="game_state.html#space_hulk_game.engine.game_state.GameState">GameState</a>,<br>save_name: str,<br>scenes: dict[str, <a title="space_hulk_game.engine.scene.Scene" href="scene.html#space_hulk_game.engine.scene.Scene">Scene</a>] = None,<br>metadata: dict[str, typing.Any] = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(
    self,
    game_state: GameState,
    save_name: str,
    scenes: dict[str, Scene] = None,
    metadata: dict[str, Any] = None,
) -&gt; None:
    &#34;&#34;&#34;
    Save a game state.

    Args:
        game_state: Game state to save.
        save_name: Name for the save (without .json extension).
        scenes: Optional scenes dict (not needed for state-only saves).
        metadata: Optional metadata to include.

    Raises:
        PersistenceError: If save fails.
    &#34;&#34;&#34;
    # Add .json extension if not present
    if not save_name.endswith(&#34;.json&#34;):
        save_name = f&#34;{save_name}.json&#34;

    filepath = self.save_dir / save_name

    # For simplified saves, we only save the game state
    # Scenes will be loaded from the original game files
    save_data = {
        &#34;version&#34;: &#34;1.0&#34;,
        &#34;timestamp&#34;: datetime.now().isoformat(),
        &#34;metadata&#34;: metadata or {},
        &#34;game_state&#34;: game_state.to_dict(),
    }

    # If scenes provided, save them too (for compatibility)
    if scenes:
        save_data[&#34;scenes&#34;] = {scene_id: scene.to_dict() for scene_id, scene in scenes.items()}

    try:
        with open(filepath, &#34;w&#34;, encoding=&#34;utf-8&#34;) as f:
            json.dump(save_data, f, indent=2, ensure_ascii=False)

        logger.info(f&#34;Game saved to: {filepath}&#34;)

    except Exception as e:
        error_msg = f&#34;Failed to save game: {e}&#34;
        logger.error(error_msg)
        raise PersistenceError(error_msg) from e</code></pre>
</details>
<div class="desc"><p>Save a game state.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>game_state</code></strong></dt>
<dd>Game state to save.</dd>
<dt><strong><code>save_name</code></strong></dt>
<dd>Name for the save (without .json extension).</dd>
<dt><strong><code>scenes</code></strong></dt>
<dd>Optional scenes dict (not needed for state-only saves).</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Optional metadata to include.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="space_hulk_game.engine.PersistenceError" href="#space_hulk_game.engine.PersistenceError">PersistenceError</a></code></dt>
<dd>If save fails.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.engine.Scene"><code class="flex name class">
<span>class <span class="ident">Scene</span></span>
<span>(</span><span>id: str,<br>name: str,<br>description: str,<br>exits: dict[str, str] = &lt;factory&gt;,<br>items: list[<a title="space_hulk_game.engine.entities.Item" href="entities.html#space_hulk_game.engine.entities.Item">Item</a>] = &lt;factory&gt;,<br>npcs: list[<a title="space_hulk_game.engine.entities.NPC" href="entities.html#space_hulk_game.engine.entities.NPC">NPC</a>] = &lt;factory&gt;,<br>events: list[<a title="space_hulk_game.engine.entities.Event" href="entities.html#space_hulk_game.engine.entities.Event">Event</a>] = &lt;factory&gt;,<br>visited: bool = False,<br>dark: bool = False,<br>locked_exits: dict[str, str] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Scene:
    &#34;&#34;&#34;
    Represents a location/room in the game world.

    Scenes are the primary spatial units in the game. Each scene has a description,
    connections to other scenes (exits), and can contain items, NPCs, and events.
    Players navigate between scenes to progress through the story.

    Attributes:
        id: Unique identifier for the scene.
        name: Display name of the scene.
        description: Detailed text description of the scene.
        exits: Dictionary mapping direction names to scene IDs
              (e.g., {&#34;north&#34;: &#34;corridor_1&#34;, &#34;east&#34;: &#34;airlock&#34;}).
        items: List of Item objects present in this scene.
        npcs: List of NPC objects present in this scene.
        events: List of Event objects that can trigger in this scene.
        visited: Whether the player has visited this scene before.
        dark: Whether the scene is dark (requires light source).
        locked_exits: Dictionary of locked exits requiring items or flags
                     (e.g., {&#34;north&#34;: &#34;brass_key&#34;}).

    Examples:
        Create a simple scene:
        &gt;&gt;&gt; entrance = Scene(
        ...     id=&#34;entrance_hall&#34;,
        ...     name=&#34;Entrance Hall&#34;,
        ...     description=&#34;A grand hall with vaulted ceilings.&#34;,
        ...     exits={&#34;north&#34;: &#34;main_corridor&#34;, &#34;south&#34;: &#34;exterior&#34;}
        ... )

        Create a scene with items and NPCs:
        &gt;&gt;&gt; from space_hulk_game.engine import Item, NPC
        &gt;&gt;&gt; medkit = Item(id=&#34;medkit&#34;, name=&#34;Medkit&#34;, description=&#34;A medkit.&#34;)
        &gt;&gt;&gt; guard = NPC(id=&#34;guard&#34;, name=&#34;Guard&#34;, description=&#34;A guard.&#34;)
        &gt;&gt;&gt; armory = Scene(
        ...     id=&#34;armory&#34;,
        ...     name=&#34;Armory&#34;,
        ...     description=&#34;Weapons line the walls.&#34;,
        ...     exits={&#34;west&#34;: &#34;corridor&#34;},
        ...     items=[medkit],
        ...     npcs=[guard]
        ... )

        Create a scene with locked exits:
        &gt;&gt;&gt; vault = Scene(
        ...     id=&#34;vault&#34;,
        ...     name=&#34;Secure Vault&#34;,
        ...     description=&#34;A heavily secured vault.&#34;,
        ...     exits={&#34;north&#34;: &#34;corridor&#34;, &#34;vault_door&#34;: &#34;treasure_room&#34;},
        ...     locked_exits={&#34;vault_door&#34;: &#34;vault_key&#34;}
        ... )

        Create a dark scene:
        &gt;&gt;&gt; dark_corridor = Scene(
        ...     id=&#34;dark_corridor&#34;,
        ...     name=&#34;Dark Corridor&#34;,
        ...     description=&#34;A pitch-black corridor.&#34;,
        ...     exits={&#34;east&#34;: &#34;light_room&#34;, &#34;west&#34;: &#34;another_room&#34;},
        ...     dark=True
        ... )
    &#34;&#34;&#34;

    id: str
    name: str
    description: str
    exits: dict[str, str] = field(default_factory=dict)
    items: list[Item] = field(default_factory=list)
    npcs: list[NPC] = field(default_factory=list)
    events: list[Event] = field(default_factory=list)
    visited: bool = False
    dark: bool = False
    locked_exits: dict[str, str] = field(default_factory=dict)

    def __post_init__(self):
        &#34;&#34;&#34;Validate the scene after initialization.&#34;&#34;&#34;
        if not self.id:
            raise ValueError(&#34;Scene id cannot be empty&#34;)
        if not self.name:
            raise ValueError(&#34;Scene name cannot be empty&#34;)
        if not self.description:
            raise ValueError(&#34;Scene description cannot be empty&#34;)

    def get_full_description(self) -&gt; str:
        &#34;&#34;&#34;
        Get the complete description of the scene, including items and NPCs.

        Returns:
            A formatted string describing the scene and its contents.

        Examples:
            &gt;&gt;&gt; item = Item(id=&#34;key&#34;, name=&#34;Brass Key&#34;, description=&#34;A key.&#34;)
            &gt;&gt;&gt; scene = Scene(
            ...     id=&#34;room&#34;,
            ...     name=&#34;Test Room&#34;,
            ...     description=&#34;A test room.&#34;,
            ...     items=[item]
            ... )
            &gt;&gt;&gt; desc = scene.get_full_description()
            &gt;&gt;&gt; &#34;Brass Key&#34; in desc
            True
        &#34;&#34;&#34;
        parts = [self.description]

        if self.items:
            item_names = [item.name for item in self.items]
            parts.append(f&#34;\n\nYou see: {&#39;, &#39;.join(item_names)}.&#34;)

        if self.npcs:
            npc_descriptions = [npc.description for npc in self.npcs]
            parts.append(f&#34;\n\n{&#39; &#39;.join(npc_descriptions)}&#34;)

        return &#34;&#34;.join(parts)

    def get_exit_description(self) -&gt; str:
        &#34;&#34;&#34;
        Get a description of available exits.

        Returns:
            A formatted string describing available exits.

        Examples:
            &gt;&gt;&gt; scene = Scene(
            ...     id=&#34;room&#34;,
            ...     name=&#34;Room&#34;,
            ...     description=&#34;A room.&#34;,
            ...     exits={&#34;north&#34;: &#34;hallway&#34;, &#34;east&#34;: &#34;closet&#34;}
            ... )
            &gt;&gt;&gt; desc = scene.get_exit_description()
            &gt;&gt;&gt; &#34;north&#34; in desc and &#34;east&#34; in desc
            True
        &#34;&#34;&#34;
        if not self.exits:
            return &#34;There are no obvious exits.&#34;

        exit_names = list(self.exits.keys())
        if len(exit_names) == 1:
            return f&#34;There is an exit to the {exit_names[0]}.&#34;
        else:
            exits_str = &#34;, &#34;.join(exit_names[:-1]) + f&#34; and {exit_names[-1]}&#34;
            return f&#34;There are exits to the {exits_str}.&#34;

    def can_exit(
        self, direction: str, inventory: list[str], game_flags: dict[str, bool]
    ) -&gt; tuple[bool, Optional[str]]:
        &#34;&#34;&#34;
        Check if the player can use a specific exit.

        Args:
            direction: The direction/exit name to check.
            inventory: Player&#39;s current inventory.
            game_flags: Current game flags.

        Returns:
            A tuple of (can_exit: bool, reason: Optional[str]).
            If can_exit is False, reason contains an explanation.

        Examples:
            &gt;&gt;&gt; scene = Scene(
            ...     id=&#34;room&#34;,
            ...     name=&#34;Room&#34;,
            ...     description=&#34;A room.&#34;,
            ...     exits={&#34;north&#34;: &#34;hallway&#34;},
            ...     locked_exits={&#34;north&#34;: &#34;key&#34;}
            ... )
            &gt;&gt;&gt; scene.can_exit(&#34;north&#34;, [], {})
            (False, &#39;The exit to the north is locked. You need: key&#39;)
            &gt;&gt;&gt; scene.can_exit(&#34;north&#34;, [&#34;key&#34;], {})
            (True, None)
            &gt;&gt;&gt; scene.can_exit(&#34;south&#34;, [&#34;key&#34;], {})
            (False, &#39;There is no exit in that direction.&#39;)
        &#34;&#34;&#34;
        if direction not in self.exits:
            return False, &#34;There is no exit in that direction.&#34;

        if direction in self.locked_exits:
            required = self.locked_exits[direction]

            # Check if it&#39;s an item requirement
            if required in inventory:
                return True, None

            # Check if it&#39;s a flag requirement
            if game_flags.get(required, False):
                return True, None

            return False, f&#34;The exit to the {direction} is locked. You need: {required}&#34;

        return True, None

    def get_item(self, item_id: str) -&gt; Optional[Item]:
        &#34;&#34;&#34;
        Get an item from the scene by ID.

        Args:
            item_id: The ID of the item to retrieve.

        Returns:
            The Item object if found, None otherwise.

        Examples:
            &gt;&gt;&gt; item = Item(id=&#34;key&#34;, name=&#34;Key&#34;, description=&#34;A key.&#34;)
            &gt;&gt;&gt; scene = Scene(
            ...     id=&#34;room&#34;,
            ...     name=&#34;Room&#34;,
            ...     description=&#34;A room.&#34;,
            ...     items=[item]
            ... )
            &gt;&gt;&gt; found = scene.get_item(&#34;key&#34;)
            &gt;&gt;&gt; found.name
            &#39;Key&#39;
            &gt;&gt;&gt; scene.get_item(&#34;missing&#34;)
        &#34;&#34;&#34;
        for item in self.items:
            if item.id == item_id:
                return item
        return None

    def remove_item(self, item_id: str) -&gt; bool:
        &#34;&#34;&#34;
        Remove an item from the scene.

        Args:
            item_id: The ID of the item to remove.

        Returns:
            True if the item was removed, False if not found.

        Examples:
            &gt;&gt;&gt; item = Item(id=&#34;key&#34;, name=&#34;Key&#34;, description=&#34;A key.&#34;)
            &gt;&gt;&gt; scene = Scene(
            ...     id=&#34;room&#34;,
            ...     name=&#34;Room&#34;,
            ...     description=&#34;A room.&#34;,
            ...     items=[item]
            ... )
            &gt;&gt;&gt; scene.remove_item(&#34;key&#34;)
            True
            &gt;&gt;&gt; len(scene.items)
            0
            &gt;&gt;&gt; scene.remove_item(&#34;key&#34;)
            False
        &#34;&#34;&#34;
        for i, item in enumerate(self.items):
            if item.id == item_id:
                self.items.pop(i)
                return True
        return False

    def add_item(self, item: Item) -&gt; None:
        &#34;&#34;&#34;
        Add an item to the scene.

        Args:
            item: The Item object to add.

        Examples:
            &gt;&gt;&gt; item = Item(id=&#34;key&#34;, name=&#34;Key&#34;, description=&#34;A key.&#34;)
            &gt;&gt;&gt; scene = Scene(id=&#34;room&#34;, name=&#34;Room&#34;, description=&#34;A room.&#34;)
            &gt;&gt;&gt; scene.add_item(item)
            &gt;&gt;&gt; len(scene.items)
            1
        &#34;&#34;&#34;
        self.items.append(item)

    def get_npc(self, npc_id: str) -&gt; Optional[NPC]:
        &#34;&#34;&#34;
        Get an NPC from the scene by ID.

        Args:
            npc_id: The ID of the NPC to retrieve.

        Returns:
            The NPC object if found, None otherwise.

        Examples:
            &gt;&gt;&gt; npc = NPC(id=&#34;guard&#34;, name=&#34;Guard&#34;, description=&#34;A guard.&#34;)
            &gt;&gt;&gt; scene = Scene(
            ...     id=&#34;room&#34;,
            ...     name=&#34;Room&#34;,
            ...     description=&#34;A room.&#34;,
            ...     npcs=[npc]
            ... )
            &gt;&gt;&gt; found = scene.get_npc(&#34;guard&#34;)
            &gt;&gt;&gt; found.name
            &#39;Guard&#39;
        &#34;&#34;&#34;
        for npc in self.npcs:
            if npc.id == npc_id:
                return npc
        return None

    def get_entry_events(self, game_flags: dict[str, bool]) -&gt; list[Event]:
        &#34;&#34;&#34;
        Get all events that should trigger when entering this scene.

        Args:
            game_flags: Current game flags.

        Returns:
            List of Event objects that can trigger.

        Examples:
            &gt;&gt;&gt; event = Event(
            ...     id=&#34;ambush&#34;,
            ...     description=&#34;An ambush!&#34;,
            ...     trigger_on_entry=True
            ... )
            &gt;&gt;&gt; scene = Scene(
            ...     id=&#34;room&#34;,
            ...     name=&#34;Room&#34;,
            ...     description=&#34;A room.&#34;,
            ...     events=[event]
            ... )
            &gt;&gt;&gt; events = scene.get_entry_events({})
            &gt;&gt;&gt; len(events)
            1
        &#34;&#34;&#34;
        return [
            event
            for event in self.events
            if event.trigger_on_entry and event.can_trigger(game_flags)
        ]

    def unlock_exit(self, direction: str) -&gt; bool:
        &#34;&#34;&#34;
        Unlock an exit, making it passable.

        Args:
            direction: The direction/exit to unlock.

        Returns:
            True if the exit was unlocked, False if it wasn&#39;t locked.

        Examples:
            &gt;&gt;&gt; scene = Scene(
            ...     id=&#34;room&#34;,
            ...     name=&#34;Room&#34;,
            ...     description=&#34;A room.&#34;,
            ...     exits={&#34;north&#34;: &#34;hallway&#34;},
            ...     locked_exits={&#34;north&#34;: &#34;key&#34;}
            ... )
            &gt;&gt;&gt; scene.unlock_exit(&#34;north&#34;)
            True
            &gt;&gt;&gt; &#34;north&#34; in scene.locked_exits
            False
        &#34;&#34;&#34;
        if direction in self.locked_exits:
            del self.locked_exits[direction]
            return True
        return False

    def to_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        Convert the scene to a dictionary for serialization.

        Returns:
            Dictionary representation of the scene.
        &#34;&#34;&#34;
        return {
            &#34;id&#34;: self.id,
            &#34;name&#34;: self.name,
            &#34;description&#34;: self.description,
            &#34;exits&#34;: self.exits,
            &#34;items&#34;: [item.to_dict() for item in self.items],
            &#34;npcs&#34;: [npc.to_dict() for npc in self.npcs],
            &#34;events&#34;: [event.to_dict() for event in self.events],
            &#34;visited&#34;: self.visited,
            &#34;dark&#34;: self.dark,
            &#34;locked_exits&#34;: self.locked_exits,
        }

    @classmethod
    def from_dict(cls, data: dict) -&gt; &#34;Scene&#34;:
        &#34;&#34;&#34;
        Create a Scene from a dictionary.

        Args:
            data: Dictionary containing scene data.

        Returns:
            A new Scene instance.
        &#34;&#34;&#34;
        scene = cls(
            id=data[&#34;id&#34;],
            name=data[&#34;name&#34;],
            description=data[&#34;description&#34;],
            exits=data.get(&#34;exits&#34;, {}),
            items=[Item.from_dict(item_data) for item_data in data.get(&#34;items&#34;, [])],
            npcs=[NPC.from_dict(npc_data) for npc_data in data.get(&#34;npcs&#34;, [])],
            events=[Event.from_dict(event_data) for event_data in data.get(&#34;events&#34;, [])],
            dark=data.get(&#34;dark&#34;, False),
            locked_exits=data.get(&#34;locked_exits&#34;, {}),
        )
        scene.visited = data.get(&#34;visited&#34;, False)
        return scene</code></pre>
</details>
<div class="desc"><p>Represents a location/room in the game world.</p>
<p>Scenes are the primary spatial units in the game. Each scene has a description,
connections to other scenes (exits), and can contain items, NPCs, and events.
Players navigate between scenes to progress through the story.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>Unique identifier for the scene.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Display name of the scene.</dd>
<dt><strong><code>description</code></strong></dt>
<dd>Detailed text description of the scene.</dd>
<dt><strong><code>exits</code></strong></dt>
<dd>Dictionary mapping direction names to scene IDs
(e.g., {"north": "corridor_1", "east": "airlock"}).</dd>
<dt><strong><code>items</code></strong></dt>
<dd>List of Item objects present in this scene.</dd>
<dt><strong><code>npcs</code></strong></dt>
<dd>List of NPC objects present in this scene.</dd>
<dt><strong><code>events</code></strong></dt>
<dd>List of Event objects that can trigger in this scene.</dd>
<dt><strong><code>visited</code></strong></dt>
<dd>Whether the player has visited this scene before.</dd>
<dt><strong><code>dark</code></strong></dt>
<dd>Whether the scene is dark (requires light source).</dd>
<dt><strong><code>locked_exits</code></strong></dt>
<dd>Dictionary of locked exits requiring items or flags
(e.g., {"north": "brass_key"}).</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Create a simple scene:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; entrance = Scene(
...     id=&quot;entrance_hall&quot;,
...     name=&quot;Entrance Hall&quot;,
...     description=&quot;A grand hall with vaulted ceilings.&quot;,
...     exits={&quot;north&quot;: &quot;main_corridor&quot;, &quot;south&quot;: &quot;exterior&quot;}
... )
</code></pre>
<p>Create a scene with items and NPCs:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from space_hulk_game.engine import Item, NPC
&gt;&gt;&gt; medkit = Item(id=&quot;medkit&quot;, name=&quot;Medkit&quot;, description=&quot;A medkit.&quot;)
&gt;&gt;&gt; guard = NPC(id=&quot;guard&quot;, name=&quot;Guard&quot;, description=&quot;A guard.&quot;)
&gt;&gt;&gt; armory = Scene(
...     id=&quot;armory&quot;,
...     name=&quot;Armory&quot;,
...     description=&quot;Weapons line the walls.&quot;,
...     exits={&quot;west&quot;: &quot;corridor&quot;},
...     items=[medkit],
...     npcs=[guard]
... )
</code></pre>
<p>Create a scene with locked exits:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; vault = Scene(
...     id=&quot;vault&quot;,
...     name=&quot;Secure Vault&quot;,
...     description=&quot;A heavily secured vault.&quot;,
...     exits={&quot;north&quot;: &quot;corridor&quot;, &quot;vault_door&quot;: &quot;treasure_room&quot;},
...     locked_exits={&quot;vault_door&quot;: &quot;vault_key&quot;}
... )
</code></pre>
<p>Create a dark scene:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; dark_corridor = Scene(
...     id=&quot;dark_corridor&quot;,
...     name=&quot;Dark Corridor&quot;,
...     description=&quot;A pitch-black corridor.&quot;,
...     exits={&quot;east&quot;: &quot;light_room&quot;, &quot;west&quot;: &quot;another_room&quot;},
...     dark=True
... )
</code></pre></div>
<h3>Static methods</h3>
<dl>
<dt id="space_hulk_game.engine.Scene.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict) ‑> <a title="space_hulk_game.engine.scene.Scene" href="scene.html#space_hulk_game.engine.scene.Scene">Scene</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a Scene from a dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing scene data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new Scene instance.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="space_hulk_game.engine.Scene.dark"><code class="name">var <span class="ident">dark</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Scene.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Scene.events"><code class="name">var <span class="ident">events</span> : list[<a title="space_hulk_game.engine.entities.Event" href="entities.html#space_hulk_game.engine.entities.Event">Event</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Scene.exits"><code class="name">var <span class="ident">exits</span> : dict[str, str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Scene.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Scene.items"><code class="name">var <span class="ident">items</span> : list[<a title="space_hulk_game.engine.entities.Item" href="entities.html#space_hulk_game.engine.entities.Item">Item</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Scene.locked_exits"><code class="name">var <span class="ident">locked_exits</span> : dict[str, str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Scene.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Scene.npcs"><code class="name">var <span class="ident">npcs</span> : list[<a title="space_hulk_game.engine.entities.NPC" href="entities.html#space_hulk_game.engine.entities.NPC">NPC</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.Scene.visited"><code class="name">var <span class="ident">visited</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="space_hulk_game.engine.Scene.add_item"><code class="name flex">
<span>def <span class="ident">add_item</span></span>(<span>self,<br>item: <a title="space_hulk_game.engine.entities.Item" href="entities.html#space_hulk_game.engine.entities.Item">Item</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_item(self, item: Item) -&gt; None:
    &#34;&#34;&#34;
    Add an item to the scene.

    Args:
        item: The Item object to add.

    Examples:
        &gt;&gt;&gt; item = Item(id=&#34;key&#34;, name=&#34;Key&#34;, description=&#34;A key.&#34;)
        &gt;&gt;&gt; scene = Scene(id=&#34;room&#34;, name=&#34;Room&#34;, description=&#34;A room.&#34;)
        &gt;&gt;&gt; scene.add_item(item)
        &gt;&gt;&gt; len(scene.items)
        1
    &#34;&#34;&#34;
    self.items.append(item)</code></pre>
</details>
<div class="desc"><p>Add an item to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item</code></strong></dt>
<dd>The Item object to add.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; item = Item(id=&quot;key&quot;, name=&quot;Key&quot;, description=&quot;A key.&quot;)
&gt;&gt;&gt; scene = Scene(id=&quot;room&quot;, name=&quot;Room&quot;, description=&quot;A room.&quot;)
&gt;&gt;&gt; scene.add_item(item)
&gt;&gt;&gt; len(scene.items)
1
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.Scene.can_exit"><code class="name flex">
<span>def <span class="ident">can_exit</span></span>(<span>self, direction: str, inventory: list[str], game_flags: dict[str, bool]) ‑> tuple[bool, str | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def can_exit(
    self, direction: str, inventory: list[str], game_flags: dict[str, bool]
) -&gt; tuple[bool, Optional[str]]:
    &#34;&#34;&#34;
    Check if the player can use a specific exit.

    Args:
        direction: The direction/exit name to check.
        inventory: Player&#39;s current inventory.
        game_flags: Current game flags.

    Returns:
        A tuple of (can_exit: bool, reason: Optional[str]).
        If can_exit is False, reason contains an explanation.

    Examples:
        &gt;&gt;&gt; scene = Scene(
        ...     id=&#34;room&#34;,
        ...     name=&#34;Room&#34;,
        ...     description=&#34;A room.&#34;,
        ...     exits={&#34;north&#34;: &#34;hallway&#34;},
        ...     locked_exits={&#34;north&#34;: &#34;key&#34;}
        ... )
        &gt;&gt;&gt; scene.can_exit(&#34;north&#34;, [], {})
        (False, &#39;The exit to the north is locked. You need: key&#39;)
        &gt;&gt;&gt; scene.can_exit(&#34;north&#34;, [&#34;key&#34;], {})
        (True, None)
        &gt;&gt;&gt; scene.can_exit(&#34;south&#34;, [&#34;key&#34;], {})
        (False, &#39;There is no exit in that direction.&#39;)
    &#34;&#34;&#34;
    if direction not in self.exits:
        return False, &#34;There is no exit in that direction.&#34;

    if direction in self.locked_exits:
        required = self.locked_exits[direction]

        # Check if it&#39;s an item requirement
        if required in inventory:
            return True, None

        # Check if it&#39;s a flag requirement
        if game_flags.get(required, False):
            return True, None

        return False, f&#34;The exit to the {direction} is locked. You need: {required}&#34;

    return True, None</code></pre>
</details>
<div class="desc"><p>Check if the player can use a specific exit.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>direction</code></strong></dt>
<dd>The direction/exit name to check.</dd>
<dt><strong><code>inventory</code></strong></dt>
<dd>Player's current inventory.</dd>
<dt><strong><code>game_flags</code></strong></dt>
<dd>Current game flags.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple of (can_exit: bool, reason: Optional[str]).
If can_exit is False, reason contains an explanation.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; scene = Scene(
...     id=&quot;room&quot;,
...     name=&quot;Room&quot;,
...     description=&quot;A room.&quot;,
...     exits={&quot;north&quot;: &quot;hallway&quot;},
...     locked_exits={&quot;north&quot;: &quot;key&quot;}
... )
&gt;&gt;&gt; scene.can_exit(&quot;north&quot;, [], {})
(False, 'The exit to the north is locked. You need: key')
&gt;&gt;&gt; scene.can_exit(&quot;north&quot;, [&quot;key&quot;], {})
(True, None)
&gt;&gt;&gt; scene.can_exit(&quot;south&quot;, [&quot;key&quot;], {})
(False, 'There is no exit in that direction.')
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.Scene.get_entry_events"><code class="name flex">
<span>def <span class="ident">get_entry_events</span></span>(<span>self, game_flags: dict[str, bool]) ‑> list[<a title="space_hulk_game.engine.entities.Event" href="entities.html#space_hulk_game.engine.entities.Event">Event</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_entry_events(self, game_flags: dict[str, bool]) -&gt; list[Event]:
    &#34;&#34;&#34;
    Get all events that should trigger when entering this scene.

    Args:
        game_flags: Current game flags.

    Returns:
        List of Event objects that can trigger.

    Examples:
        &gt;&gt;&gt; event = Event(
        ...     id=&#34;ambush&#34;,
        ...     description=&#34;An ambush!&#34;,
        ...     trigger_on_entry=True
        ... )
        &gt;&gt;&gt; scene = Scene(
        ...     id=&#34;room&#34;,
        ...     name=&#34;Room&#34;,
        ...     description=&#34;A room.&#34;,
        ...     events=[event]
        ... )
        &gt;&gt;&gt; events = scene.get_entry_events({})
        &gt;&gt;&gt; len(events)
        1
    &#34;&#34;&#34;
    return [
        event
        for event in self.events
        if event.trigger_on_entry and event.can_trigger(game_flags)
    ]</code></pre>
</details>
<div class="desc"><p>Get all events that should trigger when entering this scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>game_flags</code></strong></dt>
<dd>Current game flags.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of Event objects that can trigger.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; event = Event(
...     id=&quot;ambush&quot;,
...     description=&quot;An ambush!&quot;,
...     trigger_on_entry=True
... )
&gt;&gt;&gt; scene = Scene(
...     id=&quot;room&quot;,
...     name=&quot;Room&quot;,
...     description=&quot;A room.&quot;,
...     events=[event]
... )
&gt;&gt;&gt; events = scene.get_entry_events({})
&gt;&gt;&gt; len(events)
1
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.Scene.get_exit_description"><code class="name flex">
<span>def <span class="ident">get_exit_description</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_exit_description(self) -&gt; str:
    &#34;&#34;&#34;
    Get a description of available exits.

    Returns:
        A formatted string describing available exits.

    Examples:
        &gt;&gt;&gt; scene = Scene(
        ...     id=&#34;room&#34;,
        ...     name=&#34;Room&#34;,
        ...     description=&#34;A room.&#34;,
        ...     exits={&#34;north&#34;: &#34;hallway&#34;, &#34;east&#34;: &#34;closet&#34;}
        ... )
        &gt;&gt;&gt; desc = scene.get_exit_description()
        &gt;&gt;&gt; &#34;north&#34; in desc and &#34;east&#34; in desc
        True
    &#34;&#34;&#34;
    if not self.exits:
        return &#34;There are no obvious exits.&#34;

    exit_names = list(self.exits.keys())
    if len(exit_names) == 1:
        return f&#34;There is an exit to the {exit_names[0]}.&#34;
    else:
        exits_str = &#34;, &#34;.join(exit_names[:-1]) + f&#34; and {exit_names[-1]}&#34;
        return f&#34;There are exits to the {exits_str}.&#34;</code></pre>
</details>
<div class="desc"><p>Get a description of available exits.</p>
<h2 id="returns">Returns</h2>
<p>A formatted string describing available exits.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; scene = Scene(
...     id=&quot;room&quot;,
...     name=&quot;Room&quot;,
...     description=&quot;A room.&quot;,
...     exits={&quot;north&quot;: &quot;hallway&quot;, &quot;east&quot;: &quot;closet&quot;}
... )
&gt;&gt;&gt; desc = scene.get_exit_description()
&gt;&gt;&gt; &quot;north&quot; in desc and &quot;east&quot; in desc
True
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.Scene.get_full_description"><code class="name flex">
<span>def <span class="ident">get_full_description</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_full_description(self) -&gt; str:
    &#34;&#34;&#34;
    Get the complete description of the scene, including items and NPCs.

    Returns:
        A formatted string describing the scene and its contents.

    Examples:
        &gt;&gt;&gt; item = Item(id=&#34;key&#34;, name=&#34;Brass Key&#34;, description=&#34;A key.&#34;)
        &gt;&gt;&gt; scene = Scene(
        ...     id=&#34;room&#34;,
        ...     name=&#34;Test Room&#34;,
        ...     description=&#34;A test room.&#34;,
        ...     items=[item]
        ... )
        &gt;&gt;&gt; desc = scene.get_full_description()
        &gt;&gt;&gt; &#34;Brass Key&#34; in desc
        True
    &#34;&#34;&#34;
    parts = [self.description]

    if self.items:
        item_names = [item.name for item in self.items]
        parts.append(f&#34;\n\nYou see: {&#39;, &#39;.join(item_names)}.&#34;)

    if self.npcs:
        npc_descriptions = [npc.description for npc in self.npcs]
        parts.append(f&#34;\n\n{&#39; &#39;.join(npc_descriptions)}&#34;)

    return &#34;&#34;.join(parts)</code></pre>
</details>
<div class="desc"><p>Get the complete description of the scene, including items and NPCs.</p>
<h2 id="returns">Returns</h2>
<p>A formatted string describing the scene and its contents.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; item = Item(id=&quot;key&quot;, name=&quot;Brass Key&quot;, description=&quot;A key.&quot;)
&gt;&gt;&gt; scene = Scene(
...     id=&quot;room&quot;,
...     name=&quot;Test Room&quot;,
...     description=&quot;A test room.&quot;,
...     items=[item]
... )
&gt;&gt;&gt; desc = scene.get_full_description()
&gt;&gt;&gt; &quot;Brass Key&quot; in desc
True
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.Scene.get_item"><code class="name flex">
<span>def <span class="ident">get_item</span></span>(<span>self, item_id: str) ‑> <a title="space_hulk_game.engine.entities.Item" href="entities.html#space_hulk_game.engine.entities.Item">Item</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_item(self, item_id: str) -&gt; Optional[Item]:
    &#34;&#34;&#34;
    Get an item from the scene by ID.

    Args:
        item_id: The ID of the item to retrieve.

    Returns:
        The Item object if found, None otherwise.

    Examples:
        &gt;&gt;&gt; item = Item(id=&#34;key&#34;, name=&#34;Key&#34;, description=&#34;A key.&#34;)
        &gt;&gt;&gt; scene = Scene(
        ...     id=&#34;room&#34;,
        ...     name=&#34;Room&#34;,
        ...     description=&#34;A room.&#34;,
        ...     items=[item]
        ... )
        &gt;&gt;&gt; found = scene.get_item(&#34;key&#34;)
        &gt;&gt;&gt; found.name
        &#39;Key&#39;
        &gt;&gt;&gt; scene.get_item(&#34;missing&#34;)
    &#34;&#34;&#34;
    for item in self.items:
        if item.id == item_id:
            return item
    return None</code></pre>
</details>
<div class="desc"><p>Get an item from the scene by ID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item_id</code></strong></dt>
<dd>The ID of the item to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The Item object if found, None otherwise.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; item = Item(id=&quot;key&quot;, name=&quot;Key&quot;, description=&quot;A key.&quot;)
&gt;&gt;&gt; scene = Scene(
...     id=&quot;room&quot;,
...     name=&quot;Room&quot;,
...     description=&quot;A room.&quot;,
...     items=[item]
... )
&gt;&gt;&gt; found = scene.get_item(&quot;key&quot;)
&gt;&gt;&gt; found.name
'Key'
&gt;&gt;&gt; scene.get_item(&quot;missing&quot;)
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.Scene.get_npc"><code class="name flex">
<span>def <span class="ident">get_npc</span></span>(<span>self, npc_id: str) ‑> <a title="space_hulk_game.engine.entities.NPC" href="entities.html#space_hulk_game.engine.entities.NPC">NPC</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_npc(self, npc_id: str) -&gt; Optional[NPC]:
    &#34;&#34;&#34;
    Get an NPC from the scene by ID.

    Args:
        npc_id: The ID of the NPC to retrieve.

    Returns:
        The NPC object if found, None otherwise.

    Examples:
        &gt;&gt;&gt; npc = NPC(id=&#34;guard&#34;, name=&#34;Guard&#34;, description=&#34;A guard.&#34;)
        &gt;&gt;&gt; scene = Scene(
        ...     id=&#34;room&#34;,
        ...     name=&#34;Room&#34;,
        ...     description=&#34;A room.&#34;,
        ...     npcs=[npc]
        ... )
        &gt;&gt;&gt; found = scene.get_npc(&#34;guard&#34;)
        &gt;&gt;&gt; found.name
        &#39;Guard&#39;
    &#34;&#34;&#34;
    for npc in self.npcs:
        if npc.id == npc_id:
            return npc
    return None</code></pre>
</details>
<div class="desc"><p>Get an NPC from the scene by ID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>npc_id</code></strong></dt>
<dd>The ID of the NPC to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The NPC object if found, None otherwise.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; npc = NPC(id=&quot;guard&quot;, name=&quot;Guard&quot;, description=&quot;A guard.&quot;)
&gt;&gt;&gt; scene = Scene(
...     id=&quot;room&quot;,
...     name=&quot;Room&quot;,
...     description=&quot;A room.&quot;,
...     npcs=[npc]
... )
&gt;&gt;&gt; found = scene.get_npc(&quot;guard&quot;)
&gt;&gt;&gt; found.name
'Guard'
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.Scene.remove_item"><code class="name flex">
<span>def <span class="ident">remove_item</span></span>(<span>self, item_id: str) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_item(self, item_id: str) -&gt; bool:
    &#34;&#34;&#34;
    Remove an item from the scene.

    Args:
        item_id: The ID of the item to remove.

    Returns:
        True if the item was removed, False if not found.

    Examples:
        &gt;&gt;&gt; item = Item(id=&#34;key&#34;, name=&#34;Key&#34;, description=&#34;A key.&#34;)
        &gt;&gt;&gt; scene = Scene(
        ...     id=&#34;room&#34;,
        ...     name=&#34;Room&#34;,
        ...     description=&#34;A room.&#34;,
        ...     items=[item]
        ... )
        &gt;&gt;&gt; scene.remove_item(&#34;key&#34;)
        True
        &gt;&gt;&gt; len(scene.items)
        0
        &gt;&gt;&gt; scene.remove_item(&#34;key&#34;)
        False
    &#34;&#34;&#34;
    for i, item in enumerate(self.items):
        if item.id == item_id:
            self.items.pop(i)
            return True
    return False</code></pre>
</details>
<div class="desc"><p>Remove an item from the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item_id</code></strong></dt>
<dd>The ID of the item to remove.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the item was removed, False if not found.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; item = Item(id=&quot;key&quot;, name=&quot;Key&quot;, description=&quot;A key.&quot;)
&gt;&gt;&gt; scene = Scene(
...     id=&quot;room&quot;,
...     name=&quot;Room&quot;,
...     description=&quot;A room.&quot;,
...     items=[item]
... )
&gt;&gt;&gt; scene.remove_item(&quot;key&quot;)
True
&gt;&gt;&gt; len(scene.items)
0
&gt;&gt;&gt; scene.remove_item(&quot;key&quot;)
False
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.Scene.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict:
    &#34;&#34;&#34;
    Convert the scene to a dictionary for serialization.

    Returns:
        Dictionary representation of the scene.
    &#34;&#34;&#34;
    return {
        &#34;id&#34;: self.id,
        &#34;name&#34;: self.name,
        &#34;description&#34;: self.description,
        &#34;exits&#34;: self.exits,
        &#34;items&#34;: [item.to_dict() for item in self.items],
        &#34;npcs&#34;: [npc.to_dict() for npc in self.npcs],
        &#34;events&#34;: [event.to_dict() for event in self.events],
        &#34;visited&#34;: self.visited,
        &#34;dark&#34;: self.dark,
        &#34;locked_exits&#34;: self.locked_exits,
    }</code></pre>
</details>
<div class="desc"><p>Convert the scene to a dictionary for serialization.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary representation of the scene.</p></div>
</dd>
<dt id="space_hulk_game.engine.Scene.unlock_exit"><code class="name flex">
<span>def <span class="ident">unlock_exit</span></span>(<span>self, direction: str) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unlock_exit(self, direction: str) -&gt; bool:
    &#34;&#34;&#34;
    Unlock an exit, making it passable.

    Args:
        direction: The direction/exit to unlock.

    Returns:
        True if the exit was unlocked, False if it wasn&#39;t locked.

    Examples:
        &gt;&gt;&gt; scene = Scene(
        ...     id=&#34;room&#34;,
        ...     name=&#34;Room&#34;,
        ...     description=&#34;A room.&#34;,
        ...     exits={&#34;north&#34;: &#34;hallway&#34;},
        ...     locked_exits={&#34;north&#34;: &#34;key&#34;}
        ... )
        &gt;&gt;&gt; scene.unlock_exit(&#34;north&#34;)
        True
        &gt;&gt;&gt; &#34;north&#34; in scene.locked_exits
        False
    &#34;&#34;&#34;
    if direction in self.locked_exits:
        del self.locked_exits[direction]
        return True
    return False</code></pre>
</details>
<div class="desc"><p>Unlock an exit, making it passable.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>direction</code></strong></dt>
<dd>The direction/exit to unlock.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the exit was unlocked, False if it wasn't locked.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; scene = Scene(
...     id=&quot;room&quot;,
...     name=&quot;Room&quot;,
...     description=&quot;A room.&quot;,
...     exits={&quot;north&quot;: &quot;hallway&quot;},
...     locked_exits={&quot;north&quot;: &quot;key&quot;}
... )
&gt;&gt;&gt; scene.unlock_exit(&quot;north&quot;)
True
&gt;&gt;&gt; &quot;north&quot; in scene.locked_exits
False
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.engine.TakeAction"><code class="flex name class">
<span>class <span class="ident">TakeAction</span></span>
<span>(</span><span>raw_command: str = '', item_id: str = '')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class TakeAction(Action):
    &#34;&#34;&#34;
    Represents taking/picking up an item.

    Attributes:
        item_id: The ID or name of the item to take.
        raw_command: The original text command from the player.

    Examples:
        &gt;&gt;&gt; action = TakeAction(item_id=&#34;medkit&#34;, raw_command=&#34;take medkit&#34;)
        &gt;&gt;&gt; action.item_id
        &#39;medkit&#39;
    &#34;&#34;&#34;

    item_id: str = &#34;&#34;

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Return a string representation of the action.&#34;&#34;&#34;
        return f&#34;TakeAction(item_id=&#39;{self.item_id}&#39;)&#34;</code></pre>
</details>
<div class="desc"><p>Represents taking/picking up an item.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>item_id</code></strong></dt>
<dd>The ID or name of the item to take.</dd>
<dt><strong><code>raw_command</code></strong></dt>
<dd>The original text command from the player.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; action = TakeAction(item_id=&quot;medkit&quot;, raw_command=&quot;take medkit&quot;)
&gt;&gt;&gt; action.item_id
'medkit'
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="space_hulk_game.engine.actions.Action" href="actions.html#space_hulk_game.engine.actions.Action">Action</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="space_hulk_game.engine.TakeAction.item_id"><code class="name">var <span class="ident">item_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.engine.TalkAction"><code class="flex name class">
<span>class <span class="ident">TalkAction</span></span>
<span>(</span><span>raw_command: str = '', npc_id: str = '', topic: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class TalkAction(Action):
    &#34;&#34;&#34;
    Represents talking to an NPC.

    Attributes:
        npc_id: The ID or name of the NPC to talk to.
        topic: Optional dialogue topic or key.
        raw_command: The original text command from the player.

    Examples:
        &gt;&gt;&gt; action = TalkAction(npc_id=&#34;guard&#34;, raw_command=&#34;talk to guard&#34;)
        &gt;&gt;&gt; action.npc_id
        &#39;guard&#39;

        &gt;&gt;&gt; action2 = TalkAction(npc_id=&#34;guard&#34;, topic=&#34;quest&#34;, raw_command=&#34;ask guard about quest&#34;)
        &gt;&gt;&gt; action2.topic
        &#39;quest&#39;
    &#34;&#34;&#34;

    npc_id: str = &#34;&#34;
    topic: Optional[str] = None

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Return a string representation of the action.&#34;&#34;&#34;
        if self.topic:
            return f&#34;TalkAction(npc_id=&#39;{self.npc_id}&#39;, topic=&#39;{self.topic}&#39;)&#34;
        return f&#34;TalkAction(npc_id=&#39;{self.npc_id}&#39;)&#34;</code></pre>
</details>
<div class="desc"><p>Represents talking to an NPC.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>npc_id</code></strong></dt>
<dd>The ID or name of the NPC to talk to.</dd>
<dt><strong><code>topic</code></strong></dt>
<dd>Optional dialogue topic or key.</dd>
<dt><strong><code>raw_command</code></strong></dt>
<dd>The original text command from the player.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; action = TalkAction(npc_id=&quot;guard&quot;, raw_command=&quot;talk to guard&quot;)
&gt;&gt;&gt; action.npc_id
'guard'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; action2 = TalkAction(npc_id=&quot;guard&quot;, topic=&quot;quest&quot;, raw_command=&quot;ask guard about quest&quot;)
&gt;&gt;&gt; action2.topic
'quest'
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="space_hulk_game.engine.actions.Action" href="actions.html#space_hulk_game.engine.actions.Action">Action</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="space_hulk_game.engine.TalkAction.npc_id"><code class="name">var <span class="ident">npc_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.TalkAction.topic"><code class="name">var <span class="ident">topic</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.engine.TextAdventureEngine"><code class="flex name class">
<span>class <span class="ident">TextAdventureEngine</span></span>
<span>(</span><span>game_state: <a title="space_hulk_game.engine.game_state.GameState" href="game_state.html#space_hulk_game.engine.game_state.GameState">GameState</a>,<br>scenes: dict[str, <a title="space_hulk_game.engine.scene.Scene" href="scene.html#space_hulk_game.engine.scene.Scene">Scene</a>],<br>input_func: Callable[[], str] | None = None,<br>output_func: Callable[[str], None] | None = None,<br>victory_conditions: set | None = None,<br>defeat_conditions: set | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextAdventureEngine:
    &#34;&#34;&#34;
    Main game engine for text-based adventure games.

    This class implements the core game loop and coordinates all game systems:
    - Command parsing and action execution
    - Scene management and state transitions
    - Event processing and triggering
    - Player input/output
    - Victory/defeat condition checking

    The engine follows the Facade pattern, providing a simple interface
    to the complex subsystems of the game (parser, state, scenes, etc.).

    Attributes:
        game_state: The current game state (player location, inventory, etc.).
        scenes: Dictionary mapping scene IDs to Scene objects.
        parser: CommandParser instance for processing player commands.
        running: Whether the game loop is currently running.
        victory_conditions: Set of game flags that trigger victory.
        defeat_conditions: Set of game flags that trigger defeat.
        input_func: Function for getting player input (for testing).
        output_func: Function for displaying output (for testing).

    Examples:
        Create and run a basic game:
        &gt;&gt;&gt; from space_hulk_game.engine import (
        ...     TextAdventureEngine, GameState, Scene, Item
        ... )
        &gt;&gt;&gt; state = GameState(current_scene=&#34;room1&#34;)
        &gt;&gt;&gt; scenes = {
        ...     &#34;room1&#34;: Scene(
        ...         id=&#34;room1&#34;,
        ...         name=&#34;Starting Room&#34;,
        ...         description=&#34;A simple room.&#34;,
        ...         exits={&#34;north&#34;: &#34;room2&#34;}
        ...     ),
        ...     &#34;room2&#34;: Scene(
        ...         id=&#34;room2&#34;,
        ...         name=&#34;Second Room&#34;,
        ...         description=&#34;Another room.&#34;
        ...     )
        ... }
        &gt;&gt;&gt; engine = TextAdventureEngine(state, scenes)
        &gt;&gt;&gt; # engine.run()  # Start the interactive game loop
    &#34;&#34;&#34;

    def __init__(
        self,
        game_state: GameState,
        scenes: dict[str, Scene],
        input_func: Optional[Callable[[], str]] = None,
        output_func: Optional[Callable[[str], None]] = None,
        victory_conditions: Optional[set] = None,
        defeat_conditions: Optional[set] = None,
    ):
        &#34;&#34;&#34;
        Initialize the text adventure engine.

        Args:
            game_state: Initial game state.
            scenes: Dictionary mapping scene IDs to Scene objects.
            input_func: Optional custom input function (default: input()).
            output_func: Optional custom output function (default: print()).
            victory_conditions: Optional set of flags that trigger victory.
            defeat_conditions: Optional set of flags that trigger defeat.

        Raises:
            ValueError: If current scene is not in scenes dict.
        &#34;&#34;&#34;
        self.game_state = game_state
        self.scenes = scenes
        self.parser = CommandParser()
        self.running = False

        # I/O functions (allow injection for testing)
        self.input_func = input_func or input
        self.output_func = output_func or print

        # Win/loss conditions
        self.victory_conditions = victory_conditions or set()
        self.defeat_conditions = defeat_conditions or set()

        # Build item registry from all scenes
        self._item_registry: dict[str, Item] = {}
        for scene in scenes.values():
            for item in scene.items:
                self._item_registry[item.id] = item

        # Validate initial state
        if game_state.current_scene not in scenes:
            raise ValueError(f&#34;Initial scene &#39;{game_state.current_scene}&#39; not found in scenes&#34;)

        logger.info(f&#34;TextAdventureEngine initialized with {len(scenes)} scenes&#34;)

    def run(self) -&gt; None:
        &#34;&#34;&#34;
        Start the main game loop.

        This method handles:
        1. Initial scene display
        2. Player input collection
        3. Command parsing
        4. Action execution
        5. State updates
        6. Victory/defeat checking

        The loop continues until the player quits, wins, or loses.

        Examples:
            &gt;&gt;&gt; engine = TextAdventureEngine(state, scenes)
            &gt;&gt;&gt; # engine.run()  # Starts interactive game
        &#34;&#34;&#34;
        self.running = True
        logger.info(&#34;Game loop started&#34;)

        # Display intro and current scene
        self._display_welcome()
        self._display_current_scene()
        self._process_entry_events()

        # Main game loop
        while self.running:
            try:
                # Check win/loss conditions
                if self._check_victory():
                    self._display_victory()
                    break

                if self._check_defeat():
                    self._display_defeat()
                    break

                # Get player input
                try:
                    command = self.input_func()
                except (EOFError, KeyboardInterrupt):
                    self._output(&#34;\n\nGoodbye!&#34;)
                    break

                if not command or not command.strip():
                    continue

                # Handle quit commands
                if command.strip().lower() in [&#34;quit&#34;, &#34;exit&#34;, &#34;q&#34;]:
                    if self._confirm_quit():
                        self._output(&#34;\nThanks for playing!&#34;)
                        break
                    continue

                # Parse and execute command
                current_scene = self.scenes[self.game_state.current_scene]
                action = self.parser.parse(command, self.game_state, current_scene)

                self._execute_action(action)

            except Exception as e:
                logger.exception(&#34;Error in game loop&#34;)
                self._output(f&#34;\nAn error occurred: {e}&#34;)
                self._output(&#34;Please try another command.\n&#34;)

        self.running = False
        logger.info(&#34;Game loop ended&#34;)

    def _execute_action(self, action: Action) -&gt; None:
        &#34;&#34;&#34;
        Execute a parsed action and update game state.

        Args:
            action: The Action object to execute.
        &#34;&#34;&#34;
        logger.debug(f&#34;Executing action: {action}&#34;)

        # Route to appropriate handler
        if isinstance(action, MoveAction):
            self.handle_move(action.direction)
        elif isinstance(action, TakeAction):
            self.handle_take(action.item_id)
        elif isinstance(action, DropAction):
            self.handle_drop(action.item_id)
        elif isinstance(action, UseAction):
            self.handle_use(action.item_id, action.target_id)
        elif isinstance(action, LookAction):
            self.handle_look(action.target)
        elif isinstance(action, InventoryAction):
            self.handle_inventory()
        elif isinstance(action, TalkAction):
            self.handle_talk(action.npc_id, action.topic)
        elif isinstance(action, HelpAction):
            self.handle_help()
        elif isinstance(action, UnknownAction):
            self._handle_unknown(action)
        else:
            self._output(&#34;I don&#39;t understand that command.&#34;)
            logger.warning(f&#34;Unknown action type: {type(action)}&#34;)

    def handle_move(self, direction: str) -&gt; None:
        &#34;&#34;&#34;
        Handle movement to another scene.

        Args:
            direction: The direction or exit name to move through.
        &#34;&#34;&#34;
        current_scene = self.scenes[self.game_state.current_scene]

        # Check if exit exists and is accessible
        can_exit, reason = current_scene.can_exit(
            direction, self.game_state.inventory, self.game_state.game_flags
        )

        if not can_exit:
            self._output(f&#34;\n{reason}\n&#34;)
            logger.debug(f&#34;Move blocked: {reason}&#34;)
            return

        # Get destination scene
        destination_id = current_scene.exits[direction]

        if destination_id not in self.scenes:
            self._output(f&#34;\nError: Destination &#39;{destination_id}&#39; not found.\n&#34;)
            logger.error(f&#34;Invalid destination: {destination_id}&#34;)
            return

        # Move to new scene
        old_scene_id = self.game_state.current_scene
        self.game_state.visit_scene(destination_id)
        logger.info(f&#34;Moved from {old_scene_id} to {destination_id}&#34;)

        # Display new scene
        self._output(&#34;&#34;)  # Blank line
        self._display_current_scene()

        # Process entry events
        self._process_entry_events()

    def handle_take(self, item_id: str) -&gt; None:
        &#34;&#34;&#34;
        Handle taking an item from the current scene.

        Args:
            item_id: The ID or name of the item to take.
        &#34;&#34;&#34;
        current_scene = self.scenes[self.game_state.current_scene]

        # Find the item in the scene
        item = current_scene.get_item(item_id)

        if not item:
            self._output(f&#34;\nYou don&#39;t see &#39;{item_id}&#39; here.\n&#34;)
            logger.debug(f&#34;Item not found: {item_id}&#34;)
            return

        # Check if item is takeable
        if not item.takeable:
            self._output(f&#34;\nYou can&#39;t take the {item.name}.\n&#34;)
            logger.debug(f&#34;Item not takeable: {item_id}&#34;)
            return

        # Add to inventory and remove from scene
        self.game_state.add_item(item.id)
        current_scene.remove_item(item.id)

        # Register item in registry if not already there
        if item.id not in self._item_registry:
            self._item_registry[item.id] = item

        self._output(f&#34;\nYou take the {item.name}.\n&#34;)
        logger.info(f&#34;Took item: {item.id}&#34;)

    def handle_drop(self, item_id: str) -&gt; None:
        &#34;&#34;&#34;
        Handle dropping an item from inventory.

        Args:
            item_id: The ID or name of the item to drop.
        &#34;&#34;&#34;
        if not self.game_state.has_item(item_id):
            self._output(f&#34;\nYou don&#39;t have &#39;{item_id}&#39;.\n&#34;)
            logger.debug(f&#34;Item not in inventory: {item_id}&#34;)
            return

        # Get the item from registry
        item = self._item_registry.get(item_id)
        if item is None:
            # Item not in registry - create a basic item as fallback
            item = Item(
                id=item_id,
                name=item_id.replace(&#34;_&#34;, &#34; &#34;).title(),
                description=f&#34;A {item_id.replace(&#39;_&#39;, &#39; &#39;)}.&#34;,
                takeable=True,
            )
            self._item_registry[item_id] = item

        # Remove from inventory
        self.game_state.remove_item(item_id)

        # Add to current scene
        current_scene = self.scenes[self.game_state.current_scene]
        current_scene.add_item(item)

        self._output(f&#34;\nYou drop the {item.name}.\n&#34;)
        logger.info(f&#34;Dropped item: {item_id}&#34;)

    def handle_use(self, item_id: str, target_id: Optional[str] = None) -&gt; None:
        &#34;&#34;&#34;
        Handle using an item.

        Args:
            item_id: The ID of the item to use.
            target_id: Optional target for the item.
        &#34;&#34;&#34;
        # Check if player has the item
        if not self.game_state.has_item(item_id):
            self._output(f&#34;\nYou don&#39;t have &#39;{item_id}&#39;.\n&#34;)
            logger.debug(f&#34;Item not in inventory: {item_id}&#34;)
            return

        # Get the item from registry
        item = self._item_registry.get(item_id)
        if item is None:
            self._output(f&#34;\nYou can&#39;t use the {item_id}.\n&#34;)
            logger.warning(f&#34;Item not in registry: {item_id}&#34;)
            return

        # Check if item is useable
        if not item.useable:
            self._output(f&#34;\nYou can&#39;t use the {item.name}.\n&#34;)
            logger.debug(f&#34;Item not useable: {item_id}&#34;)
            return

        # Check if item has required flag
        if item.required_flag and not self.game_state.get_flag(item.required_flag):
            self._output(f&#34;\nYou can&#39;t use the {item.name} right now.\n&#34;)
            logger.debug(f&#34;Missing required flag for item: {item.required_flag}&#34;)
            return

        # Display use text if available
        if item.use_text:
            self._output(f&#34;\n{item.use_text}\n&#34;)

        # Apply item effects
        effects_applied = False

        # Handle healing effect
        if &#34;heal&#34; in item.effects:
            heal_amount = item.effects[&#34;heal&#34;]
            self.game_state.heal(heal_amount)
            if not item.use_text:
                self._output(f&#34;\nYou use the {item.name}. You feel better! (+{heal_amount} HP)\n&#34;)
            effects_applied = True
            # Remove consumable healing items
            self.game_state.remove_item(item_id)
            logger.info(f&#34;Used healing item: {item_id}, healed {heal_amount} HP&#34;)

        # Handle unlock effect
        if &#34;unlock&#34; in item.effects:
            current_scene = self.scenes[self.game_state.current_scene]
            unlock_target = item.effects[&#34;unlock&#34;]

            # Try to unlock the specified exit or any locked exit that requires this item
            unlocked = False
            for direction, locked_item in list(current_scene.locked_exits.items()):
                if locked_item == item_id or (target_id and direction == target_id):
                    current_scene.unlock_exit(direction)
                    if not item.use_text:
                        self._output(
                            f&#34;\nYou use the {item.name}. You hear a click as the lock opens.\n&#34;
                        )
                    logger.info(f&#34;Unlocked exit: {direction}&#34;)
                    unlocked = True
                    effects_applied = True
                    break

            if not unlocked and not item.use_text:
                self._output(f&#34;\nThe {item.name} doesn&#39;t seem to unlock anything here.\n&#34;)

        # Handle damage effect
        if &#34;damage&#34; in item.effects:
            damage_amount = item.effects[&#34;damage&#34;]
            self.game_state.take_damage(damage_amount)
            if not item.use_text:
                self._output(f&#34;\nYou use the {item.name}. It hurts! (-{damage_amount} HP)\n&#34;)
            effects_applied = True
            logger.info(f&#34;Used damaging item: {item_id}, dealt {damage_amount} damage&#34;)

        # Handle flag setting effect
        if &#34;set_flag&#34; in item.effects:
            flag_name = item.effects[&#34;set_flag&#34;]
            self.game_state.set_flag(flag_name, True)
            if not item.use_text:
                self._output(f&#34;\nYou use the {item.name}.\n&#34;)
            effects_applied = True
            logger.info(f&#34;Set flag from item use: {flag_name}&#34;)

        # If no effects were applied and no use_text, show generic message
        if not effects_applied and not item.use_text:
            self._output(f&#34;\nYou use the {item.name}. Nothing happens.\n&#34;)
            logger.debug(f&#34;Used item with no effects: {item_id}&#34;)

    def handle_look(self, target: Optional[str] = None) -&gt; None:
        &#34;&#34;&#34;
        Handle examining the scene or an object.

        Args:
            target: Optional target to examine. If None, examine scene.
        &#34;&#34;&#34;
        current_scene = self.scenes[self.game_state.current_scene]

        if not target:
            # Look at the scene
            self._output(&#34;&#34;)
            self._display_current_scene()
            return

        # Look for item in scene
        item = current_scene.get_item(target)
        if item:
            self._output(f&#34;\n{item.description}\n&#34;)
            logger.debug(f&#34;Examined item: {target}&#34;)
            return

        # Look for NPC in scene
        npc = current_scene.get_npc(target)
        if npc:
            self._output(f&#34;\n{npc.description}\n&#34;)
            logger.debug(f&#34;Examined NPC: {target}&#34;)
            return

        # Not found
        self._output(f&#34;\nYou don&#39;t see &#39;{target}&#39; here.\n&#34;)
        logger.debug(f&#34;Target not found: {target}&#34;)

    def handle_talk(self, npc_id: str, topic: Optional[str] = None) -&gt; None:
        &#34;&#34;&#34;
        Handle talking to an NPC.

        Args:
            npc_id: The ID or name of the NPC to talk to.
            topic: Optional dialogue topic.
        &#34;&#34;&#34;
        current_scene = self.scenes[self.game_state.current_scene]

        # Find the NPC
        npc = current_scene.get_npc(npc_id)

        if not npc:
            self._output(f&#34;\nYou don&#39;t see &#39;{npc_id}&#39; here.\n&#34;)
            logger.debug(f&#34;NPC not found: {npc_id}&#34;)
            return

        # Check if can interact
        if not npc.can_interact(self.game_state.game_flags):
            self._output(f&#34;\nThe {npc.name} doesn&#39;t want to talk right now.\n&#34;)
            logger.debug(f&#34;Cannot interact with NPC: {npc_id}&#34;)
            return

        # Get dialogue
        if topic:
            dialogue = npc.get_dialogue(topic, f&#34;The {npc.name} has nothing to say about that.&#34;)
        else:
            # Try default greetings
            dialogue = npc.get_dialogue(&#34;greeting&#34;, None)
            if not dialogue:
                dialogue = npc.get_dialogue(&#34;default&#34;, f&#34;The {npc.name} nods at you.&#34;)

        self._output(f&#39;\n{npc.name}: &#34;{dialogue}&#34;\n&#39;)

        # Give item if configured
        if npc.gives_item and not self.game_state.has_item(npc.gives_item):
            self.game_state.add_item(npc.gives_item)
            self._output(f&#34;The {npc.name} gives you: {npc.gives_item}\n&#34;)
            logger.info(f&#34;Received item from NPC: {npc.gives_item}&#34;)

        logger.debug(f&#34;Talked to NPC: {npc_id}, topic: {topic}&#34;)

    def handle_inventory(self) -&gt; None:
        &#34;&#34;&#34;
        Display the player&#39;s inventory.
        &#34;&#34;&#34;
        if not self.game_state.inventory:
            self._output(&#34;\nYour inventory is empty.\n&#34;)
            return

        self._output(&#34;\n=== INVENTORY ===&#34;)
        for item_id in self.game_state.inventory:
            # Format item name nicely
            item_name = item_id.replace(&#34;_&#34;, &#34; &#34;).title()
            self._output(f&#34;  - {item_name}&#34;)
        self._output(&#34;&#34;)

        logger.debug(&#34;Displayed inventory&#34;)

    def handle_help(self) -&gt; None:
        &#34;&#34;&#34;
        Display available commands and help text.
        &#34;&#34;&#34;
        help_text = &#34;&#34;&#34;
=== AVAILABLE COMMANDS ===

Movement:
  go &lt;direction&gt;     - Move in a direction (north, south, east, west, etc.)

Interaction:
  take &lt;item&gt;        - Pick up an item
  drop &lt;item&gt;        - Drop an item from your inventory
  use &lt;item&gt;         - Use an item
  use &lt;item&gt; on &lt;target&gt; - Use an item on a target
  look               - Look at the current scene
  look at &lt;target&gt;   - Examine an object or NPC
  talk to &lt;npc&gt;      - Talk to an NPC
  ask &lt;npc&gt; about &lt;topic&gt; - Ask an NPC about something

Inventory:
  inventory          - Show your inventory (or &#39;inv&#39;, &#39;i&#39;)

Other:
  help               - Show this help text (or &#39;h&#39;, &#39;?&#39;)
  quit               - Quit the game (or &#39;exit&#39;, &#39;q&#39;)

Tips:
  - You can use synonyms for most commands (e.g., &#39;get&#39; instead of &#39;take&#39;)
  - The parser is forgiving with typos and variations
  - Explore thoroughly and talk to everyone!
&#34;&#34;&#34;
        self._output(help_text)
        logger.debug(&#34;Displayed help&#34;)

    def _handle_unknown(self, action: UnknownAction) -&gt; None:
        &#34;&#34;&#34;
        Handle an unknown/unrecognized command.

        Args:
            action: The UnknownAction with optional suggestion.
        &#34;&#34;&#34;
        self._output(&#34;\nI don&#39;t understand that command.&#34;)

        if action.suggestion:
            self._output(f&#34;Did you mean &#39;{action.suggestion}&#39;?&#34;)

        self._output(&#34;Type &#39;help&#39; for a list of commands.\n&#34;)
        logger.debug(f&#34;Unknown command: {action.raw_command}&#34;)

    def _display_welcome(self) -&gt; None:
        &#34;&#34;&#34;Display welcome message.&#34;&#34;&#34;
        welcome = &#34;&#34;&#34;
╔═══════════════════════════════════════════════════════════╗
║           SPACE HULK: DERELICT OF THE VOID                ║
║                                                           ║
║  A Text Adventure in the Warhammer 40,000 Universe       ║
╚═══════════════════════════════════════════════════════════╝

In the grim darkness of the far future, there is only war...

Type &#39;help&#39; for a list of commands. Type &#39;quit&#39; to exit.
&#34;&#34;&#34;
        self._output(welcome)

    def _display_current_scene(self) -&gt; None:
        &#34;&#34;&#34;Display the current scene description.&#34;&#34;&#34;
        current_scene = self.scenes[self.game_state.current_scene]

        # Scene header
        self._output(&#34;=&#34; * 60)
        self._output(f&#34;{current_scene.name.upper()}&#34;)
        self._output(&#34;=&#34; * 60)

        # Scene description
        description = current_scene.get_full_description()
        self._output(f&#34;\n{description}\n&#34;)

        # Available exits
        exit_desc = current_scene.get_exit_description()
        self._output(exit_desc)

        # Health status
        health_percent = (self.game_state.health / self.game_state.max_health) * 100
        health_bar = self._get_health_bar(health_percent)
        self._output(
            f&#34;\nHealth: {health_bar} {self.game_state.health}/{self.game_state.max_health}&#34;
        )
        self._output(&#34;&#34;)

        # Mark as visited
        current_scene.visited = True

    def _get_health_bar(self, percent: float) -&gt; str:
        &#34;&#34;&#34;
        Generate a visual health bar with status indicators.

        Args:
            percent: Health percentage (0-100).

        Returns:
            A string representing a health bar with status indicator.
        &#34;&#34;&#34;
        bar_length = 20
        filled = int((percent / 100) * bar_length)
        empty = bar_length - filled

        bar = &#34;█&#34; * filled + &#34;░&#34; * empty

        # Add status indicators based on health
        if percent &gt; 75:
            return f&#34;[{bar}] (Good)&#34;
        elif percent &gt; 25:
            return f&#34;[{bar}] (Warning)&#34;
        else:
            return f&#34;[{bar}] (CRITICAL)&#34;

    def _process_entry_events(self) -&gt; None:
        &#34;&#34;&#34;Process events that trigger on entering the current scene.&#34;&#34;&#34;
        current_scene = self.scenes[self.game_state.current_scene]

        entry_events = current_scene.get_entry_events(self.game_state.game_flags)

        for event in entry_events:
            self._trigger_event(event)

    def _trigger_event(self, event: Event) -&gt; None:
        &#34;&#34;&#34;
        Trigger an event and apply its effects.

        Args:
            event: The Event to trigger.
        &#34;&#34;&#34;
        # Display event description
        self._output(f&#34;\n&gt;&gt;&gt; {event.description}\n&#34;)

        # Mark as triggered
        event.trigger()

        # Apply effects
        effects = event.effects

        if &#34;damage&#34; in effects:
            damage = effects[&#34;damage&#34;]
            self.game_state.take_damage(damage)
            self._output(f&#34;You take {damage} damage!\n&#34;)
            logger.info(f&#34;Event damage: {damage}&#34;)

        if &#34;heal&#34; in effects:
            heal = effects[&#34;heal&#34;]
            self.game_state.heal(heal)
            self._output(f&#34;You recover {heal} health!\n&#34;)
            logger.info(f&#34;Event heal: {heal}&#34;)

        if &#34;set_flag&#34; in effects:
            flag = effects[&#34;set_flag&#34;]
            self.game_state.set_flag(flag)
            logger.info(f&#34;Event set flag: {flag}&#34;)

        if &#34;give_item&#34; in effects:
            item_id = effects[&#34;give_item&#34;]
            self.game_state.add_item(item_id)
            self._output(f&#34;You receive: {item_id}\n&#34;)
            logger.info(f&#34;Event gave item: {item_id}&#34;)

        logger.info(f&#34;Triggered event: {event.id}&#34;)

    def _check_victory(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if victory conditions are met.

        Returns:
            True if player has won, False otherwise.
        &#34;&#34;&#34;
        if not self.victory_conditions:
            return False

        for flag in self.victory_conditions:
            if self.game_state.get_flag(flag):
                logger.info(f&#34;Victory condition met: {flag}&#34;)
                return True

        return False

    def _check_defeat(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if defeat conditions are met.

        Returns:
            True if player has lost, False otherwise.
        &#34;&#34;&#34;
        # Check death
        if not self.game_state.is_alive():
            logger.info(&#34;Defeat: Player died&#34;)
            return True

        # Check defeat flags
        for flag in self.defeat_conditions:
            if self.game_state.get_flag(flag):
                logger.info(f&#34;Defeat condition met: {flag}&#34;)
                return True

        return False

    def _display_victory(self) -&gt; None:
        &#34;&#34;&#34;Display victory message.&#34;&#34;&#34;
        victory_text = &#34;&#34;&#34;
╔═══════════════════════════════════════════════════════════╗
║                       VICTORY!                            ║
╚═══════════════════════════════════════════════════════════╝

Against all odds, you have succeeded in your mission!
The Emperor protects, and through your courage and skill,
you have brought honor to the Imperium.

May your name be remembered in the annals of history!
&#34;&#34;&#34;
        self._output(victory_text)

    def _display_defeat(self) -&gt; None:
        &#34;&#34;&#34;Display defeat message.&#34;&#34;&#34;
        defeat_text = &#34;&#34;&#34;
╔═══════════════════════════════════════════════════════════╗
║                       DEFEAT                              ║
╚═══════════════════════════════════════════════════════════╝

Your mission has ended in failure...

&#34;&#34;&#34;
        if not self.game_state.is_alive():
            defeat_text += &#34;You have fallen in battle.\n&#34;

        defeat_text += &#34;&#34;&#34;
In the grim darkness of the far future, there is only war,
and not all battles can be won. Your sacrifice will be
remembered by those who come after.

Perhaps in another timeline, victory was possible...
&#34;&#34;&#34;
        self._output(defeat_text)

    def _confirm_quit(self) -&gt; bool:
        &#34;&#34;&#34;
        Ask player to confirm they want to quit.

        Returns:
            True if player confirms quit, False otherwise.
        &#34;&#34;&#34;
        self._output(&#34;\nAre you sure you want to quit? (yes/no): &#34;)
        try:
            response = self.input_func()
            return response.strip().lower() in [&#34;yes&#34;, &#34;y&#34;]
        except (EOFError, KeyboardInterrupt):
            return True

    def _output(self, text: str) -&gt; None:
        &#34;&#34;&#34;
        Output text to the player.

        Args:
            text: The text to display.
        &#34;&#34;&#34;
        self.output_func(text)</code></pre>
</details>
<div class="desc"><p>Main game engine for text-based adventure games.</p>
<p>This class implements the core game loop and coordinates all game systems:
- Command parsing and action execution
- Scene management and state transitions
- Event processing and triggering
- Player input/output
- Victory/defeat condition checking</p>
<p>The engine follows the Facade pattern, providing a simple interface
to the complex subsystems of the game (parser, state, scenes, etc.).</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>game_state</code></strong></dt>
<dd>The current game state (player location, inventory, etc.).</dd>
<dt><strong><code>scenes</code></strong></dt>
<dd>Dictionary mapping scene IDs to Scene objects.</dd>
<dt><strong><code>parser</code></strong></dt>
<dd>CommandParser instance for processing player commands.</dd>
<dt><strong><code>running</code></strong></dt>
<dd>Whether the game loop is currently running.</dd>
<dt><strong><code>victory_conditions</code></strong></dt>
<dd>Set of game flags that trigger victory.</dd>
<dt><strong><code>defeat_conditions</code></strong></dt>
<dd>Set of game flags that trigger defeat.</dd>
<dt><strong><code>input_func</code></strong></dt>
<dd>Function for getting player input (for testing).</dd>
<dt><strong><code>output_func</code></strong></dt>
<dd>Function for displaying output (for testing).</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Create and run a basic game:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from space_hulk_game.engine import (
...     TextAdventureEngine, GameState, Scene, Item
... )
&gt;&gt;&gt; state = GameState(current_scene=&quot;room1&quot;)
&gt;&gt;&gt; scenes = {
...     &quot;room1&quot;: Scene(
...         id=&quot;room1&quot;,
...         name=&quot;Starting Room&quot;,
...         description=&quot;A simple room.&quot;,
...         exits={&quot;north&quot;: &quot;room2&quot;}
...     ),
...     &quot;room2&quot;: Scene(
...         id=&quot;room2&quot;,
...         name=&quot;Second Room&quot;,
...         description=&quot;Another room.&quot;
...     )
... }
&gt;&gt;&gt; engine = TextAdventureEngine(state, scenes)
&gt;&gt;&gt; # engine.run()  # Start the interactive game loop
</code></pre>
<p>Initialize the text adventure engine.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>game_state</code></strong></dt>
<dd>Initial game state.</dd>
<dt><strong><code>scenes</code></strong></dt>
<dd>Dictionary mapping scene IDs to Scene objects.</dd>
<dt><strong><code>input_func</code></strong></dt>
<dd>Optional custom input function (default: input()).</dd>
<dt><strong><code>output_func</code></strong></dt>
<dd>Optional custom output function (default: print()).</dd>
<dt><strong><code>victory_conditions</code></strong></dt>
<dd>Optional set of flags that trigger victory.</dd>
<dt><strong><code>defeat_conditions</code></strong></dt>
<dd>Optional set of flags that trigger defeat.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If current scene is not in scenes dict.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="space_hulk_game.engine.TextAdventureEngine.handle_drop"><code class="name flex">
<span>def <span class="ident">handle_drop</span></span>(<span>self, item_id: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_drop(self, item_id: str) -&gt; None:
    &#34;&#34;&#34;
    Handle dropping an item from inventory.

    Args:
        item_id: The ID or name of the item to drop.
    &#34;&#34;&#34;
    if not self.game_state.has_item(item_id):
        self._output(f&#34;\nYou don&#39;t have &#39;{item_id}&#39;.\n&#34;)
        logger.debug(f&#34;Item not in inventory: {item_id}&#34;)
        return

    # Get the item from registry
    item = self._item_registry.get(item_id)
    if item is None:
        # Item not in registry - create a basic item as fallback
        item = Item(
            id=item_id,
            name=item_id.replace(&#34;_&#34;, &#34; &#34;).title(),
            description=f&#34;A {item_id.replace(&#39;_&#39;, &#39; &#39;)}.&#34;,
            takeable=True,
        )
        self._item_registry[item_id] = item

    # Remove from inventory
    self.game_state.remove_item(item_id)

    # Add to current scene
    current_scene = self.scenes[self.game_state.current_scene]
    current_scene.add_item(item)

    self._output(f&#34;\nYou drop the {item.name}.\n&#34;)
    logger.info(f&#34;Dropped item: {item_id}&#34;)</code></pre>
</details>
<div class="desc"><p>Handle dropping an item from inventory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item_id</code></strong></dt>
<dd>The ID or name of the item to drop.</dd>
</dl></div>
</dd>
<dt id="space_hulk_game.engine.TextAdventureEngine.handle_help"><code class="name flex">
<span>def <span class="ident">handle_help</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def handle_help(self) -&gt; None:
        &#34;&#34;&#34;
        Display available commands and help text.
        &#34;&#34;&#34;
        help_text = &#34;&#34;&#34;
=== AVAILABLE COMMANDS ===

Movement:
  go &lt;direction&gt;     - Move in a direction (north, south, east, west, etc.)

Interaction:
  take &lt;item&gt;        - Pick up an item
  drop &lt;item&gt;        - Drop an item from your inventory
  use &lt;item&gt;         - Use an item
  use &lt;item&gt; on &lt;target&gt; - Use an item on a target
  look               - Look at the current scene
  look at &lt;target&gt;   - Examine an object or NPC
  talk to &lt;npc&gt;      - Talk to an NPC
  ask &lt;npc&gt; about &lt;topic&gt; - Ask an NPC about something

Inventory:
  inventory          - Show your inventory (or &#39;inv&#39;, &#39;i&#39;)

Other:
  help               - Show this help text (or &#39;h&#39;, &#39;?&#39;)
  quit               - Quit the game (or &#39;exit&#39;, &#39;q&#39;)

Tips:
  - You can use synonyms for most commands (e.g., &#39;get&#39; instead of &#39;take&#39;)
  - The parser is forgiving with typos and variations
  - Explore thoroughly and talk to everyone!
&#34;&#34;&#34;
        self._output(help_text)
        logger.debug(&#34;Displayed help&#34;)</code></pre>
</details>
<div class="desc"><p>Display available commands and help text.</p></div>
</dd>
<dt id="space_hulk_game.engine.TextAdventureEngine.handle_inventory"><code class="name flex">
<span>def <span class="ident">handle_inventory</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_inventory(self) -&gt; None:
    &#34;&#34;&#34;
    Display the player&#39;s inventory.
    &#34;&#34;&#34;
    if not self.game_state.inventory:
        self._output(&#34;\nYour inventory is empty.\n&#34;)
        return

    self._output(&#34;\n=== INVENTORY ===&#34;)
    for item_id in self.game_state.inventory:
        # Format item name nicely
        item_name = item_id.replace(&#34;_&#34;, &#34; &#34;).title()
        self._output(f&#34;  - {item_name}&#34;)
    self._output(&#34;&#34;)

    logger.debug(&#34;Displayed inventory&#34;)</code></pre>
</details>
<div class="desc"><p>Display the player's inventory.</p></div>
</dd>
<dt id="space_hulk_game.engine.TextAdventureEngine.handle_look"><code class="name flex">
<span>def <span class="ident">handle_look</span></span>(<span>self, target: str | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_look(self, target: Optional[str] = None) -&gt; None:
    &#34;&#34;&#34;
    Handle examining the scene or an object.

    Args:
        target: Optional target to examine. If None, examine scene.
    &#34;&#34;&#34;
    current_scene = self.scenes[self.game_state.current_scene]

    if not target:
        # Look at the scene
        self._output(&#34;&#34;)
        self._display_current_scene()
        return

    # Look for item in scene
    item = current_scene.get_item(target)
    if item:
        self._output(f&#34;\n{item.description}\n&#34;)
        logger.debug(f&#34;Examined item: {target}&#34;)
        return

    # Look for NPC in scene
    npc = current_scene.get_npc(target)
    if npc:
        self._output(f&#34;\n{npc.description}\n&#34;)
        logger.debug(f&#34;Examined NPC: {target}&#34;)
        return

    # Not found
    self._output(f&#34;\nYou don&#39;t see &#39;{target}&#39; here.\n&#34;)
    logger.debug(f&#34;Target not found: {target}&#34;)</code></pre>
</details>
<div class="desc"><p>Handle examining the scene or an object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target</code></strong></dt>
<dd>Optional target to examine. If None, examine scene.</dd>
</dl></div>
</dd>
<dt id="space_hulk_game.engine.TextAdventureEngine.handle_move"><code class="name flex">
<span>def <span class="ident">handle_move</span></span>(<span>self, direction: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_move(self, direction: str) -&gt; None:
    &#34;&#34;&#34;
    Handle movement to another scene.

    Args:
        direction: The direction or exit name to move through.
    &#34;&#34;&#34;
    current_scene = self.scenes[self.game_state.current_scene]

    # Check if exit exists and is accessible
    can_exit, reason = current_scene.can_exit(
        direction, self.game_state.inventory, self.game_state.game_flags
    )

    if not can_exit:
        self._output(f&#34;\n{reason}\n&#34;)
        logger.debug(f&#34;Move blocked: {reason}&#34;)
        return

    # Get destination scene
    destination_id = current_scene.exits[direction]

    if destination_id not in self.scenes:
        self._output(f&#34;\nError: Destination &#39;{destination_id}&#39; not found.\n&#34;)
        logger.error(f&#34;Invalid destination: {destination_id}&#34;)
        return

    # Move to new scene
    old_scene_id = self.game_state.current_scene
    self.game_state.visit_scene(destination_id)
    logger.info(f&#34;Moved from {old_scene_id} to {destination_id}&#34;)

    # Display new scene
    self._output(&#34;&#34;)  # Blank line
    self._display_current_scene()

    # Process entry events
    self._process_entry_events()</code></pre>
</details>
<div class="desc"><p>Handle movement to another scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>direction</code></strong></dt>
<dd>The direction or exit name to move through.</dd>
</dl></div>
</dd>
<dt id="space_hulk_game.engine.TextAdventureEngine.handle_take"><code class="name flex">
<span>def <span class="ident">handle_take</span></span>(<span>self, item_id: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_take(self, item_id: str) -&gt; None:
    &#34;&#34;&#34;
    Handle taking an item from the current scene.

    Args:
        item_id: The ID or name of the item to take.
    &#34;&#34;&#34;
    current_scene = self.scenes[self.game_state.current_scene]

    # Find the item in the scene
    item = current_scene.get_item(item_id)

    if not item:
        self._output(f&#34;\nYou don&#39;t see &#39;{item_id}&#39; here.\n&#34;)
        logger.debug(f&#34;Item not found: {item_id}&#34;)
        return

    # Check if item is takeable
    if not item.takeable:
        self._output(f&#34;\nYou can&#39;t take the {item.name}.\n&#34;)
        logger.debug(f&#34;Item not takeable: {item_id}&#34;)
        return

    # Add to inventory and remove from scene
    self.game_state.add_item(item.id)
    current_scene.remove_item(item.id)

    # Register item in registry if not already there
    if item.id not in self._item_registry:
        self._item_registry[item.id] = item

    self._output(f&#34;\nYou take the {item.name}.\n&#34;)
    logger.info(f&#34;Took item: {item.id}&#34;)</code></pre>
</details>
<div class="desc"><p>Handle taking an item from the current scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item_id</code></strong></dt>
<dd>The ID or name of the item to take.</dd>
</dl></div>
</dd>
<dt id="space_hulk_game.engine.TextAdventureEngine.handle_talk"><code class="name flex">
<span>def <span class="ident">handle_talk</span></span>(<span>self, npc_id: str, topic: str | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_talk(self, npc_id: str, topic: Optional[str] = None) -&gt; None:
    &#34;&#34;&#34;
    Handle talking to an NPC.

    Args:
        npc_id: The ID or name of the NPC to talk to.
        topic: Optional dialogue topic.
    &#34;&#34;&#34;
    current_scene = self.scenes[self.game_state.current_scene]

    # Find the NPC
    npc = current_scene.get_npc(npc_id)

    if not npc:
        self._output(f&#34;\nYou don&#39;t see &#39;{npc_id}&#39; here.\n&#34;)
        logger.debug(f&#34;NPC not found: {npc_id}&#34;)
        return

    # Check if can interact
    if not npc.can_interact(self.game_state.game_flags):
        self._output(f&#34;\nThe {npc.name} doesn&#39;t want to talk right now.\n&#34;)
        logger.debug(f&#34;Cannot interact with NPC: {npc_id}&#34;)
        return

    # Get dialogue
    if topic:
        dialogue = npc.get_dialogue(topic, f&#34;The {npc.name} has nothing to say about that.&#34;)
    else:
        # Try default greetings
        dialogue = npc.get_dialogue(&#34;greeting&#34;, None)
        if not dialogue:
            dialogue = npc.get_dialogue(&#34;default&#34;, f&#34;The {npc.name} nods at you.&#34;)

    self._output(f&#39;\n{npc.name}: &#34;{dialogue}&#34;\n&#39;)

    # Give item if configured
    if npc.gives_item and not self.game_state.has_item(npc.gives_item):
        self.game_state.add_item(npc.gives_item)
        self._output(f&#34;The {npc.name} gives you: {npc.gives_item}\n&#34;)
        logger.info(f&#34;Received item from NPC: {npc.gives_item}&#34;)

    logger.debug(f&#34;Talked to NPC: {npc_id}, topic: {topic}&#34;)</code></pre>
</details>
<div class="desc"><p>Handle talking to an NPC.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>npc_id</code></strong></dt>
<dd>The ID or name of the NPC to talk to.</dd>
<dt><strong><code>topic</code></strong></dt>
<dd>Optional dialogue topic.</dd>
</dl></div>
</dd>
<dt id="space_hulk_game.engine.TextAdventureEngine.handle_use"><code class="name flex">
<span>def <span class="ident">handle_use</span></span>(<span>self, item_id: str, target_id: str | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_use(self, item_id: str, target_id: Optional[str] = None) -&gt; None:
    &#34;&#34;&#34;
    Handle using an item.

    Args:
        item_id: The ID of the item to use.
        target_id: Optional target for the item.
    &#34;&#34;&#34;
    # Check if player has the item
    if not self.game_state.has_item(item_id):
        self._output(f&#34;\nYou don&#39;t have &#39;{item_id}&#39;.\n&#34;)
        logger.debug(f&#34;Item not in inventory: {item_id}&#34;)
        return

    # Get the item from registry
    item = self._item_registry.get(item_id)
    if item is None:
        self._output(f&#34;\nYou can&#39;t use the {item_id}.\n&#34;)
        logger.warning(f&#34;Item not in registry: {item_id}&#34;)
        return

    # Check if item is useable
    if not item.useable:
        self._output(f&#34;\nYou can&#39;t use the {item.name}.\n&#34;)
        logger.debug(f&#34;Item not useable: {item_id}&#34;)
        return

    # Check if item has required flag
    if item.required_flag and not self.game_state.get_flag(item.required_flag):
        self._output(f&#34;\nYou can&#39;t use the {item.name} right now.\n&#34;)
        logger.debug(f&#34;Missing required flag for item: {item.required_flag}&#34;)
        return

    # Display use text if available
    if item.use_text:
        self._output(f&#34;\n{item.use_text}\n&#34;)

    # Apply item effects
    effects_applied = False

    # Handle healing effect
    if &#34;heal&#34; in item.effects:
        heal_amount = item.effects[&#34;heal&#34;]
        self.game_state.heal(heal_amount)
        if not item.use_text:
            self._output(f&#34;\nYou use the {item.name}. You feel better! (+{heal_amount} HP)\n&#34;)
        effects_applied = True
        # Remove consumable healing items
        self.game_state.remove_item(item_id)
        logger.info(f&#34;Used healing item: {item_id}, healed {heal_amount} HP&#34;)

    # Handle unlock effect
    if &#34;unlock&#34; in item.effects:
        current_scene = self.scenes[self.game_state.current_scene]
        unlock_target = item.effects[&#34;unlock&#34;]

        # Try to unlock the specified exit or any locked exit that requires this item
        unlocked = False
        for direction, locked_item in list(current_scene.locked_exits.items()):
            if locked_item == item_id or (target_id and direction == target_id):
                current_scene.unlock_exit(direction)
                if not item.use_text:
                    self._output(
                        f&#34;\nYou use the {item.name}. You hear a click as the lock opens.\n&#34;
                    )
                logger.info(f&#34;Unlocked exit: {direction}&#34;)
                unlocked = True
                effects_applied = True
                break

        if not unlocked and not item.use_text:
            self._output(f&#34;\nThe {item.name} doesn&#39;t seem to unlock anything here.\n&#34;)

    # Handle damage effect
    if &#34;damage&#34; in item.effects:
        damage_amount = item.effects[&#34;damage&#34;]
        self.game_state.take_damage(damage_amount)
        if not item.use_text:
            self._output(f&#34;\nYou use the {item.name}. It hurts! (-{damage_amount} HP)\n&#34;)
        effects_applied = True
        logger.info(f&#34;Used damaging item: {item_id}, dealt {damage_amount} damage&#34;)

    # Handle flag setting effect
    if &#34;set_flag&#34; in item.effects:
        flag_name = item.effects[&#34;set_flag&#34;]
        self.game_state.set_flag(flag_name, True)
        if not item.use_text:
            self._output(f&#34;\nYou use the {item.name}.\n&#34;)
        effects_applied = True
        logger.info(f&#34;Set flag from item use: {flag_name}&#34;)

    # If no effects were applied and no use_text, show generic message
    if not effects_applied and not item.use_text:
        self._output(f&#34;\nYou use the {item.name}. Nothing happens.\n&#34;)
        logger.debug(f&#34;Used item with no effects: {item_id}&#34;)</code></pre>
</details>
<div class="desc"><p>Handle using an item.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item_id</code></strong></dt>
<dd>The ID of the item to use.</dd>
<dt><strong><code>target_id</code></strong></dt>
<dd>Optional target for the item.</dd>
</dl></div>
</dd>
<dt id="space_hulk_game.engine.TextAdventureEngine.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self) -&gt; None:
    &#34;&#34;&#34;
    Start the main game loop.

    This method handles:
    1. Initial scene display
    2. Player input collection
    3. Command parsing
    4. Action execution
    5. State updates
    6. Victory/defeat checking

    The loop continues until the player quits, wins, or loses.

    Examples:
        &gt;&gt;&gt; engine = TextAdventureEngine(state, scenes)
        &gt;&gt;&gt; # engine.run()  # Starts interactive game
    &#34;&#34;&#34;
    self.running = True
    logger.info(&#34;Game loop started&#34;)

    # Display intro and current scene
    self._display_welcome()
    self._display_current_scene()
    self._process_entry_events()

    # Main game loop
    while self.running:
        try:
            # Check win/loss conditions
            if self._check_victory():
                self._display_victory()
                break

            if self._check_defeat():
                self._display_defeat()
                break

            # Get player input
            try:
                command = self.input_func()
            except (EOFError, KeyboardInterrupt):
                self._output(&#34;\n\nGoodbye!&#34;)
                break

            if not command or not command.strip():
                continue

            # Handle quit commands
            if command.strip().lower() in [&#34;quit&#34;, &#34;exit&#34;, &#34;q&#34;]:
                if self._confirm_quit():
                    self._output(&#34;\nThanks for playing!&#34;)
                    break
                continue

            # Parse and execute command
            current_scene = self.scenes[self.game_state.current_scene]
            action = self.parser.parse(command, self.game_state, current_scene)

            self._execute_action(action)

        except Exception as e:
            logger.exception(&#34;Error in game loop&#34;)
            self._output(f&#34;\nAn error occurred: {e}&#34;)
            self._output(&#34;Please try another command.\n&#34;)

    self.running = False
    logger.info(&#34;Game loop ended&#34;)</code></pre>
</details>
<div class="desc"><p>Start the main game loop.</p>
<p>This method handles:
1. Initial scene display
2. Player input collection
3. Command parsing
4. Action execution
5. State updates
6. Victory/defeat checking</p>
<p>The loop continues until the player quits, wins, or loses.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; engine = TextAdventureEngine(state, scenes)
&gt;&gt;&gt; # engine.run()  # Starts interactive game
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.engine.UnknownAction"><code class="flex name class">
<span>class <span class="ident">UnknownAction</span></span>
<span>(</span><span>raw_command: str = '', suggestion: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class UnknownAction(Action):
    &#34;&#34;&#34;
    Represents an unrecognized command.

    Attributes:
        raw_command: The original text command from the player.
        suggestion: Optional suggestion for what the player might have meant.

    Examples:
        &gt;&gt;&gt; action = UnknownAction(raw_command=&#34;xyz&#34;, suggestion=&#34;examine&#34;)
        &gt;&gt;&gt; action.suggestion
        &#39;examine&#39;
    &#34;&#34;&#34;

    suggestion: Optional[str] = None

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Return a string representation of the action.&#34;&#34;&#34;
        if self.suggestion:
            return f&#34;UnknownAction(suggestion=&#39;{self.suggestion}&#39;)&#34;
        return &#34;UnknownAction()&#34;</code></pre>
</details>
<div class="desc"><p>Represents an unrecognized command.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>raw_command</code></strong></dt>
<dd>The original text command from the player.</dd>
<dt><strong><code>suggestion</code></strong></dt>
<dd>Optional suggestion for what the player might have meant.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; action = UnknownAction(raw_command=&quot;xyz&quot;, suggestion=&quot;examine&quot;)
&gt;&gt;&gt; action.suggestion
'examine'
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="space_hulk_game.engine.actions.Action" href="actions.html#space_hulk_game.engine.actions.Action">Action</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="space_hulk_game.engine.UnknownAction.suggestion"><code class="name">var <span class="ident">suggestion</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.engine.UseAction"><code class="flex name class">
<span>class <span class="ident">UseAction</span></span>
<span>(</span><span>raw_command: str = '', item_id: str = '', target_id: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class UseAction(Action):
    &#34;&#34;&#34;
    Represents using an item.

    Attributes:
        item_id: The ID or name of the item to use.
        target_id: Optional target for the item (e.g., &#34;use key on door&#34;).
        raw_command: The original text command from the player.

    Examples:
        &gt;&gt;&gt; action = UseAction(item_id=&#34;medkit&#34;, raw_command=&#34;use medkit&#34;)
        &gt;&gt;&gt; action.item_id
        &#39;medkit&#39;

        &gt;&gt;&gt; action2 = UseAction(item_id=&#34;key&#34;, target_id=&#34;door&#34;, raw_command=&#34;use key on door&#34;)
        &gt;&gt;&gt; action2.target_id
        &#39;door&#39;
    &#34;&#34;&#34;

    item_id: str = &#34;&#34;
    target_id: Optional[str] = None

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Return a string representation of the action.&#34;&#34;&#34;
        if self.target_id:
            return f&#34;UseAction(item_id=&#39;{self.item_id}&#39;, target_id=&#39;{self.target_id}&#39;)&#34;
        return f&#34;UseAction(item_id=&#39;{self.item_id}&#39;)&#34;</code></pre>
</details>
<div class="desc"><p>Represents using an item.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>item_id</code></strong></dt>
<dd>The ID or name of the item to use.</dd>
<dt><strong><code>target_id</code></strong></dt>
<dd>Optional target for the item (e.g., "use key on door").</dd>
<dt><strong><code>raw_command</code></strong></dt>
<dd>The original text command from the player.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; action = UseAction(item_id=&quot;medkit&quot;, raw_command=&quot;use medkit&quot;)
&gt;&gt;&gt; action.item_id
'medkit'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; action2 = UseAction(item_id=&quot;key&quot;, target_id=&quot;door&quot;, raw_command=&quot;use key on door&quot;)
&gt;&gt;&gt; action2.target_id
'door'
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="space_hulk_game.engine.actions.Action" href="actions.html#space_hulk_game.engine.actions.Action">Action</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="space_hulk_game.engine.UseAction.item_id"><code class="name">var <span class="ident">item_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.UseAction.target_id"><code class="name">var <span class="ident">target_id</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.engine.ValidationError"><code class="flex name class">
<span>class <span class="ident">ValidationError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValidationError(LoaderError):
    &#34;&#34;&#34;Raised when loaded content fails validation.&#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>Raised when loaded content fails validation.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="space_hulk_game.engine.loader.LoaderError" href="loader.html#space_hulk_game.engine.loader.LoaderError">LoaderError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="space_hulk_game.engine.ValidationResult"><code class="flex name class">
<span>class <span class="ident">ValidationResult</span></span>
<span>(</span><span>issues: list[str] = &lt;factory&gt;,<br>suggestions: dict[str, list[str]] = &lt;factory&gt;,<br>warnings: list[str] = &lt;factory&gt;,<br>stats: dict[str, typing.Any] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ValidationResult:
    &#34;&#34;&#34;
    Result of game validation containing issues and suggested fixes.

    Attributes:
        issues: List of validation issues found.
        suggestions: Dictionary mapping scene IDs to suggested fixes.
        warnings: List of non-critical warnings.
        stats: Dictionary containing validation statistics.

    Examples:
        Create a validation result:
        &gt;&gt;&gt; result = ValidationResult(
        ...     issues=[&#34;Scene &#39;vault&#39; is unreachable&#34;],
        ...     suggestions={&#34;entrance&#34;: [&#34;Add exit to &#39;vault&#39;&#34;]},
        ...     warnings=[&#34;Scene &#39;dark_room&#39; has no description&#34;]
        ... )
        &gt;&gt;&gt; result.is_valid()
        False
        &gt;&gt;&gt; len(result.issues)
        1
    &#34;&#34;&#34;

    issues: list[str] = field(default_factory=list)
    suggestions: dict[str, list[str]] = field(default_factory=dict)
    warnings: list[str] = field(default_factory=list)
    stats: dict[str, Any] = field(default_factory=dict)

    def is_valid(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if the game passed validation (no critical issues).

        Returns:
            True if there are no critical issues, False otherwise.

        Examples:
            &gt;&gt;&gt; result = ValidationResult()
            &gt;&gt;&gt; result.is_valid()
            True
            &gt;&gt;&gt; result.issues.append(&#34;Critical error&#34;)
            &gt;&gt;&gt; result.is_valid()
            False
        &#34;&#34;&#34;
        return len(self.issues) == 0

    def add_issue(self, issue: str) -&gt; None:
        &#34;&#34;&#34;
        Add a critical issue to the validation result.

        Args:
            issue: Description of the issue.

        Examples:
            &gt;&gt;&gt; result = ValidationResult()
            &gt;&gt;&gt; result.add_issue(&#34;Scene missing&#34;)
            &gt;&gt;&gt; len(result.issues)
            1
        &#34;&#34;&#34;
        self.issues.append(issue)
        logger.warning(f&#34;Validation issue: {issue}&#34;)

    def add_warning(self, warning: str) -&gt; None:
        &#34;&#34;&#34;
        Add a non-critical warning to the validation result.

        Args:
            warning: Description of the warning.

        Examples:
            &gt;&gt;&gt; result = ValidationResult()
            &gt;&gt;&gt; result.add_warning(&#34;Minor issue&#34;)
            &gt;&gt;&gt; len(result.warnings)
            1
        &#34;&#34;&#34;
        self.warnings.append(warning)
        logger.info(f&#34;Validation warning: {warning}&#34;)

    def add_suggestion(self, scene_id: str, suggestion: str) -&gt; None:
        &#34;&#34;&#34;
        Add a suggested fix for a scene.

        Args:
            scene_id: The scene ID that needs fixing.
            suggestion: Suggested action to fix the issue.

        Examples:
            &gt;&gt;&gt; result = ValidationResult()
            &gt;&gt;&gt; result.add_suggestion(&#34;entrance&#34;, &#34;Add exit to corridor&#34;)
            &gt;&gt;&gt; &#34;entrance&#34; in result.suggestions
            True
        &#34;&#34;&#34;
        if scene_id not in self.suggestions:
            self.suggestions[scene_id] = []
        self.suggestions[scene_id].append(suggestion)
        logger.debug(f&#34;Suggestion for {scene_id}: {suggestion}&#34;)

    def get_summary(self) -&gt; str:
        &#34;&#34;&#34;
        Get a human-readable summary of the validation results.

        Returns:
            Formatted string summarizing the validation.

        Examples:
            &gt;&gt;&gt; result = ValidationResult(issues=[&#34;Error 1&#34;], warnings=[&#34;Warning 1&#34;])
            &gt;&gt;&gt; summary = result.get_summary()
            &gt;&gt;&gt; &#34;1 issue&#34; in summary
            True
        &#34;&#34;&#34;
        lines = []
        lines.append(&#34;Validation Summary:&#34;)
        lines.append(f&#34;  Status: {&#39;PASSED&#39; if self.is_valid() else &#39;FAILED&#39;}&#34;)
        lines.append(f&#34;  Critical Issues: {len(self.issues)}&#34;)
        lines.append(f&#34;  Warnings: {len(self.warnings)}&#34;)
        lines.append(f&#34;  Suggestions: {len(self.suggestions)}&#34;)

        if self.stats:
            lines.append(&#34;\nStatistics:&#34;)
            for key, value in self.stats.items():
                lines.append(f&#34;  {key}: {value}&#34;)

        if self.issues:
            lines.append(&#34;\nCritical Issues:&#34;)
            for issue in self.issues:
                lines.append(f&#34;  - {issue}&#34;)

        if self.warnings:
            lines.append(&#34;\nWarnings:&#34;)
            for warning in self.warnings:
                lines.append(f&#34;  - {warning}&#34;)

        if self.suggestions:
            lines.append(&#34;\nSuggested Fixes:&#34;)
            for scene_id, suggestions in self.suggestions.items():
                lines.append(f&#34;  {scene_id}:&#34;)
                for suggestion in suggestions:
                    lines.append(f&#34;    - {suggestion}&#34;)

        return &#34;\n&#34;.join(lines)</code></pre>
</details>
<div class="desc"><p>Result of game validation containing issues and suggested fixes.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>issues</code></strong></dt>
<dd>List of validation issues found.</dd>
<dt><strong><code>suggestions</code></strong></dt>
<dd>Dictionary mapping scene IDs to suggested fixes.</dd>
<dt><strong><code>warnings</code></strong></dt>
<dd>List of non-critical warnings.</dd>
<dt><strong><code>stats</code></strong></dt>
<dd>Dictionary containing validation statistics.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Create a validation result:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; result = ValidationResult(
...     issues=[&quot;Scene 'vault' is unreachable&quot;],
...     suggestions={&quot;entrance&quot;: [&quot;Add exit to 'vault'&quot;]},
...     warnings=[&quot;Scene 'dark_room' has no description&quot;]
... )
&gt;&gt;&gt; result.is_valid()
False
&gt;&gt;&gt; len(result.issues)
1
</code></pre></div>
<h3>Instance variables</h3>
<dl>
<dt id="space_hulk_game.engine.ValidationResult.issues"><code class="name">var <span class="ident">issues</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.ValidationResult.stats"><code class="name">var <span class="ident">stats</span> : dict[str, typing.Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.ValidationResult.suggestions"><code class="name">var <span class="ident">suggestions</span> : dict[str, list[str]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="space_hulk_game.engine.ValidationResult.warnings"><code class="name">var <span class="ident">warnings</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="space_hulk_game.engine.ValidationResult.add_issue"><code class="name flex">
<span>def <span class="ident">add_issue</span></span>(<span>self, issue: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_issue(self, issue: str) -&gt; None:
    &#34;&#34;&#34;
    Add a critical issue to the validation result.

    Args:
        issue: Description of the issue.

    Examples:
        &gt;&gt;&gt; result = ValidationResult()
        &gt;&gt;&gt; result.add_issue(&#34;Scene missing&#34;)
        &gt;&gt;&gt; len(result.issues)
        1
    &#34;&#34;&#34;
    self.issues.append(issue)
    logger.warning(f&#34;Validation issue: {issue}&#34;)</code></pre>
</details>
<div class="desc"><p>Add a critical issue to the validation result.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>issue</code></strong></dt>
<dd>Description of the issue.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; result = ValidationResult()
&gt;&gt;&gt; result.add_issue(&quot;Scene missing&quot;)
&gt;&gt;&gt; len(result.issues)
1
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.ValidationResult.add_suggestion"><code class="name flex">
<span>def <span class="ident">add_suggestion</span></span>(<span>self, scene_id: str, suggestion: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_suggestion(self, scene_id: str, suggestion: str) -&gt; None:
    &#34;&#34;&#34;
    Add a suggested fix for a scene.

    Args:
        scene_id: The scene ID that needs fixing.
        suggestion: Suggested action to fix the issue.

    Examples:
        &gt;&gt;&gt; result = ValidationResult()
        &gt;&gt;&gt; result.add_suggestion(&#34;entrance&#34;, &#34;Add exit to corridor&#34;)
        &gt;&gt;&gt; &#34;entrance&#34; in result.suggestions
        True
    &#34;&#34;&#34;
    if scene_id not in self.suggestions:
        self.suggestions[scene_id] = []
    self.suggestions[scene_id].append(suggestion)
    logger.debug(f&#34;Suggestion for {scene_id}: {suggestion}&#34;)</code></pre>
</details>
<div class="desc"><p>Add a suggested fix for a scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scene_id</code></strong></dt>
<dd>The scene ID that needs fixing.</dd>
<dt><strong><code>suggestion</code></strong></dt>
<dd>Suggested action to fix the issue.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; result = ValidationResult()
&gt;&gt;&gt; result.add_suggestion(&quot;entrance&quot;, &quot;Add exit to corridor&quot;)
&gt;&gt;&gt; &quot;entrance&quot; in result.suggestions
True
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.ValidationResult.add_warning"><code class="name flex">
<span>def <span class="ident">add_warning</span></span>(<span>self, warning: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_warning(self, warning: str) -&gt; None:
    &#34;&#34;&#34;
    Add a non-critical warning to the validation result.

    Args:
        warning: Description of the warning.

    Examples:
        &gt;&gt;&gt; result = ValidationResult()
        &gt;&gt;&gt; result.add_warning(&#34;Minor issue&#34;)
        &gt;&gt;&gt; len(result.warnings)
        1
    &#34;&#34;&#34;
    self.warnings.append(warning)
    logger.info(f&#34;Validation warning: {warning}&#34;)</code></pre>
</details>
<div class="desc"><p>Add a non-critical warning to the validation result.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>warning</code></strong></dt>
<dd>Description of the warning.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; result = ValidationResult()
&gt;&gt;&gt; result.add_warning(&quot;Minor issue&quot;)
&gt;&gt;&gt; len(result.warnings)
1
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.ValidationResult.get_summary"><code class="name flex">
<span>def <span class="ident">get_summary</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_summary(self) -&gt; str:
    &#34;&#34;&#34;
    Get a human-readable summary of the validation results.

    Returns:
        Formatted string summarizing the validation.

    Examples:
        &gt;&gt;&gt; result = ValidationResult(issues=[&#34;Error 1&#34;], warnings=[&#34;Warning 1&#34;])
        &gt;&gt;&gt; summary = result.get_summary()
        &gt;&gt;&gt; &#34;1 issue&#34; in summary
        True
    &#34;&#34;&#34;
    lines = []
    lines.append(&#34;Validation Summary:&#34;)
    lines.append(f&#34;  Status: {&#39;PASSED&#39; if self.is_valid() else &#39;FAILED&#39;}&#34;)
    lines.append(f&#34;  Critical Issues: {len(self.issues)}&#34;)
    lines.append(f&#34;  Warnings: {len(self.warnings)}&#34;)
    lines.append(f&#34;  Suggestions: {len(self.suggestions)}&#34;)

    if self.stats:
        lines.append(&#34;\nStatistics:&#34;)
        for key, value in self.stats.items():
            lines.append(f&#34;  {key}: {value}&#34;)

    if self.issues:
        lines.append(&#34;\nCritical Issues:&#34;)
        for issue in self.issues:
            lines.append(f&#34;  - {issue}&#34;)

    if self.warnings:
        lines.append(&#34;\nWarnings:&#34;)
        for warning in self.warnings:
            lines.append(f&#34;  - {warning}&#34;)

    if self.suggestions:
        lines.append(&#34;\nSuggested Fixes:&#34;)
        for scene_id, suggestions in self.suggestions.items():
            lines.append(f&#34;  {scene_id}:&#34;)
            for suggestion in suggestions:
                lines.append(f&#34;    - {suggestion}&#34;)

    return &#34;\n&#34;.join(lines)</code></pre>
</details>
<div class="desc"><p>Get a human-readable summary of the validation results.</p>
<h2 id="returns">Returns</h2>
<p>Formatted string summarizing the validation.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; result = ValidationResult(issues=[&quot;Error 1&quot;], warnings=[&quot;Warning 1&quot;])
&gt;&gt;&gt; summary = result.get_summary()
&gt;&gt;&gt; &quot;1 issue&quot; in summary
True
</code></pre></div>
</dd>
<dt id="space_hulk_game.engine.ValidationResult.is_valid"><code class="name flex">
<span>def <span class="ident">is_valid</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid(self) -&gt; bool:
    &#34;&#34;&#34;
    Check if the game passed validation (no critical issues).

    Returns:
        True if there are no critical issues, False otherwise.

    Examples:
        &gt;&gt;&gt; result = ValidationResult()
        &gt;&gt;&gt; result.is_valid()
        True
        &gt;&gt;&gt; result.issues.append(&#34;Critical error&#34;)
        &gt;&gt;&gt; result.is_valid()
        False
    &#34;&#34;&#34;
    return len(self.issues) == 0</code></pre>
</details>
<div class="desc"><p>Check if the game passed validation (no critical issues).</p>
<h2 id="returns">Returns</h2>
<p>True if there are no critical issues, False otherwise.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; result = ValidationResult()
&gt;&gt;&gt; result.is_valid()
True
&gt;&gt;&gt; result.issues.append(&quot;Critical error&quot;)
&gt;&gt;&gt; result.is_valid()
False
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="space_hulk_game.engine.YAMLParseError"><code class="flex name class">
<span>class <span class="ident">YAMLParseError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class YAMLParseError(LoaderError):
    &#34;&#34;&#34;Raised when YAML parsing fails.&#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>Raised when YAML parsing fails.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="space_hulk_game.engine.loader.LoaderError" href="loader.html#space_hulk_game.engine.loader.LoaderError">LoaderError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="space_hulk_game" href="../index.html">space_hulk_game</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="space_hulk_game.engine.actions" href="actions.html">space_hulk_game.engine.actions</a></code></li>
<li><code><a title="space_hulk_game.engine.engine" href="engine.html">space_hulk_game.engine.engine</a></code></li>
<li><code><a title="space_hulk_game.engine.entities" href="entities.html">space_hulk_game.engine.entities</a></code></li>
<li><code><a title="space_hulk_game.engine.game_data" href="game_data.html">space_hulk_game.engine.game_data</a></code></li>
<li><code><a title="space_hulk_game.engine.game_state" href="game_state.html">space_hulk_game.engine.game_state</a></code></li>
<li><code><a title="space_hulk_game.engine.loader" href="loader.html">space_hulk_game.engine.loader</a></code></li>
<li><code><a title="space_hulk_game.engine.parser" href="parser.html">space_hulk_game.engine.parser</a></code></li>
<li><code><a title="space_hulk_game.engine.persistence" href="persistence.html">space_hulk_game.engine.persistence</a></code></li>
<li><code><a title="space_hulk_game.engine.scene" href="scene.html">space_hulk_game.engine.scene</a></code></li>
<li><code><a title="space_hulk_game.engine.validator" href="validator.html">space_hulk_game.engine.validator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="space_hulk_game.engine.delete_save" href="#space_hulk_game.engine.delete_save">delete_save</a></code></li>
<li><code><a title="space_hulk_game.engine.get_save_metadata" href="#space_hulk_game.engine.get_save_metadata">get_save_metadata</a></code></li>
<li><code><a title="space_hulk_game.engine.list_save_files" href="#space_hulk_game.engine.list_save_files">list_save_files</a></code></li>
<li><code><a title="space_hulk_game.engine.load_game" href="#space_hulk_game.engine.load_game">load_game</a></code></li>
<li><code><a title="space_hulk_game.engine.save_game" href="#space_hulk_game.engine.save_game">save_game</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="space_hulk_game.engine.Action" href="#space_hulk_game.engine.Action">Action</a></code></h4>
<ul class="">
<li><code><a title="space_hulk_game.engine.Action.raw_command" href="#space_hulk_game.engine.Action.raw_command">raw_command</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.CommandParser" href="#space_hulk_game.engine.CommandParser">CommandParser</a></code></h4>
<ul class="">
<li><code><a title="space_hulk_game.engine.CommandParser.COMMANDS" href="#space_hulk_game.engine.CommandParser.COMMANDS">COMMANDS</a></code></li>
<li><code><a title="space_hulk_game.engine.CommandParser.CUTOFF" href="#space_hulk_game.engine.CommandParser.CUTOFF">CUTOFF</a></code></li>
<li><code><a title="space_hulk_game.engine.CommandParser.parse" href="#space_hulk_game.engine.CommandParser.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.ContentLoader" href="#space_hulk_game.engine.ContentLoader">ContentLoader</a></code></h4>
<ul class="">
<li><code><a title="space_hulk_game.engine.ContentLoader.load_game" href="#space_hulk_game.engine.ContentLoader.load_game">load_game</a></code></li>
<li><code><a title="space_hulk_game.engine.ContentLoader.load_yaml" href="#space_hulk_game.engine.ContentLoader.load_yaml">load_yaml</a></code></li>
<li><code><a title="space_hulk_game.engine.ContentLoader.merge_into_game_data" href="#space_hulk_game.engine.ContentLoader.merge_into_game_data">merge_into_game_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.DropAction" href="#space_hulk_game.engine.DropAction">DropAction</a></code></h4>
<ul class="">
<li><code><a title="space_hulk_game.engine.DropAction.item_id" href="#space_hulk_game.engine.DropAction.item_id">item_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.Event" href="#space_hulk_game.engine.Event">Event</a></code></h4>
<ul class="two-column">
<li><code><a title="space_hulk_game.engine.Event.can_trigger" href="#space_hulk_game.engine.Event.can_trigger">can_trigger</a></code></li>
<li><code><a title="space_hulk_game.engine.Event.description" href="#space_hulk_game.engine.Event.description">description</a></code></li>
<li><code><a title="space_hulk_game.engine.Event.effects" href="#space_hulk_game.engine.Event.effects">effects</a></code></li>
<li><code><a title="space_hulk_game.engine.Event.from_dict" href="#space_hulk_game.engine.Event.from_dict">from_dict</a></code></li>
<li><code><a title="space_hulk_game.engine.Event.id" href="#space_hulk_game.engine.Event.id">id</a></code></li>
<li><code><a title="space_hulk_game.engine.Event.one_time" href="#space_hulk_game.engine.Event.one_time">one_time</a></code></li>
<li><code><a title="space_hulk_game.engine.Event.required_flag" href="#space_hulk_game.engine.Event.required_flag">required_flag</a></code></li>
<li><code><a title="space_hulk_game.engine.Event.reset" href="#space_hulk_game.engine.Event.reset">reset</a></code></li>
<li><code><a title="space_hulk_game.engine.Event.to_dict" href="#space_hulk_game.engine.Event.to_dict">to_dict</a></code></li>
<li><code><a title="space_hulk_game.engine.Event.trigger" href="#space_hulk_game.engine.Event.trigger">trigger</a></code></li>
<li><code><a title="space_hulk_game.engine.Event.trigger_on_entry" href="#space_hulk_game.engine.Event.trigger_on_entry">trigger_on_entry</a></code></li>
<li><code><a title="space_hulk_game.engine.Event.triggered" href="#space_hulk_game.engine.Event.triggered">triggered</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.GameData" href="#space_hulk_game.engine.GameData">GameData</a></code></h4>
<ul class="two-column">
<li><code><a title="space_hulk_game.engine.GameData.description" href="#space_hulk_game.engine.GameData.description">description</a></code></li>
<li><code><a title="space_hulk_game.engine.GameData.endings" href="#space_hulk_game.engine.GameData.endings">endings</a></code></li>
<li><code><a title="space_hulk_game.engine.GameData.from_dict" href="#space_hulk_game.engine.GameData.from_dict">from_dict</a></code></li>
<li><code><a title="space_hulk_game.engine.GameData.game_rules" href="#space_hulk_game.engine.GameData.game_rules">game_rules</a></code></li>
<li><code><a title="space_hulk_game.engine.GameData.get_item_definition" href="#space_hulk_game.engine.GameData.get_item_definition">get_item_definition</a></code></li>
<li><code><a title="space_hulk_game.engine.GameData.get_npc_definition" href="#space_hulk_game.engine.GameData.get_npc_definition">get_npc_definition</a></code></li>
<li><code><a title="space_hulk_game.engine.GameData.get_scene" href="#space_hulk_game.engine.GameData.get_scene">get_scene</a></code></li>
<li><code><a title="space_hulk_game.engine.GameData.global_items" href="#space_hulk_game.engine.GameData.global_items">global_items</a></code></li>
<li><code><a title="space_hulk_game.engine.GameData.global_npcs" href="#space_hulk_game.engine.GameData.global_npcs">global_npcs</a></code></li>
<li><code><a title="space_hulk_game.engine.GameData.has_scene" href="#space_hulk_game.engine.GameData.has_scene">has_scene</a></code></li>
<li><code><a title="space_hulk_game.engine.GameData.metadata" href="#space_hulk_game.engine.GameData.metadata">metadata</a></code></li>
<li><code><a title="space_hulk_game.engine.GameData.plot_points" href="#space_hulk_game.engine.GameData.plot_points">plot_points</a></code></li>
<li><code><a title="space_hulk_game.engine.GameData.scenes" href="#space_hulk_game.engine.GameData.scenes">scenes</a></code></li>
<li><code><a title="space_hulk_game.engine.GameData.starting_scene" href="#space_hulk_game.engine.GameData.starting_scene">starting_scene</a></code></li>
<li><code><a title="space_hulk_game.engine.GameData.themes" href="#space_hulk_game.engine.GameData.themes">themes</a></code></li>
<li><code><a title="space_hulk_game.engine.GameData.title" href="#space_hulk_game.engine.GameData.title">title</a></code></li>
<li><code><a title="space_hulk_game.engine.GameData.to_dict" href="#space_hulk_game.engine.GameData.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.GameState" href="#space_hulk_game.engine.GameState">GameState</a></code></h4>
<ul class="two-column">
<li><code><a title="space_hulk_game.engine.GameState.add_item" href="#space_hulk_game.engine.GameState.add_item">add_item</a></code></li>
<li><code><a title="space_hulk_game.engine.GameState.current_scene" href="#space_hulk_game.engine.GameState.current_scene">current_scene</a></code></li>
<li><code><a title="space_hulk_game.engine.GameState.from_dict" href="#space_hulk_game.engine.GameState.from_dict">from_dict</a></code></li>
<li><code><a title="space_hulk_game.engine.GameState.game_flags" href="#space_hulk_game.engine.GameState.game_flags">game_flags</a></code></li>
<li><code><a title="space_hulk_game.engine.GameState.get_flag" href="#space_hulk_game.engine.GameState.get_flag">get_flag</a></code></li>
<li><code><a title="space_hulk_game.engine.GameState.has_item" href="#space_hulk_game.engine.GameState.has_item">has_item</a></code></li>
<li><code><a title="space_hulk_game.engine.GameState.has_visited" href="#space_hulk_game.engine.GameState.has_visited">has_visited</a></code></li>
<li><code><a title="space_hulk_game.engine.GameState.heal" href="#space_hulk_game.engine.GameState.heal">heal</a></code></li>
<li><code><a title="space_hulk_game.engine.GameState.health" href="#space_hulk_game.engine.GameState.health">health</a></code></li>
<li><code><a title="space_hulk_game.engine.GameState.inventory" href="#space_hulk_game.engine.GameState.inventory">inventory</a></code></li>
<li><code><a title="space_hulk_game.engine.GameState.is_alive" href="#space_hulk_game.engine.GameState.is_alive">is_alive</a></code></li>
<li><code><a title="space_hulk_game.engine.GameState.max_health" href="#space_hulk_game.engine.GameState.max_health">max_health</a></code></li>
<li><code><a title="space_hulk_game.engine.GameState.remove_item" href="#space_hulk_game.engine.GameState.remove_item">remove_item</a></code></li>
<li><code><a title="space_hulk_game.engine.GameState.set_flag" href="#space_hulk_game.engine.GameState.set_flag">set_flag</a></code></li>
<li><code><a title="space_hulk_game.engine.GameState.take_damage" href="#space_hulk_game.engine.GameState.take_damage">take_damage</a></code></li>
<li><code><a title="space_hulk_game.engine.GameState.to_dict" href="#space_hulk_game.engine.GameState.to_dict">to_dict</a></code></li>
<li><code><a title="space_hulk_game.engine.GameState.visit_scene" href="#space_hulk_game.engine.GameState.visit_scene">visit_scene</a></code></li>
<li><code><a title="space_hulk_game.engine.GameState.visited_scenes" href="#space_hulk_game.engine.GameState.visited_scenes">visited_scenes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.GameValidator" href="#space_hulk_game.engine.GameValidator">GameValidator</a></code></h4>
<ul class="">
<li><code><a title="space_hulk_game.engine.GameValidator.validate_game" href="#space_hulk_game.engine.GameValidator.validate_game">validate_game</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.HelpAction" href="#space_hulk_game.engine.HelpAction">HelpAction</a></code></h4>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.InventoryAction" href="#space_hulk_game.engine.InventoryAction">InventoryAction</a></code></h4>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.Item" href="#space_hulk_game.engine.Item">Item</a></code></h4>
<ul class="two-column">
<li><code><a title="space_hulk_game.engine.Item.can_use" href="#space_hulk_game.engine.Item.can_use">can_use</a></code></li>
<li><code><a title="space_hulk_game.engine.Item.description" href="#space_hulk_game.engine.Item.description">description</a></code></li>
<li><code><a title="space_hulk_game.engine.Item.effects" href="#space_hulk_game.engine.Item.effects">effects</a></code></li>
<li><code><a title="space_hulk_game.engine.Item.from_dict" href="#space_hulk_game.engine.Item.from_dict">from_dict</a></code></li>
<li><code><a title="space_hulk_game.engine.Item.id" href="#space_hulk_game.engine.Item.id">id</a></code></li>
<li><code><a title="space_hulk_game.engine.Item.name" href="#space_hulk_game.engine.Item.name">name</a></code></li>
<li><code><a title="space_hulk_game.engine.Item.required_flag" href="#space_hulk_game.engine.Item.required_flag">required_flag</a></code></li>
<li><code><a title="space_hulk_game.engine.Item.takeable" href="#space_hulk_game.engine.Item.takeable">takeable</a></code></li>
<li><code><a title="space_hulk_game.engine.Item.to_dict" href="#space_hulk_game.engine.Item.to_dict">to_dict</a></code></li>
<li><code><a title="space_hulk_game.engine.Item.use_text" href="#space_hulk_game.engine.Item.use_text">use_text</a></code></li>
<li><code><a title="space_hulk_game.engine.Item.useable" href="#space_hulk_game.engine.Item.useable">useable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.LoaderError" href="#space_hulk_game.engine.LoaderError">LoaderError</a></code></h4>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.LookAction" href="#space_hulk_game.engine.LookAction">LookAction</a></code></h4>
<ul class="">
<li><code><a title="space_hulk_game.engine.LookAction.target" href="#space_hulk_game.engine.LookAction.target">target</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.MoveAction" href="#space_hulk_game.engine.MoveAction">MoveAction</a></code></h4>
<ul class="">
<li><code><a title="space_hulk_game.engine.MoveAction.direction" href="#space_hulk_game.engine.MoveAction.direction">direction</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.NPC" href="#space_hulk_game.engine.NPC">NPC</a></code></h4>
<ul class="two-column">
<li><code><a title="space_hulk_game.engine.NPC.can_interact" href="#space_hulk_game.engine.NPC.can_interact">can_interact</a></code></li>
<li><code><a title="space_hulk_game.engine.NPC.description" href="#space_hulk_game.engine.NPC.description">description</a></code></li>
<li><code><a title="space_hulk_game.engine.NPC.dialogue" href="#space_hulk_game.engine.NPC.dialogue">dialogue</a></code></li>
<li><code><a title="space_hulk_game.engine.NPC.from_dict" href="#space_hulk_game.engine.NPC.from_dict">from_dict</a></code></li>
<li><code><a title="space_hulk_game.engine.NPC.get_dialogue" href="#space_hulk_game.engine.NPC.get_dialogue">get_dialogue</a></code></li>
<li><code><a title="space_hulk_game.engine.NPC.gives_item" href="#space_hulk_game.engine.NPC.gives_item">gives_item</a></code></li>
<li><code><a title="space_hulk_game.engine.NPC.health" href="#space_hulk_game.engine.NPC.health">health</a></code></li>
<li><code><a title="space_hulk_game.engine.NPC.hostile" href="#space_hulk_game.engine.NPC.hostile">hostile</a></code></li>
<li><code><a title="space_hulk_game.engine.NPC.id" href="#space_hulk_game.engine.NPC.id">id</a></code></li>
<li><code><a title="space_hulk_game.engine.NPC.is_alive" href="#space_hulk_game.engine.NPC.is_alive">is_alive</a></code></li>
<li><code><a title="space_hulk_game.engine.NPC.name" href="#space_hulk_game.engine.NPC.name">name</a></code></li>
<li><code><a title="space_hulk_game.engine.NPC.required_flag" href="#space_hulk_game.engine.NPC.required_flag">required_flag</a></code></li>
<li><code><a title="space_hulk_game.engine.NPC.to_dict" href="#space_hulk_game.engine.NPC.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.PersistenceError" href="#space_hulk_game.engine.PersistenceError">PersistenceError</a></code></h4>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.SaveSystem" href="#space_hulk_game.engine.SaveSystem">SaveSystem</a></code></h4>
<ul class="">
<li><code><a title="space_hulk_game.engine.SaveSystem.delete" href="#space_hulk_game.engine.SaveSystem.delete">delete</a></code></li>
<li><code><a title="space_hulk_game.engine.SaveSystem.get_metadata" href="#space_hulk_game.engine.SaveSystem.get_metadata">get_metadata</a></code></li>
<li><code><a title="space_hulk_game.engine.SaveSystem.list_saves" href="#space_hulk_game.engine.SaveSystem.list_saves">list_saves</a></code></li>
<li><code><a title="space_hulk_game.engine.SaveSystem.load" href="#space_hulk_game.engine.SaveSystem.load">load</a></code></li>
<li><code><a title="space_hulk_game.engine.SaveSystem.save" href="#space_hulk_game.engine.SaveSystem.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.Scene" href="#space_hulk_game.engine.Scene">Scene</a></code></h4>
<ul class="">
<li><code><a title="space_hulk_game.engine.Scene.add_item" href="#space_hulk_game.engine.Scene.add_item">add_item</a></code></li>
<li><code><a title="space_hulk_game.engine.Scene.can_exit" href="#space_hulk_game.engine.Scene.can_exit">can_exit</a></code></li>
<li><code><a title="space_hulk_game.engine.Scene.dark" href="#space_hulk_game.engine.Scene.dark">dark</a></code></li>
<li><code><a title="space_hulk_game.engine.Scene.description" href="#space_hulk_game.engine.Scene.description">description</a></code></li>
<li><code><a title="space_hulk_game.engine.Scene.events" href="#space_hulk_game.engine.Scene.events">events</a></code></li>
<li><code><a title="space_hulk_game.engine.Scene.exits" href="#space_hulk_game.engine.Scene.exits">exits</a></code></li>
<li><code><a title="space_hulk_game.engine.Scene.from_dict" href="#space_hulk_game.engine.Scene.from_dict">from_dict</a></code></li>
<li><code><a title="space_hulk_game.engine.Scene.get_entry_events" href="#space_hulk_game.engine.Scene.get_entry_events">get_entry_events</a></code></li>
<li><code><a title="space_hulk_game.engine.Scene.get_exit_description" href="#space_hulk_game.engine.Scene.get_exit_description">get_exit_description</a></code></li>
<li><code><a title="space_hulk_game.engine.Scene.get_full_description" href="#space_hulk_game.engine.Scene.get_full_description">get_full_description</a></code></li>
<li><code><a title="space_hulk_game.engine.Scene.get_item" href="#space_hulk_game.engine.Scene.get_item">get_item</a></code></li>
<li><code><a title="space_hulk_game.engine.Scene.get_npc" href="#space_hulk_game.engine.Scene.get_npc">get_npc</a></code></li>
<li><code><a title="space_hulk_game.engine.Scene.id" href="#space_hulk_game.engine.Scene.id">id</a></code></li>
<li><code><a title="space_hulk_game.engine.Scene.items" href="#space_hulk_game.engine.Scene.items">items</a></code></li>
<li><code><a title="space_hulk_game.engine.Scene.locked_exits" href="#space_hulk_game.engine.Scene.locked_exits">locked_exits</a></code></li>
<li><code><a title="space_hulk_game.engine.Scene.name" href="#space_hulk_game.engine.Scene.name">name</a></code></li>
<li><code><a title="space_hulk_game.engine.Scene.npcs" href="#space_hulk_game.engine.Scene.npcs">npcs</a></code></li>
<li><code><a title="space_hulk_game.engine.Scene.remove_item" href="#space_hulk_game.engine.Scene.remove_item">remove_item</a></code></li>
<li><code><a title="space_hulk_game.engine.Scene.to_dict" href="#space_hulk_game.engine.Scene.to_dict">to_dict</a></code></li>
<li><code><a title="space_hulk_game.engine.Scene.unlock_exit" href="#space_hulk_game.engine.Scene.unlock_exit">unlock_exit</a></code></li>
<li><code><a title="space_hulk_game.engine.Scene.visited" href="#space_hulk_game.engine.Scene.visited">visited</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.TakeAction" href="#space_hulk_game.engine.TakeAction">TakeAction</a></code></h4>
<ul class="">
<li><code><a title="space_hulk_game.engine.TakeAction.item_id" href="#space_hulk_game.engine.TakeAction.item_id">item_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.TalkAction" href="#space_hulk_game.engine.TalkAction">TalkAction</a></code></h4>
<ul class="">
<li><code><a title="space_hulk_game.engine.TalkAction.npc_id" href="#space_hulk_game.engine.TalkAction.npc_id">npc_id</a></code></li>
<li><code><a title="space_hulk_game.engine.TalkAction.topic" href="#space_hulk_game.engine.TalkAction.topic">topic</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.TextAdventureEngine" href="#space_hulk_game.engine.TextAdventureEngine">TextAdventureEngine</a></code></h4>
<ul class="two-column">
<li><code><a title="space_hulk_game.engine.TextAdventureEngine.handle_drop" href="#space_hulk_game.engine.TextAdventureEngine.handle_drop">handle_drop</a></code></li>
<li><code><a title="space_hulk_game.engine.TextAdventureEngine.handle_help" href="#space_hulk_game.engine.TextAdventureEngine.handle_help">handle_help</a></code></li>
<li><code><a title="space_hulk_game.engine.TextAdventureEngine.handle_inventory" href="#space_hulk_game.engine.TextAdventureEngine.handle_inventory">handle_inventory</a></code></li>
<li><code><a title="space_hulk_game.engine.TextAdventureEngine.handle_look" href="#space_hulk_game.engine.TextAdventureEngine.handle_look">handle_look</a></code></li>
<li><code><a title="space_hulk_game.engine.TextAdventureEngine.handle_move" href="#space_hulk_game.engine.TextAdventureEngine.handle_move">handle_move</a></code></li>
<li><code><a title="space_hulk_game.engine.TextAdventureEngine.handle_take" href="#space_hulk_game.engine.TextAdventureEngine.handle_take">handle_take</a></code></li>
<li><code><a title="space_hulk_game.engine.TextAdventureEngine.handle_talk" href="#space_hulk_game.engine.TextAdventureEngine.handle_talk">handle_talk</a></code></li>
<li><code><a title="space_hulk_game.engine.TextAdventureEngine.handle_use" href="#space_hulk_game.engine.TextAdventureEngine.handle_use">handle_use</a></code></li>
<li><code><a title="space_hulk_game.engine.TextAdventureEngine.run" href="#space_hulk_game.engine.TextAdventureEngine.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.UnknownAction" href="#space_hulk_game.engine.UnknownAction">UnknownAction</a></code></h4>
<ul class="">
<li><code><a title="space_hulk_game.engine.UnknownAction.suggestion" href="#space_hulk_game.engine.UnknownAction.suggestion">suggestion</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.UseAction" href="#space_hulk_game.engine.UseAction">UseAction</a></code></h4>
<ul class="">
<li><code><a title="space_hulk_game.engine.UseAction.item_id" href="#space_hulk_game.engine.UseAction.item_id">item_id</a></code></li>
<li><code><a title="space_hulk_game.engine.UseAction.target_id" href="#space_hulk_game.engine.UseAction.target_id">target_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.ValidationError" href="#space_hulk_game.engine.ValidationError">ValidationError</a></code></h4>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.ValidationResult" href="#space_hulk_game.engine.ValidationResult">ValidationResult</a></code></h4>
<ul class="two-column">
<li><code><a title="space_hulk_game.engine.ValidationResult.add_issue" href="#space_hulk_game.engine.ValidationResult.add_issue">add_issue</a></code></li>
<li><code><a title="space_hulk_game.engine.ValidationResult.add_suggestion" href="#space_hulk_game.engine.ValidationResult.add_suggestion">add_suggestion</a></code></li>
<li><code><a title="space_hulk_game.engine.ValidationResult.add_warning" href="#space_hulk_game.engine.ValidationResult.add_warning">add_warning</a></code></li>
<li><code><a title="space_hulk_game.engine.ValidationResult.get_summary" href="#space_hulk_game.engine.ValidationResult.get_summary">get_summary</a></code></li>
<li><code><a title="space_hulk_game.engine.ValidationResult.is_valid" href="#space_hulk_game.engine.ValidationResult.is_valid">is_valid</a></code></li>
<li><code><a title="space_hulk_game.engine.ValidationResult.issues" href="#space_hulk_game.engine.ValidationResult.issues">issues</a></code></li>
<li><code><a title="space_hulk_game.engine.ValidationResult.stats" href="#space_hulk_game.engine.ValidationResult.stats">stats</a></code></li>
<li><code><a title="space_hulk_game.engine.ValidationResult.suggestions" href="#space_hulk_game.engine.ValidationResult.suggestions">suggestions</a></code></li>
<li><code><a title="space_hulk_game.engine.ValidationResult.warnings" href="#space_hulk_game.engine.ValidationResult.warnings">warnings</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="space_hulk_game.engine.YAMLParseError" href="#space_hulk_game.engine.YAMLParseError">YAMLParseError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
